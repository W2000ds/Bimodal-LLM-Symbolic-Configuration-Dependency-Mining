hadoop.common.configuration.version,version of this configuration file,0.23.0
hadoop.tmp.dir,A base for other temporary directories.,/tmp/hadoop-${user.name}
io.native.lib.available,Controls whether to use native libraries for bz2 and zlib compression codecs or not. The property does not control any other native libraries.  ,true
hadoop.http.filter.initializers,"A comma separated list of class names. Each class in the list  must extend org.apache.hadoop.http.FilterInitializer. The corresponding  Filter will be initialized. Then, the Filter will be applied to all user  facing jsp and servlet web pages.  The ordering of the list defines the  ordering of the filters.",org.apache.hadoop.http.lib.StaticUserWebFilter
hadoop.security.authorization,Is service-level authorization enabled?,false
hadoop.security.instrumentation.requires.admin," Indicates if administrator ACLs are required to access instrumentation servlets (JMX, METRICS, CONF, STACKS).  ",false
hadoop.security.authentication,"Possible values are simple (no authentication), and kerberos  ",simple
hadoop.security.group.mapping," Class for user to group mapping (get groups for a given user) for ACL. The default implementation, org.apache.hadoop.security.JniBasedUnixGroupsMappingWithFallback, will determine if the Java Native Interface (JNI) is available. If JNI is available the implementation will use the API within hadoop to resolve a list of groups for a user. If JNI is not available then the shell implementation, ShellBasedUnixGroupsMapping, is used.  This implementation shells out to the Linux/Unix environment with the ",org.apache.hadoop.security.JniBasedUnixGroupsMappingWithFallback
hadoop.security.dns.interface," The name of the Network Interface from which the service should determine its host name for Kerberos login. e.g. eth2. In a multi-homed environment, the setting can be used to affect the _HOST substitution in the service Kerberos principal. If this configuration value is not set, the service will use its default hostname as returned by InetAddress.getLocalHost().getCanonicalHostName(). Most clusters will not require this setting.  ",
hadoop.security.dns.nameserver, The host name or IP address of the name server (DNS) which a service Node should use to determine its own host name for Kerberos Login. Requires hadoop.security.dns.interface. Most clusters will not require this setting.  ,
hadoop.security.dns.log-slow-lookups.enabled, Time name lookups (via SecurityUtil) and log them if they exceed the configured threshold.  ,false
hadoop.security.dns.log-slow-lookups.threshold.ms," If slow lookup logging is enabled, this threshold is used to decide if a lookup is considered slow enough to be logged.  ",1000
hadoop.security.groups.cache.secs," This is the config controlling the validity of the entries in the cache containing the user->group mapping. When this duration has expired, then the implementation of the group mapping provider is invoked to get the groups of the user and then cached back.  ",300
hadoop.security.groups.negative-cache.secs," Expiration time for entries in the the negative user-to-group mapping caching, in seconds. This is useful when invalid users are retrying frequently. It is suggested to set a small value for this expiration, since a transient error in group lookup could temporarily lock out a legitimate user. Set this to zero or negative value to disable negative user-to-group caching.  ",30
hadoop.security.groups.cache.warn.after.ms," If looking up a single user to group takes longer than this amount of milliseconds, we will log a warning message.  ",5000
hadoop.security.groups.cache.background.reload," Whether to reload expired user->group mappings using a background thread pool. If set to true, a pool of hadoop.security.groups.cache.background.reload.threads is created to update the cache in the background.  ",false
hadoop.security.groups.cache.background.reload.threads, Only relevant if hadoop.security.groups.cache.background.reload is true. Controls the number of concurrent background user->group cache entry refreshes. Pending refresh requests beyond this value are queued and processed when a thread is free.  ,3
hadoop.security.groups.shell.command.timeout," Used by the ShellBasedUnixGroupsMapping class, this property controls how long to wait for the underlying shell command that is run to fetch groups. Expressed in seconds (e.g. 10s, 1m, etc.), if the running command takes longer than the value configured, the command is aborted and the groups resolver would return a result of no groups found. A value of 0s (default) would mean an infinite wait (i.e. wait until the command exits on its own).  ",0s
hadoop.security.group.mapping.ldap.connection.timeout.ms," This property is the connection timeout (in milliseconds) for LDAP operations. If the LDAP provider doesn't establish a connection within the specified period, it will abort the connect attempt. Non-positive value means no LDAP connection timeout is specified in which case it waits for the connection to establish until the underlying network times out.  ",60000
hadoop.security.group.mapping.ldap.read.timeout.ms," This property is the read timeout (in milliseconds) for LDAP operations. If the LDAP provider doesn't get a LDAP response within the specified period, it will abort the read attempt. Non-positive value means no read timeout is specified in which case it waits for the response infinitely.  ",60000
hadoop.security.group.mapping.ldap.url, The URL of the LDAP server to use for resolving user groups when using the LdapGroupsMapping user to group mapping.  ,
hadoop.security.group.mapping.ldap.ssl, Whether or not to use SSL when connecting to the LDAP server.  ,false
hadoop.security.group.mapping.ldap.ssl.keystore, File path to the SSL keystore that contains the SSL certificate required by the LDAP server.  ,
hadoop.security.group.mapping.ldap.ssl.keystore.password.file," The path to a file containing the password of the LDAP SSL keystore. If the password is not configured in credential providers and the property hadoop.security.group.mapping.ldap.ssl.keystore.password is not set, LDAPGroupsMapping reads password from the file. IMPORTANT: This file should be readable only by the Unix user running the daemons and should be a local file.  ",
hadoop.security.group.mapping.ldap.ssl.keystore.password, The password of the LDAP SSL keystore. this property name is used as an alias to get the password from credential providers. If the password can not be found and hadoop.security.credential.clear-text-fallback is true LDAPGroupsMapping uses the value of this property for password.  ,
hadoop.security.credential.clear-text-fallback, true or false to indicate whether or not to fall back to storing credential password as clear text. The default value is true. This property only works when the password can't not be found from credential providers.  ,true
hadoop.security.credential.provider.path, A comma-separated list of URLs that indicates the type and location of a list of providers that should be consulted.  ,
hadoop.security.credstore.java-keystore-provider.password-file, The path to a file containing the custom password for all keystores that may be configured in the provider path.  ,
hadoop.security.group.mapping.ldap.ssl.truststore, File path to the SSL truststore that contains the root certificate used to sign the LDAP server's certificate. Specify this if the LDAP server's certificate is not signed by a well known certificate authority.  ,
hadoop.security.group.mapping.ldap.ssl.truststore.password.file, The path to a file containing the password of the LDAP SSL truststore. IMPORTANT: This file should be readable only by the Unix user running the daemons.  ,
hadoop.security.group.mapping.ldap.bind.user, The distinguished name of the user to bind as when connecting to the LDAP server. This may be left blank if the LDAP server supports anonymous binds.  ,
hadoop.security.group.mapping.ldap.bind.password.file," The path to a file containing the password of the bind user. If the password is not configured in credential providers and the property hadoop.security.group.mapping.ldap.bind.password is not set, LDAPGroupsMapping reads password from the file. IMPORTANT: This file should be readable only by the Unix user running the daemons and should be a local file.  ",
hadoop.security.group.mapping.ldap.bind.password, The password of the bind user. this property name is used as an alias to get the password from credential providers. If the password can not be found and hadoop.security.credential.clear-text-fallback is true LDAPGroupsMapping uses the value of this property for password.  ,
hadoop.security.group.mapping.ldap.base," The search base for the LDAP connection. This is a distinguished name, and will typically be the root of the LDAP directory.  ",
hadoop.security.group.mapping.ldap.userbase," The search base for the LDAP connection for user search query. This is a distinguished name, and its the root of the LDAP directory for users. If not set, hadoop.security.group.mapping.ldap.base is used.  ",
hadoop.security.group.mapping.ldap.groupbase," The search base for the LDAP connection for group search . This is a distinguished name, and its the root of the LDAP directory for groups. If not set, hadoop.security.group.mapping.ldap.base is used.  ",
hadoop.security.group.mapping.ldap.search.filter.user," An additional filter to use when searching for LDAP users. The default will usually be appropriate for Active Directory installations. If connecting to an LDAP server with a non-AD schema, this should be replaced with (&(objectClass=inetOrgPerson)(uid={0}). {0} is a special string used to denote where the username fits into the filter. If the LDAP server supports posixGroups, Hadoop can enable the feature by setting the value of this property to ""posixAccount"" and the value of the hadoop.security.group.mapping.ldap.search.filter.group property to ""posixGroup"".  ",(&(objectClass=user)(sAMAccountName={0}))
hadoop.security.group.mapping.ldap.search.filter.group, An additional filter to use when searching for LDAP groups. This should be changed when resolving groups against a non-Active Directory installation. See the description of hadoop.security.group.mapping.ldap.search.filter.user to enable posixGroups support.  ,(objectClass=group)
hadoop.security.group.mapping.ldap.search.attr.memberof,"   The attribute of the user object that identifies its group objects. By   default, Hadoop makes two LDAP queries per user if this value is empty. If   set, Hadoop will attempt to resolve group names from this attribute,   instead of making the second LDAP query to get group objects. The value   should be 'memberOf' for an MS AD installation. ",
hadoop.security.group.mapping.ldap.search.attr.member, The attribute of the group object that identifies the users that are members of the group. The default will usually be appropriate for any LDAP installation.  ,member
hadoop.security.group.mapping.ldap.search.attr.group.name, The attribute of the group object that identifies the group name. The default will usually be appropriate for all LDAP systems.  ,cn
hadoop.security.group.mapping.ldap.search.group.hierarchy.levels, The number of levels to go up the group hierarchy when determining which groups a user is part of. 0 Will represent checking just the group that the user belongs to.  Each additional level will raise the time it takes to execute a query by at most hadoop.security.group.mapping.ldap.directory.search.timeout. The default will usually be appropriate for all LDAP systems.  ,0
hadoop.security.group.mapping.ldap.posix.attr.uid.name, The attribute of posixAccount to use when groups for membership. Mostly useful for schemas wherein groups have memberUids that use an attribute other than uidNumber.  ,uidNumber
hadoop.security.group.mapping.ldap.posix.attr.gid.name, The attribute of posixAccount indicating the group id.  ,gidNumber
hadoop.security.group.mapping.ldap.directory.search.timeout, The attribute applied to the LDAP SearchControl properties to set a maximum time limit when searching and awaiting a result. Set to 0 if infinite wait period is desired. Default is 10 seconds. Units in milliseconds.  ,10000
hadoop.security.group.mapping.providers, Comma separated of names of other providers to provide user to group mapping. Used by CompositeGroupsMapping.  ,
hadoop.security.group.mapping.providers.combined," true or false to indicate whether groups from the providers are combined or not. The default value is true. If true, then all the providers will be tried to get groups and all the groups are combined to return as the final results. Otherwise, providers are tried one by one in the configured list order, and if any groups are retrieved from any provider, then the groups will be returned without trying the left ones.  ",true
hadoop.security.service.user.name.key," For those cases where the same RPC protocol is implemented by multiple servers, this configuration is required for specifying the principal name to use for the service when the client wishes to make an RPC call.  ",
fs.azure.user.agent.prefix,"   WASB passes User-Agent header to the Azure back-end. The default value   contains WASB version, Java Runtime version, Azure Client library version,   and the value of the configuration option fs.azure.user.agent.prefix. ",unknown
hadoop.security.uid.cache.secs,  This is the config controlling the validity of the entries in the cache  containing the userId to userName and groupId to groupName used by  NativeIO getFstat(). ,14400
hadoop.service.shutdown.timeout,"   Timeout to wait for each shutdown operation to complete.   If a hook takes longer than this time to complete, it will be interrupted,   so the service will shutdown. This allows the service shutdown   to recover from a blocked operation.   Some shutdown hooks may need more time than this, for example when   a large amount of data needs to be uploaded to an object store.   In this situation: increase the timeout.   The minimum duration of the timeout is 1 second, ""1s"". ",30s
hadoop.rpc.protection,"A comma-separated list of protection values for secured sasl   connections. Possible values are authentication, integrity and privacy.   authentication means authentication only and no integrity or privacy;   integrity implies authentication and integrity are enabled; and privacy   implies all of authentication, integrity and privacy are enabled.   hadoop.security.saslproperties.resolver.class can be used to override   the hadoop.rpc.protection for a connection at the server side.  ",authentication
hadoop.security.saslproperties.resolver.class,"SaslPropertiesResolver used to resolve the QOP used for a   connection. If not specified, the full set of values specified in   hadoop.rpc.protection is used while determining the QOP used for the   connection. If a class is specified, then the QOP values returned by   the class will be used while determining the QOP used for the connection.  ",
hadoop.security.sensitive-config-keys,"A comma-separated or multi-line list of regular expressions to   match configuration keys that should be redacted where appropriate, for   example, when logging modified properties during a reconfiguration,   private credentials should not be logged.  ","
hadoop.workaround.non.threadsafe.getpwuid,"Some operating systems or authentication modules are known to  have broken implementations of getpwuid_r and getpwgid_r, such that these  calls are not thread-safe. Symptoms of this problem include JVM crashes  with a stack trace inside these functions. If your system exhibits this  issue, enable this configuration parameter to include a lock around the  calls as a workaround.  An incomplete list of some systems known to have this issue is available  at http://wiki.apache.org/hadoop/KnownBrokenPwuidImplementations  ",true
hadoop.kerberos.kinit.command,Used to periodically renew Kerberos credentials when provided  to Hadoop. The default setting assumes that kinit is in the PATH of users  running the Hadoop client. Change this to the absolute path to kinit if this  is not the case.  ,kinit
hadoop.kerberos.min.seconds.before.relogin,"The minimum time between relogin attempts for Kerberos, in seconds. ",60
hadoop.security.auth_to_local,Maps kerberos principals to local user names,
hadoop.token.files,List of token cache files that have delegation tokens for hadoop service,
io.file.buffer.size,"The size of buffer for use in sequence files.  The size of this buffer should probably be a multiple of hardware  page size (4096 on Intel x86), and it determines how much data is  buffered during read and write operations.",4096
io.bytes.per.checksum,The number of bytes per checksum.  Must not be larger than  io.file.buffer.size.,512
io.skip.checksum.errors,"If true, when a checksum error is encountered while  reading a sequence file, entries are skipped, instead of throwing an  exception.",false
io.compression.codecs,"A comma-separated list of the compression codec classes that can  be used for compression/decompression. In addition to any classes specified  with this property (which take precedence), codec classes on the classpath  are discovered using a Java ServiceLoader.",
io.compression.codec.bzip2.library,"The native-code library to be used for compression and  decompression by the bzip2 codec.  This library could be specified  either by by name or the full pathname.  In the former case, the  library is located by the dynamic linker, usually searching the  directories specified in the environment variable LD_LIBRARY_PATH.  The value of ""system-native"" indicates that the default system  library should be used.  To indicate that the algorithm should  operate entirely in Java, specify ""java-builtin"".",system-native
io.serializations,A list of serialization classes that can be used for  obtaining serializers and deserializers.,"org.apache.hadoop.io.serializer.WritableSerialization, org.apache.hadoop.io.serializer.avro.AvroSpecificSerialization, org.apache.hadoop.io.serializer.avro.AvroReflectSerialization"
io.seqfile.local.dir,The local directory where sequence file stores intermediate  data files during merge.  May be a comma-separated list of  directories on different devices in order to spread disk i/o.  Directories that do not exist are ignored.  ,${hadoop.tmp.dir}/io/local
io.map.index.skip,Number of index entries to skip between each entry.  Zero by default. Setting this to values larger than zero can  facilitate opening large MapFiles using less memory.,0
io.map.index.interval," MapFile consist of two files - data file (tuples) and index file (keys). For every io.map.index.interval records written in the data file, an entry (record-key, data-file-position) is written in the index file. This is to allow for doing binary search later within the index file to look up records by their keys and get their closest positions in the data file.  ",128
fs.defaultFS,"The name of the default file system.  A URI whose  scheme and authority determine the FileSystem implementation.  The  uri's scheme determines the config property (fs.SCHEME.impl) naming  the FileSystem implementation class.  The uri's authority is used to  determine the host, port, etc. for a filesystem.",file:///
fs.default.name,Deprecated. Use (fs.defaultFS) property  instead,file:///
fs.trash.interval,"Number of minutes after which the checkpoint  gets deleted.  If zero, the trash feature is disabled.  This option may be configured both on the server and the  client. If trash is disabled server side then the client  side configuration is checked. If trash is enabled on the  server side then the value configured on the server is  used and the client configuration value is ignored.  ",0
fs.trash.checkpoint.interval,"Number of minutes between trash checkpoints.  Should be smaller or equal to fs.trash.interval. If zero,  the value is set to the value of fs.trash.interval.  Every time the checkpointer runs it creates a new checkpoint  out of current and removes checkpoints created more than  fs.trash.interval minutes ago.  ",0
fs.protected.directories,A comma-separated list of directories which cannot be deleted even by the superuser unless they are empty. This setting can be used to guard important system directories against accidental deletion due to administrator error.  ,
fs.AbstractFileSystem.file.impl,The AbstractFileSystem for file: uris.,org.apache.hadoop.fs.local.LocalFs
fs.AbstractFileSystem.har.impl,The AbstractFileSystem for har: uris.,org.apache.hadoop.fs.HarFs
fs.AbstractFileSystem.hdfs.impl,The FileSystem for hdfs: uris.,org.apache.hadoop.fs.Hdfs
fs.AbstractFileSystem.viewfs.impl,The AbstractFileSystem for view file system for viewfs: uris  (ie client side mount table:).,org.apache.hadoop.fs.viewfs.ViewFs
fs.viewfs.rename.strategy,"Allowed rename strategy to rename between multiple mountpoints. Allowed values are SAME_MOUNTPOINT,SAME_TARGET_URI_ACROSS_MOUNTPOINT and SAME_FILESYSTEM_ACROSS_MOUNTPOINT.  ",SAME_MOUNTPOINT
fs.AbstractFileSystem.ftp.impl,The FileSystem for Ftp: uris.,org.apache.hadoop.fs.ftp.FtpFs
fs.AbstractFileSystem.webhdfs.impl,The FileSystem for webhdfs: uris.,org.apache.hadoop.fs.WebHdfs
fs.AbstractFileSystem.swebhdfs.impl,The FileSystem for swebhdfs: uris.,org.apache.hadoop.fs.SWebHdfs
fs.ftp.host,FTP filesystem connects to this server,0.0.0.0
fs.ftp.host.port, FTP filesystem connects to fs.ftp.host on this port  ,21
fs.ftp.data.connection.mode,"Set the FTPClient's data connection mode based on configuration. Valid values are ACTIVE_LOCAL_DATA_CONNECTION_MODE, PASSIVE_LOCAL_DATA_CONNECTION_MODE and PASSIVE_REMOTE_DATA_CONNECTION_MODE.  ",ACTIVE_LOCAL_DATA_CONNECTION_MODE
fs.ftp.transfer.mode," Set FTP's transfer mode based on configuration. Valid values are STREAM_TRANSFER_MODE, BLOCK_TRANSFER_MODE and COMPRESSED_TRANSFER_MODE.  ",BLOCK_TRANSFER_MODE
fs.df.interval,Disk usage statistics refresh interval in msec.,60000
fs.du.interval,File space usage statistics refresh interval in msec.,600000
fs.s3.awsAccessKeyId,AWS access key ID used by S3 block file system.,
fs.s3.awsSecretAccessKey,AWS secret key used by S3 block file system.,
fs.s3.block.size,Block size to use when writing files to S3.,67108864
fs.s3.buffer.dir,Determines where on the local filesystem the s3:/s3n: filesystem  should store files before sending them to S3  (or after retrieving them from S3).  ,${hadoop.tmp.dir}/s3
fs.s3.maxRetries,"The maximum number of retries for reading or writing files to S3,  before we signal failure to the application.  ",4
fs.s3.sleepTimeSeconds,The number of seconds to sleep between each S3 retry.  ,10
fs.swift.impl,The implementation class of the OpenStack Swift Filesystem,org.apache.hadoop.fs.swift.snative.SwiftNativeFileSystem
fs.automatic.close,"By default, FileSystem instances are automatically closed at program  exit using a JVM shutdown hook. Setting this property to false disables this  behavior. This is an advanced option that should only be used by server applications  requiring a more carefully orchestrated shutdown sequence.  ",true
fs.s3n.awsAccessKeyId,AWS access key ID used by S3 native file system.,
fs.s3n.awsSecretAccessKey,AWS secret key used by S3 native file system.,
fs.s3n.block.size,Block size to use when reading files using the native S3  filesystem (s3n: URIs).,67108864
fs.s3n.multipart.uploads.enabled,"Setting this property to true enables multiple uploads to  native S3 filesystem. When uploading a file, it is split into blocks  if the size is larger than fs.s3n.multipart.uploads.block.size.  ",false
fs.s3n.multipart.uploads.block.size,The block size for multipart uploads to native S3 filesystem.  Default size is 64MB.  ,67108864
fs.s3n.multipart.copy.block.size,The block size for multipart copy in native S3 filesystem.  Default size is 5GB.  ,5368709120
fs.s3n.server-side-encryption-algorithm,"Specify a server-side encryption algorithm for S3.  Unset by default, and the only other currently allowable value is AES256.  ",
fs.s3a.access.key,AWS access key ID used by S3A file system. Omit for IAM role-based or provider-based authentication.,
fs.s3a.secret.key,AWS secret key used by S3A file system. Omit for IAM role-based or provider-based authentication.,
fs.s3a.aws.credentials.provider," Comma-separated class names of credential provider classes which implement com.amazonaws.auth.AWSCredentialsProvider. These are loaded and queried in sequence for a valid set of credentials. Each listed class must implement one of the following means of construction, which are attempted in order: 1. a public constructor accepting java.net.URI and  org.apache.hadoop.conf.Configuration, 2. a public static method named getInstance that accepts no    arguments and returns an instance of    com.amazonaws.auth.AWSCredentialsProvider, or 3. a public default constructor. Specifying org.apache.hadoop.fs.s3a.AnonymousAWSCredentialsProvider allows anonymous access to a publicly accessible S3 bucket without any credentials. Please note that allowing anonymous access to an S3 bucket compromises security and therefore is unsuitable for most use cases. It can be useful for accessing public data sets without requiring AWS credentials. If unspecified, then the default list of credential provider classes, queried in sequence, is: 1. org.apache.hadoop.fs.s3a.BasicAWSCredentialsProvider: supports static  configuration of AWS access key ID and secret access key.  See also  fs.s3a.access.key and fs.s3a.secret.key. 2. com.amazonaws.auth.EnvironmentVariableCredentialsProvider: supports  configuration of AWS access key ID and secret access key in  environment variables named AWS_ACCESS_KEY_ID and  AWS_SECRET_ACCESS_KEY, as documented in the AWS SDK. 3. org.apache.hadoop.fs.s3a.SharedInstanceProfileCredentialsProvider:  a shared instance of  com.amazonaws.auth.InstanceProfileCredentialsProvider from the AWS  SDK, which supports use of instance profile credentials if running  in an EC2 VM.  Using this shared instance potentially reduces load  on the EC2 instance metadata service for multi-threaded  applications.  ",
fs.s3a.session.token,"Session token, when using org.apache.hadoop.fs.s3a.TemporaryAWSCredentialsProvider as one of the providers.  ",
fs.s3a.security.credential.provider.path," Optional comma separated list of credential providers, a list which is prepended to that set in hadoop.security.credential.provider.path  ",
fs.s3a.connection.maximum,Controls the maximum number of simultaneous connections to S3.,15
fs.s3a.connection.ssl.enabled,Enables or disables SSL connections to S3.,true
fs.s3a.endpoint,"AWS S3 endpoint to connect to. An up-to-date list is provided in the AWS Documentation: regions and endpoints. Without this property, the standard region (s3.amazonaws.com) is assumed.  ",
fs.s3a.path.style.access,Enable S3 path style access ie disabling the default virtual hosting behaviour. Useful for S3A-compliant storage providers as it removes the need to set up DNS for virtual hosting.  ,false
fs.s3a.proxy.host,Hostname of the (optional) proxy server for S3 connections.,
fs.s3a.proxy.port,"Proxy server port. If this property is not set but fs.s3a.proxy.host is, port 80 or 443 is assumed (consistent with the value of fs.s3a.connection.ssl.enabled).",
fs.s3a.proxy.username,Username for authenticating with proxy server.,
fs.s3a.proxy.password,Password for authenticating with proxy server.,
fs.s3a.proxy.domain,Domain for authenticating with proxy server.,
fs.s3a.proxy.workstation,Workstation for authenticating with proxy server.,
fs.s3a.attempts.maximum,How many times we should retry commands on transient errors.,20
fs.s3a.connection.establish.timeout,Socket connection setup timeout in milliseconds.,5000
fs.s3a.connection.timeout,Socket connection timeout in milliseconds.,200000
fs.s3a.socket.send.buffer,Socket send buffer hint to amazon connector. Represented in bytes.,8192
fs.s3a.socket.recv.buffer,Socket receive buffer hint to amazon connector. Represented in bytes.,8192
fs.s3a.paging.maximum,How many keys to request from S3 when doing  directory listings at a time.,5000
fs.s3a.threads.max,The total number of threads available in the filesystem for data uploads *or any other queued filesystem operation*.,10
fs.s3a.threads.keepalivetime,Number of seconds a thread can be idle before being terminated.,60
fs.s3a.max.total.tasks,The number of operations which can be queued for execution,5
fs.s3a.multipart.size,"How big (in bytes) to split upload or copy operations up into. A suffix from the set {K,M,G,T,P} may be used to scale the numeric value.  ",100M
fs.s3a.multipart.threshold,"How big (in bytes) to split upload or copy operations up into. This also controls the partition size in renamed files, as rename() involves copying the source file(s). A suffix from the set {K,M,G,T,P} may be used to scale the numeric value.  ",2147483647
fs.s3a.multiobjectdelete.enable,"When enabled, multiple single-object delete requests are replaced by a single 'delete multiple objects'-request, reducing the number of requests. Beware: legacy S3-compatible object stores might not support this request.  ",true
fs.s3a.acl.default,"Set a canned ACL for newly created and copied objects. Value may be Private,   PublicRead, PublicReadWrite, AuthenticatedRead, LogDeliveryWrite, BucketOwnerRead,   or BucketOwnerFullControl.",
fs.s3a.multipart.purge,"True if you want to purge existing multipart uploads that may not have been completed/aborted correctly. The corresponding purge age is defined in fs.s3a.multipart.purge.age. If set, when the filesystem is instantiated then all outstanding uploads older than the purge age will be terminated -across the entire bucket. This will impact multipart uploads by other applications and users. so should be used sparingly, with an age value chosen to stop failed uploads, without breaking ongoing operations.  ",false
fs.s3a.multipart.purge.age,Minimum age in seconds of multipart uploads to purge.  ,86400
fs.s3a.server-side-encryption-algorithm,"Specify a server-side encryption algorithm for s3a: file system. Unset by default.  It supports the following values: 'AES256' (for SSE-S3), 'SSE-KMS' and 'SSE-C'.  ",
fs.s3a.server-side-encryption.key,"Specific encryption key to use if fs.s3a.server-side-encryption-algorithm has been set to 'SSE-KMS' or 'SSE-C'. In the case of SSE-C, the value of this property should be the Base64 encoded key. If you are using SSE-KMS and leave this property empty, you'll be using your default's S3 KMS key, otherwise you should set this property to the specific KMS key id.  ",
fs.s3a.signing-algorithm,Override the default signing algorithm so legacy implementations can still be used,
fs.s3a.block.size,"Block size to use when reading files using s3a: file system. A suffix from the set {K,M,G,T,P} may be used to scale the numeric value.  ",32M
fs.s3a.buffer.dir,Comma separated list of directories that will be used to buffer file uploads to.,${hadoop.tmp.dir}/s3a
fs.s3a.fast.upload, Use the incremental block-based fast upload mechanism with the buffering mechanism set in fs.s3a.fast.upload.buffer.  ,false
fs.s3a.fast.upload.buffer," The buffering mechanism to use when using S3A fast upload (fs.s3a.fast.upload=true). Values: disk, array, bytebuffer. This configuration option has no effect if fs.s3a.fast.upload is false. ""disk"" will use the directories listed in fs.s3a.buffer.dir as the location(s) to save data prior to being uploaded. ""array"" uses arrays in the JVM heap ""bytebuffer"" uses off-heap memory within the JVM. Both ""array"" and ""bytebuffer"" will consume memory in a single stream up to the number of blocks set by:  fs.s3a.multipart.size * fs.s3a.fast.upload.active.blocks. If using either of these mechanisms, keep this value low The total number of threads performing work across all threads is set by fs.s3a.threads.max, with fs.s3a.max.total.tasks values setting the number of queued work items.  ",disk
fs.s3a.fast.upload.active.blocks," Maximum Number of blocks a single output stream can have active (uploading, or queued to the central FileSystem instance's pool of queued operations. This stops a single stream overloading the shared thread pool.  ",4
fs.s3a.readahead.range,"Bytes to read ahead during a seek() before closing and  re-opening the S3 HTTP connection. This option will be overridden if  any call to setReadahead() is made to an open stream.  A suffix from the set {K,M,G,T,P} may be used to scale the numeric value.  ",64K
fs.s3a.user.agent.prefix," Sets a custom value that will be prepended to the User-Agent header sent in HTTP requests to the S3 back-end by S3AFileSystem.  The User-Agent header always includes the Hadoop version number followed by a string generated by the AWS SDK.  An example is ""User-Agent: Hadoop 2.8.0, aws-sdk-java/1.10.6"". If this optional property is set, then its value is prepended to create a customized User-Agent.  For example, if this configuration property was set to ""MyApp"", then an example of the resulting User-Agent would be ""User-Agent: MyApp, Hadoop 2.8.0, aws-sdk-java/1.10.6"".  ",
fs.s3a.metadatastore.authoritative,"  When true, allow MetadataStore implementations to act as source of  truth for getting file status and directory listings.  Even if this  is set to true, MetadataStore implementations may choose not to  return authoritative results.  If the configured MetadataStore does  not support being authoritative, this setting will have no effect. ",false
fs.s3a.metadatastore.impl,"  Fully-qualified name of the class that implements the MetadataStore  to be used by s3a.  The default class, NullMetadataStore, has no  effect: s3a will continue to treat the backing S3 service as the one  and only source of truth for file and directory metadata. ",org.apache.hadoop.fs.s3a.s3guard.NullMetadataStore
fs.s3a.s3guard.cli.prune.age,  Default age (in milliseconds) after which to prune metadata from the  metadatastore when the prune command is run.  Can be overridden on the  command-line. ,86400000
fs.s3a.impl,The implementation class of the S3A Filesystem,org.apache.hadoop.fs.s3a.S3AFileSystem
fs.s3a.s3guard.ddb.region," AWS DynamoDB region to connect to. An up-to-date list is provided in the AWS Documentation: regions and endpoints. Without this property, the S3Guard will operate table in the associated S3 bucket region.  ",
fs.s3a.s3guard.ddb.table," The DynamoDB table name to operate. Without this property, the respective S3 bucket name will be used.  ",
fs.s3a.s3guard.ddb.table.create," If true, the S3A client will create the table if it does not already exist.  ",false
fs.s3a.s3guard.ddb.table.capacity.read," Provisioned throughput requirements for read operations in terms of capacity units for the DynamoDB table.  This config value will only be used when creating a new DynamoDB table, though later you can manually provision by increasing or decreasing read capacity as needed for existing tables. See DynamoDB documents for more information.  ",500
fs.s3a.s3guard.ddb.table.capacity.write, Provisioned throughput requirements for write operations in terms of capacity units for the DynamoDB table.  Refer to related config fs.s3a.s3guard.ddb.table.capacity.read before usage.  ,100
fs.s3a.s3guard.ddb.max.retries,"   Max retries on batched DynamoDB operations before giving up and   throwing an IOException.  Each retry is delayed with an exponential   backoff timer which starts at 100 milliseconds and approximately   doubles each time.  The minimum wait before throwing an exception is   sum(100, 200, 400, 800, .. 100*2^N-1 ) == 100 * ((2^N)-1)   So N = 9 yields at least 51.1 seconds (51,100) milliseconds of blocking   before throwing an IOException. ",9
fs.s3a.s3guard.ddb.background.sleep, Length (in milliseconds) of pause between each batch of deletes when pruning metadata.  Prevents prune operations (which can typically be low priority background operations) from overly interfering with other I/O operations.  ,25
fs.AbstractFileSystem.s3a.impl,The implementation class of the S3A AbstractFileSystem.,org.apache.hadoop.fs.s3a.S3A
fs.wasb.impl,The implementation class of the Native Azure Filesystem,org.apache.hadoop.fs.azure.NativeAzureFileSystem
fs.wasbs.impl,The implementation class of the Secure Native Azure Filesystem,org.apache.hadoop.fs.azure.NativeAzureFileSystem$Secure
fs.azure.secure.mode," Config flag to identify the mode in which fs.azure.NativeAzureFileSystem needs to run under. Setting it ""true"" would make fs.azure.NativeAzureFileSystem use SAS keys to communicate with Azure storage.  ",false
fs.azure.local.sas.key.mode," Works in conjuction with fs.azure.secure.mode. Setting this config to true results in fs.azure.NativeAzureFileSystem using the local SAS key generation where the SAS keys are generating in the same process as fs.azure.NativeAzureFileSystem. If fs.azure.secure.mode flag is set to false, this flag has no effect.  ",false
fs.azure.sas.expiry.period," The default value to be used for expiration period for SAS keys generated. Can use the following suffix (case insensitive): ms(millis), s(sec), m(min), h(hour), d(day) to specify the time (such as 2s, 2m, 1h, etc.).  ",90d
fs.azure.authorization," Config flag to enable authorization support in WASB. Setting it to ""true"" enables authorization support to WASB. Currently WASB authorization requires a remote service to provide authorization that needs to be specified via fs.azure.authorization.remote.service.url configuration  ",false
fs.azure.authorization.caching.enable, Config flag to enable caching of authorization results and saskeys in WASB. This flag is relevant only when fs.azure.authorization is enabled.  ,true
fs.azure.saskey.usecontainersaskeyforallaccess, Use container saskey for access to all blobs within the container. Blob-specific saskeys are not used when this setting is enabled. This setting provides better performance compared to blob-specific saskeys.  ,true
fs.adl.impl,,org.apache.hadoop.fs.adl.AdlFileSystem
fs.AbstractFileSystem.adl.impl,,org.apache.hadoop.fs.adl.Adl
io.seqfile.compress.blocksize,The minimum block size for compression in block compressed    SequenceFiles.  ,1000000
io.mapfile.bloom.size,"The size of BloomFilter-s used in BloomMapFile. Each time this many  keys is appended the next BloomFilter will be created (inside a DynamicBloomFilter).  Larger values minimize the number of filters, which slightly increases the performance,  but may waste too much space if the total number of keys is usually much smaller  than this number.  ",1048576
io.mapfile.bloom.error.rate,"The rate of false positives in BloomFilter-s used in BloomMapFile.  As this value decreases, the size of BloomFilter-s increases exponentially. This  value is the probability of encountering false positives (default is 0.5%).  ",0.005
hadoop.util.hash.type,The default implementation of Hash. Currently this can take one of the  two values: 'murmur' to select MurmurHash and 'jenkins' to select JenkinsHash.  ,murmur
ipc.client.idlethreshold,Defines the threshold number of connections after which      connections will be inspected for idleness.  ,4000
ipc.client.kill.max,Defines the maximum number of clients to disconnect in one go.  ,10
ipc.client.connection.maxidletime,The maximum time in msec after which a client will bring down the      connection to the server.  ,10000
ipc.client.connect.max.retries,Indicates the number of retries a client will make to establish      a server connection.  ,10
ipc.client.connect.retry.interval,Indicates the number of milliseconds a client will wait for before retrying to establish a server connection.  ,1000
ipc.client.connect.timeout,Indicates the number of milliseconds a client will wait for the      socket to establish a server connection.  ,20000
ipc.client.connect.max.retries.on.timeouts,Indicates the number of retries a client will make on socket timeout      to establish a server connection.  ,45
ipc.client.tcpnodelay,Use TCP_NODELAY flag to bypass Nagle's algorithm transmission delays.  ,true
ipc.client.low-latency,Use low-latency QoS markers for IPC connections.  ,false
ipc.client.ping,"Send a ping to the server when timeout on reading the response,  if set to true. If no failure is detected, the client retries until at least  a byte is read or the time given by ipc.client.rpc-timeout.ms is passed.  ",true
ipc.ping.interval,"Timeout on waiting response from server, in milliseconds.  The client will send ping when the interval is passed without receiving bytes,  if ipc.client.ping is set to true.  ",60000
ipc.client.rpc-timeout.ms,"Timeout on waiting response from server, in milliseconds.  If ipc.client.ping is set to true and this rpc-timeout is greater than  the value of ipc.ping.interval, the effective value of the rpc-timeout is  rounded up to multiple of ipc.ping.interval.  ",0
ipc.server.listen.queue.size,Indicates the length of the listen queue for servers accepting      client connections.  ,128
ipc.server.log.slow.rpc,This setting is useful to troubleshoot performance issues for  various services. If this value is set to true then we log requests that  fall into 99th percentile as well as increment RpcSlowCalls counter. ,false
ipc.maximum.data.length,This indicates the maximum IPC message length (bytes) that can be accepted by the server. Messages larger than this value are rejected by the immediately to avoid possible OOMs. This setting should rarely need to be changed.  ,67108864
ipc.maximum.response.length,This indicates the maximum IPC message length (bytes) that can be accepted by the client. Messages larger than this value are rejected immediately to avoid possible OOMs. This setting should rarely need to be changed.  Set to 0 to disable.  ,134217728
hadoop.security.impersonation.provider.class,"A class which implements ImpersonationProvider interface, used to    authorize whether one user can impersonate a specific user.    If not specified, the DefaultImpersonationProvider will be used.    If a class is specified, then that class will be used to determine    the impersonation capability.  ",
hadoop.rpc.socket.factory.class.default," Default SocketFactory to use. This parameter is expected to be formatted as ""package.FactoryClassName"".  ",org.apache.hadoop.net.StandardSocketFactory
hadoop.rpc.socket.factory.class.ClientProtocol," SocketFactory to use to connect to a DFS. If null or empty, use hadoop.rpc.socket.class.default. This socket factory is also used by DFSClient to create sockets to DataNodes.  ",
hadoop.socks.server, Address (host:port) of the SOCKS server to be used by the SocksSocketFactory.  ,
net.topology.node.switch.mapping.impl," The default implementation of the DNSToSwitchMapping. It invokes a script specified in net.topology.script.file.name to resolve node names. If the value for net.topology.script.file.name is not set, the default value of DEFAULT_RACK is returned for all node names.  ",org.apache.hadoop.net.ScriptBasedMapping
net.topology.impl, The default implementation of NetworkTopology which is classic three layer one.  ,org.apache.hadoop.net.NetworkTopology
net.topology.script.file.name," The script name that should be invoked to resolve DNS names to NetworkTopology names. Example: the script would take host.foo.bar as an argument, and return /rack1 as the output.  ",
net.topology.script.number.args, The max number of args that the script configured with net.topology.script.file.name should be run with. Each arg is an IP address.  ,100
net.topology.table.file.name," The file name for a topology file, which is used when the net.topology.node.switch.mapping.impl property is set to org.apache.hadoop.net.TableMapping. The file format is a two column text file, with columns separated by whitespace. The first column is a DNS or IP address and the second column specifies the rack where the address maps. If no entry corresponding to a host in the cluster is found, then /default-rack is assumed.  ",
file.stream-buffer-size,"The size of buffer to stream files.  The size of this buffer should probably be a multiple of hardware  page size (4096 on Intel x86), and it determines how much data is  buffered during read and write operations.",4096
file.bytes-per-checksum,The number of bytes per checksum.  Must not be larger than  file.stream-buffer-size,512
file.client-write-packet-size,Packet size for clients to write,65536
file.blocksize,Block size,67108864
file.replication,Replication factor,1
s3.stream-buffer-size,"The size of buffer to stream files.  The size of this buffer should probably be a multiple of hardware  page size (4096 on Intel x86), and it determines how much data is  buffered during read and write operations.",4096
s3.bytes-per-checksum,The number of bytes per checksum.  Must not be larger than  s3.stream-buffer-size,512
s3.client-write-packet-size,Packet size for clients to write,65536
s3.blocksize,Block size,67108864
s3.replication,Replication factor,3
s3native.stream-buffer-size,"The size of buffer to stream files.  The size of this buffer should probably be a multiple of hardware  page size (4096 on Intel x86), and it determines how much data is  buffered during read and write operations.",4096
s3native.bytes-per-checksum,The number of bytes per checksum.  Must not be larger than  s3native.stream-buffer-size,512
s3native.client-write-packet-size,Packet size for clients to write,65536
s3native.blocksize,Block size,67108864
s3native.replication,Replication factor,3
ftp.stream-buffer-size,"The size of buffer to stream files.  The size of this buffer should probably be a multiple of hardware  page size (4096 on Intel x86), and it determines how much data is  buffered during read and write operations.",4096
ftp.bytes-per-checksum,The number of bytes per checksum.  Must not be larger than  ftp.stream-buffer-size,512
ftp.client-write-packet-size,Packet size for clients to write,65536
ftp.blocksize,Block size,67108864
ftp.replication,Replication factor,3
tfile.io.chunk.size, Value chunk size in bytes. Default  to 1MB. Values of the length less than the chunk size is guaranteed to have known value length in read time (See also TFile.Reader.Scanner.Entry.isValueLengthKnown()).  ,1048576
tfile.fs.output.buffer.size, Buffer size used for FSDataOutputStream in bytes.  ,262144
tfile.fs.input.buffer.size, Buffer size used for FSDataInputStream in bytes.  ,262144
hadoop.http.authentication.type, Defines authentication used for Oozie HTTP endpoint. Supported values are: simple | kerberos | #AUTHENTICATION_HANDLER_CLASSNAME#  ,simple
hadoop.http.authentication.token.validity, Indicates how long (in seconds) an authentication token is valid before it has to be renewed.  ,36000
hadoop.http.authentication.signature.secret.file, The signature secret for signing the authentication tokens. The same secret should be used for JT/NN/DN/TT configurations.  ,${user.home}/hadoop-http-auth-signature-secret
hadoop.http.authentication.cookie.domain," The domain to use for the HTTP cookie that stores the authentication token. In order to authentiation to work correctly across all Hadoop nodes web-consoles the domain must be correctly set. IMPORTANT: when using IP addresses, browsers ignore cookies with domain settings. For this setting to work properly all nodes in the cluster must be configured to generate URLs with hostname.domain names on it.  ",
hadoop.http.authentication.simple.anonymous.allowed, Indicates if anonymous requests are allowed when using 'simple' authentication.  ,true
hadoop.http.authentication.kerberos.principal, Indicates the Kerberos principal to be used for HTTP endpoint. The principal MUST start with 'HTTP/' as per Kerberos HTTP SPNEGO specification.  ,HTTP/_HOST@LOCALHOST
hadoop.http.authentication.kerberos.keytab, Location of the keytab file with the credentials for the principal. Referring to the same keytab file Oozie uses for its Kerberos credentials for Hadoop.  ,${user.home}/hadoop.keytab
hadoop.http.cross-origin.enabled,Enable/disable the cross-origin (CORS) filter.,false
hadoop.http.cross-origin.allowed-origins,Comma separated list of origins that are allowed for web services needing cross-origin (CORS) support. Wildcards (*) and patterns allowed,*
hadoop.http.cross-origin.allowed-methods,Comma separated list of methods that are allowed for web services needing cross-origin (CORS) support.,"GET,POST,HEAD"
hadoop.http.cross-origin.allowed-headers,Comma separated list of headers that are allowed for web services needing cross-origin (CORS) support.,"X-Requested-With,Content-Type,Accept,Origin"
hadoop.http.cross-origin.max-age,The number of seconds a pre-flighted request can be cached for web services needing cross-origin (CORS) support.,1800
dfs.ha.fencing.methods, List of fencing methods to use for service fencing. May contain builtin methods (eg shell and sshfence) or user-defined method.  ,
dfs.ha.fencing.ssh.connect-timeout," SSH connection timeout, in milliseconds, to use with the builtin sshfence fencer.  ",30000
dfs.ha.fencing.ssh.private-key-files, The SSH private key files to use with the builtin sshfence fencer.  ,
hadoop.http.staticuser.user," The user name to filter as, on static web filters while rendering content. An example use is the HDFS web UI (user to be used for browsing files).  ",dr.who
ha.zookeeper.quorum," A list of ZooKeeper server addresses, separated by commas, that are to be used by the ZKFailoverController in automatic failover.  ",
ha.zookeeper.session-timeout.ms," The session timeout to use when the ZKFC connects to ZooKeeper. Setting this value to a lower value implies that server crashes will be detected more quickly, but risks triggering failover too aggressively in the case of a transient error or network blip.  ",10000
ha.zookeeper.parent-znode," The ZooKeeper znode under which the ZK failover controller stores its information. Note that the nameservice ID is automatically appended to this znode, so it is not normally necessary to configure this, even in a federated environment.  ",/hadoop-ha
ha.zookeeper.acl," A comma-separated list of ZooKeeper ACLs to apply to the znodes used by automatic failover. These ACLs are specified in the same format as used by the ZooKeeper CLI. If the ACL itself contains secrets, you may instead specify a path to a file, prefixed with the '@' symbol, and the value of this configuration will be loaded from within.  ",world:anyone:rwcda
ha.zookeeper.auth," A comma-separated list of ZooKeeper authentications to add when connecting to ZooKeeper. These are specified in the same format as used by the ""addauth"" command in the ZK CLI. It is important that the authentications specified here are sufficient to access znodes with the ACL specified in ha.zookeeper.acl. If the auths contain secrets, you may instead specify a path to a file, prefixed with the '@' symbol, and the value of this configuration will be loaded from within.  ",
hadoop.ssl.keystores.factory.class, The keystores factory to use for retrieving certificates.  ,org.apache.hadoop.security.ssl.FileBasedKeyStoresFactory
hadoop.ssl.require.client.cert,Whether client certificates are required,false
hadoop.ssl.hostname.verifier," The hostname verifier to provide for HttpsURLConnections. Valid values are: DEFAULT, STRICT, STRICT_IE6, DEFAULT_AND_LOCALHOST and ALLOW_ALL  ",DEFAULT
hadoop.ssl.server.conf," Resource file from which ssl server keystore information will be extracted. This file is looked up in the classpath, typically it should be in Hadoop conf/ directory.  ",ssl-server.xml
hadoop.ssl.client.conf," Resource file from which ssl client keystore information will be extracted This file is looked up in the classpath, typically it should be in Hadoop conf/ directory.  ",ssl-client.xml
hadoop.ssl.enabled, Deprecated. Use dfs.http.policy and yarn.http.policy instead.  ,false
hadoop.ssl.enabled.protocols, The supported SSL protocols.  ,"TLSv1,SSLv2Hello,TLSv1.1,TLSv1.2"
hadoop.jetty.logs.serve.aliases, Enable/Disable aliases serving from jetty  ,true
fs.permissions.umask-mode," The umask used when creating files and directories. Can be in octal or in symbolic. Examples are: ""022"" (octal for u=rwx,g=r-x,o=r-x in symbolic), or ""u=rwx,g=rwx,o="" (symbolic for 007 in octal).  ",022
ha.health-monitor.connect-retry-interval.ms, How often to retry connecting to the service.  ,1000
ha.health-monitor.check-interval.ms, How often to check the service.  ,1000
ha.health-monitor.sleep-after-disconnect.ms, How long to sleep after an unexpected RPC error.  ,1000
ha.health-monitor.rpc-timeout.ms, Timeout for the actual monitorHealth() calls.  ,45000
ha.failover-controller.new-active.rpc-timeout.ms, Timeout that the FC waits for the new active to become active  ,60000
ha.failover-controller.graceful-fence.rpc-timeout.ms, Timeout that the FC waits for the old active to go to standby  ,5000
ha.failover-controller.graceful-fence.connection.retries, FC connection retries for graceful fencing  ,1
ha.failover-controller.cli-check.rpc-timeout.ms," Timeout that the CLI (manual) FC waits for monitorHealth, getServiceState  ",20000
ipc.client.fallback-to-simple-auth-allowed," When a client is configured to attempt a secure connection, but attempts to connect to an insecure server, that server may instruct the client to switch to SASL SIMPLE (unsecure) authentication. This setting controls whether or not the client will accept this instruction from the server. When false (the default), the client will not allow the fallback to SIMPLE authentication, and will abort the connection.  ",false
fs.client.resolve.remote.symlinks,"   Whether to resolve symlinks when accessing a remote Hadoop filesystem.   Setting this to false causes an exception to be thrown upon encountering   a symlink. This setting does not apply to local filesystems, which   automatically resolve local symlinks.  ",true
nfs.exports.allowed.hosts," By default, the export can be mounted by any client. The value string contains machine name and access privilege, separated by whitespace characters. The machine name format can be a single host, a Java regular expression, or an IPv4 address. The access privilege uses rw or ro to specify read/write or read-only access of the machines to exports. If the access privilege is not provided, the default is read-only. Entries are separated by "";"". For example: ""192.168.0.0/22 rw ; host.*\.example\.com ; host1.test.org ro;"". Only the NFS gateway needs to restart after this property is updated.  ",* rw
hadoop.user.group.static.mapping.overrides," Static mapping of user to groups. This will override the groups if available in the system for the specified user. In other words, groups look-up will not happen for these users, instead groups mapped in this configuration will be used. Mapping should be in this format. user1=group1,group2;user2=;user3=group2; Default, ""dr.who=;"" will consider ""dr.who"" as user without groups.  ",dr.who=;
rpc.metrics.quantile.enable," Setting this property to true and rpc.metrics.percentiles.intervals to a comma-separated list of the granularity in seconds, the 50/75/90/95/99th percentile latency for rpc queue/processing time in milliseconds are added to rpc metrics.  ",false
rpc.metrics.percentiles.intervals, A comma-separated list of the granularity in seconds for the metrics which describe the 50/75/90/95/99th percentile latency for rpc queue/processing time. The metrics are outputted if rpc.metrics.quantile.enable is set to true.  ,
hadoop.security.crypto.codec.classes.EXAMPLECIPHERSUITE," The prefix for a given crypto codec, contains a comma-separated list of implementation classes for a given crypto codec (eg EXAMPLECIPHERSUITE). The first implementation will be used if available, others are fallbacks.  ",
hadoop.security.crypto.codec.classes.aes.ctr.nopadding," Comma-separated list of crypto codec implementations for AES/CTR/NoPadding. The first implementation will be used if available, others are fallbacks.  ","org.apache.hadoop.crypto.OpensslAesCtrCryptoCodec, org.apache.hadoop.crypto.JceAesCtrCryptoCodec"
hadoop.security.crypto.cipher.suite, Cipher suite for crypto codec.  ,AES/CTR/NoPadding
hadoop.security.crypto.jce.provider, The JCE provider name used in CryptoCodec.  ,
hadoop.security.crypto.jceks.key.serialfilter," Enhanced KeyStore Mechanisms in JDK 8u171 introduced jceks.key.serialFilter. If jceks.key.serialFilter is configured, the JCEKS KeyStore uses it during the deserialization of the encrypted Key object stored inside a SecretKeyEntry. If jceks.key.serialFilter is not configured it will cause an error when recovering keystore file in KeyProviderFactory when recovering key from keystore file using JDK 8u171 or newer. The filter pattern uses the same format as jdk.serialFilter. The value of this property will be used as the following: 1. The value of jceks.key.serialFilter system property takes precedence over the value of this property. 2. In the absence of jceks.key.serialFilter system property the value of this property will be set as the value of jceks.key.serialFilter. 3. If the value of this property and jceks.key.serialFilter system property has not been set, org.apache.hadoop.crypto.key.KeyProvider sets a default value for jceks.key.serialFilter.  ",
hadoop.security.crypto.buffer.size, The buffer size used by CryptoInputStream and CryptoOutputStream.  ,8192
hadoop.security.java.secure.random.algorithm, The java secure random algorithm.  ,SHA1PRNG
hadoop.security.secure.random.impl, Implementation of secure random.  ,
hadoop.security.random.device.file.path, OS security random device file path.  ,/dev/urandom
hadoop.security.key.provider.path," The KeyProvider to use when managing zone keys, and interacting with encryption keys when reading and writing to an encryption zone. For hdfs clients, the provider path will be same as namenode's provider path.  ",
fs.har.impl.disable.cache,Don't cache 'har' filesystem instances.,true
hadoop.security.kms.client.authentication.retry-count, Number of time to retry connecting to KMS on authentication failure  ,1
hadoop.security.kms.client.encrypted.key.cache.size, Size of the EncryptedKeyVersion cache Queue for each key  ,500
hadoop.security.kms.client.encrypted.key.cache.low-watermark," If size of the EncryptedKeyVersion cache Queue falls below the low watermark, this cache queue will be scheduled for a refill  ",0.3f
hadoop.security.kms.client.encrypted.key.cache.num.refill.threads, Number of threads to use for refilling depleted EncryptedKeyVersion cache Queues  ,2
hadoop.security.kms.client.encrypted.key.cache.expiry," Cache expiry time for a Key, after which the cache Queue for this key will be dropped. Default = 12hrs  ",43200000
hadoop.security.kms.client.timeout," Sets value for KMS client connection timeout, and the read timeout to KMS servers.  ",60
hadoop.security.kms.client.failover.sleep.base.millis," Expert only. The time to wait, in milliseconds, between failover attempts increases exponentially as a function of the number of attempts made so far, with a random factor of +/- 50%. This option specifies the base value used in the failover calculation. The first failover will retry immediately. The 2nd failover attempt will delay at least hadoop.security.client.failover.sleep.base.millis milliseconds. And so on.  ",100
hadoop.security.kms.client.failover.sleep.max.millis," Expert only. The time to wait, in milliseconds, between failover attempts increases exponentially as a function of the number of attempts made so far, with a random factor of +/- 50%. This option specifies the maximum value to wait between failovers. Specifically, the time between two failover attempts will not exceed +/- 50% of hadoop.security.client.failover.sleep.max.millis milliseconds.  ",2000
ipc.server.max.connections,"The maximum number of concurrent connections a server is allowed to accept. If this limit is exceeded, incoming connections will first fill the listen queue and then may go to an OS-specific listen overflow queue. The client may fail or timeout, but the server can avoid running out of file descriptors using this feature. 0 means no limit.  ",0
hadoop.registry.rm.enabled,"   Is the registry enabled in the YARN Resource Manager?   If true, the YARN RM will, as needed.   create the user and system paths, and purge   service records when containers, application attempts   and applications complete.   If false, the paths must be created by other means,   and no automatic cleanup of service records will take place. ",false
hadoop.registry.zk.root,   The root zookeeper node for the registry ,/registry
hadoop.registry.zk.session.timeout.ms,   Zookeeper session timeout in milliseconds ,60000
hadoop.registry.zk.connection.timeout.ms,   Zookeeper connection timeout in milliseconds ,15000
hadoop.registry.zk.retry.times,   Zookeeper connection retry count before failing ,5
hadoop.registry.zk.retry.interval.ms, ,1000
hadoop.registry.zk.retry.ceiling.ms,"   Zookeeper retry limit in milliseconds, during   exponential backoff.   This places a limit even   if the retry times and interval limit, combined   with the backoff policy, result in a long retry   period ",60000
hadoop.registry.zk.quorum,   List of hostname:port pairs defining the   zookeeper quorum binding for the registry ,localhost:2181
hadoop.registry.secure,"   Key to set if the registry is secure. Turning it on   changes the permissions policy from ""open access""   to restrictions on kerberos with the option of   a user adding one or more auth key pairs down their   own tree. ",false
hadoop.registry.system.acls,"   A comma separated list of Zookeeper ACL identifiers with   system access to the registry in a secure cluster.   These are given full access to all entries.   If there is an ""@"" at the end of a SASL entry it   instructs the registry client to append the default kerberos domain. ","sasl:yarn@, sasl:mapred@, sasl:hdfs@"
hadoop.registry.kerberos.realm,"   The kerberos realm: used to set the realm of   system principals which do not declare their realm,   and any other accounts that need the value.   If empty, the default realm of the running process   is used.   If neither are known and the realm is needed, then the registry   service/client will fail. ",
hadoop.registry.jaas.context,   Key to define the JAAS context. Used in secure   mode ,Client
hadoop.shell.missing.defaultFs.warning,   Enable hdfs shell commands to display warnings if (fs.defaultFS) property   is not set. ,false
hadoop.shell.safely.delete.limit.num.files,"Used by -safely option of hadoop fs shell -rm command to avoid   accidental deletion of large directories. When enabled, the -rm command   requires confirmation if the number of files to be deleted is greater than   this limit.  The default limit is 100 files. The warning is disabled if   the limit is 0 or the -safely is not specified in -rm command. ",100
fs.client.htrace.sampler.classes,The class names of the HTrace Samplers to use for Hadoop   filesystem clients. ,
hadoop.htrace.span.receiver.classes,The class names of the Span Receivers to use for Hadoop. ,
hadoop.http.logs.enabled,"   Enable the ""/logs"" endpoint on all Hadoop daemons, which serves local   logs, but may be considered a security risk due to it listing the contents   of a directory. ",true
fs.client.resolve.topology.enabled,"Whether the client machine will use the class specified by   property net.topology.node.switch.mapping.impl to compute the network   distance between itself and remote machines of the FileSystem. Additional   properties might need to be configured depending on the class specified   in net.topology.node.switch.mapping.impl. For example, if   org.apache.hadoop.net.ScriptBasedMapping is used, a valid script file   needs to be specified in net.topology.script.file.name. ",false
fs.adl.impl,,org.apache.hadoop.fs.adl.AdlFileSystem
fs.AbstractFileSystem.adl.impl,,org.apache.hadoop.fs.adl.Adl
adl.feature.ownerandgroup.enableupn,"   When true : User and Group in FileStatus/AclStatus response is   represented as user friendly name as per Azure AD profile.   When false (default) : User and Group in FileStatus/AclStatus   response is represented by the unique identifier from Azure AD   profile (Object ID as GUID).   For optimal performance, false is recommended. ",false
fs.adl.oauth2.access.token.provider.type,"   Defines Azure Active Directory OAuth2 access token provider type.   Supported types are ClientCredential, RefreshToken, MSI, DeviceCode,   and Custom.   The ClientCredential type requires property fs.adl.oauth2.client.id,   fs.adl.oauth2.credential, and fs.adl.oauth2.refresh.url.   The RefreshToken type requires property fs.adl.oauth2.client.id and   fs.adl.oauth2.refresh.token.   The MSI type reads optional property fs.adl.oauth2.msi.port, if specified.   The DeviceCode type requires property   fs.adl.oauth2.devicecode.clientapp.id.   The Custom type requires property fs.adl.oauth2.access.token.provider. ",ClientCredential
fs.adl.oauth2.client.id,The OAuth2 client id.,
fs.adl.oauth2.credential,The OAuth2 access key.,
fs.adl.oauth2.refresh.url,The OAuth2 token endpoint.,
fs.adl.oauth2.refresh.token,The OAuth2 refresh token.,
fs.adl.oauth2.access.token.provider,   The class name of the OAuth2 access token provider. ,
fs.adl.oauth2.msi.port,"   The localhost port for the MSI token service. This is the port specified   when creating the Azure VM. The default, if this setting is not specified,   is 50342.   Used by MSI token provider. ",
fs.adl.oauth2.devicecode.clientapp.id,   The app id of the AAD native app in whose context the auth request   should be made.   Used by DeviceCode token provider. ,
hadoop.caller.context.enabled,"When the feature is enabled, additional fields are written into   name-node audit log records for auditing coarse granularity operations. ",false
hadoop.caller.context.max.size,"The maximum bytes a caller context string can have. If the   passed caller context is longer than this maximum bytes, client will   truncate it before sending to server. Note that the server may have a   different maximum size, and will truncate the caller context to the   maximum size it allows. ",128
hadoop.caller.context.signature.max.size,"   The caller's signature (optional) is for offline validation. If the   signature exceeds the maximum allowed bytes in server, the caller context   will be abandoned, in which case the caller context will not be recorded   in audit logs. ",40
seq.io.sort.mb,"   The total amount of buffer memory to use while sorting files,   while using SequenceFile.Sorter, in megabytes. By default,   gives each merge stream 1MB, which should minimize seeks. ",100
seq.io.sort.factor,   The number of streams to merge at once while sorting   files using SequenceFile.Sorter.   This determines the number of open file handles. ,100
hadoop.zk.address,Host:Port of the ZooKeeper server to be used. ,
hadoop.zk.num-retries,Number of tries to connect to ZooKeeper.,1000
hadoop.zk.retry-interval-ms,Retry interval in milliseconds when connecting to ZooKeeper. ,1000
hadoop.zk.timeout-ms,"ZooKeeper session timeout in milliseconds. Session expiration is managed by the ZooKeeper cluster itself, not by the client. This value is used by the cluster to determine when the client's session expires. Expirations happens when the cluster does not hear from the client within the specified session timeout period (i.e. no heartbeat).",10000
hadoop.zk.acl,ACL's to be used for ZooKeeper znodes.,world:anyone:rwcda
hadoop.zk.auth,"  Specify the auths to be used for the ACL's specified in hadoop.zk.acl.  This takes a comma-separated list of authentication mechanisms, each of the  form 'scheme:auth' (the same syntax used for the 'addAuth' command in  the ZK CLI). ",
hbase.tmp.dir,"Temporary directory on the local filesystem. Change this setting to point to a location more permanent than '/tmp', the usual resolve for java.io.tmpdir, as the '/tmp' directory is cleared on machine restart.",${java.io.tmpdir}/hbase-${user.name}
hbase.rootdir,"The directory shared by region servers and into which HBase persists.  The URL should be 'fully-qualified' to include the filesystem scheme.  For example, to specify the HDFS directory '/hbase' where the HDFS instance's namenode is running at namenode.example.org on port 9000, set this value to: hdfs://namenode.example.org:9000/hbase.  By default, we write to whatever ${hbase.tmp.dir} is set too -- usually /tmp -- so change this configuration or else all data will be lost on machine restart.",${hbase.tmp.dir}/hbase
hbase.cluster.distributed,"The mode the cluster will be in. Possible values are   false for standalone mode and true for distributed mode.  If   false, startup will run all HBase and ZooKeeper daemons together   in the one JVM.",false
hbase.zookeeper.quorum,"Comma separated list of servers in the ZooKeeper ensemble (This config. should have been named hbase.zookeeper.ensemble). For example, ""host1.mydomain.com,host2.mydomain.com,host3.mydomain.com"". By default this is set to localhost for local and pseudo-distributed modes of operation. For a fully-distributed setup, this should be set to a full list of ZooKeeper ensemble servers. If HBASE_MANAGES_ZK is set in hbase-env.sh this is the list of servers which hbase will start/stop ZooKeeper on as part of cluster start/stop.  Client-side, we will take this list of ensemble members and put it together with the hbase.zookeeper.property.clientPort config. and pass it into zookeeper constructor as the connectString parameter.",localhost
zookeeper.recovery.retry.maxsleeptime,"Max sleep time before retry zookeeper operations in milliseconds, a max time is needed here so that sleep time won't grow unboundedly ",60000
hbase.local.dir,Directory on the local filesystem to be used as a local storage.,${hbase.tmp.dir}/local/
hbase.master.port,The port the HBase Master should bind to.,16000
hbase.master.info.port,The port for the HBase Master web UI. Set to -1 if you do not want a UI instance run.,16010
hbase.master.info.bindAddress,The bind address for the HBase Master web UI ,0.0.0.0
hbase.master.logcleaner.plugins,"A comma-separated list of BaseLogCleanerDelegate invoked by the LogsCleaner service. These WAL cleaners are called in order, so put the cleaner that prunes the most files in front. To implement your own BaseLogCleanerDelegate, just put it in HBase's classpath and add the fully qualified class name here. Always add the above default log cleaners in the list.","org.apache.hadoop.hbase.master.cleaner.TimeToLiveLogCleaner,org.apache.hadoop.hbase.master.cleaner.TimeToLiveProcedureWALCleaner"
hbase.master.logcleaner.ttl,"How long a WAL remain in the archive ({hbase.rootdir}/oldWALs) directory, after which it will be cleaned by a Master thread. The value is in milliseconds.",600000
hbase.master.procedurewalcleaner.ttl,"How long a Procedure WAL will remain in the archive directory, after which it will be cleaned by a Master thread. The value is in milliseconds.",604800000
hbase.master.hfilecleaner.plugins,"A comma-separated list of BaseHFileCleanerDelegate invoked by the HFileCleaner service. These HFiles cleaners are called in order, so put the cleaner that prunes the most files in front. To implement your own BaseHFileCleanerDelegate, just put it in HBase's classpath and add the fully qualified class name here. Always add the above default log cleaners in the list as they will be overwritten in hbase-site.xml.",org.apache.hadoop.hbase.master.cleaner.TimeToLiveHFileCleaner
hbase.master.infoserver.redirect,Whether or not the Master listens to the Master web   UI port (hbase.master.info.port) and redirects requests to the web   UI server shared by the Master and RegionServer. Config. makes   sense when Master is serving Regions (not the default).,true
hbase.master.fileSplitTimeout,"Splitting a region, how long to wait on the file-splitting   step before aborting the attempt. Default: 600000. This setting used   to be known as hbase.regionserver.fileSplitTimeout in hbase-1.x.   Split is now run master-side hence the rename (If a   'hbase.master.fileSplitTimeout' setting found, will use it to   prime the current 'hbase.master.fileSplitTimeout'   Configuration.",600000
hbase.regionserver.port,The port the HBase RegionServer binds to.,16020
hbase.regionserver.info.port,The port for the HBase RegionServer web UI Set to -1 if you do not want the RegionServer UI to run.,16030
hbase.regionserver.info.bindAddress,The address for the HBase RegionServer web UI,0.0.0.0
hbase.regionserver.info.port.auto,"Whether or not the Master or RegionServer UI should search for a port to bind to. Enables automatic port search if hbase.regionserver.info.port is already in use. Useful for testing, turned off by default.",false
hbase.regionserver.handler.count,"Count of RPC Listener instances spun up on RegionServers.   Same property is used by the Master for count of master handlers.   Too many handlers can be counter-productive. Make it a multiple of   CPU count. If mostly read-only, handlers count close to cpu count   does well. Start with twice the CPU count and tune from there.",30
hbase.ipc.server.callqueue.handler.factor,Factor to determine the number of call queues.   A value of 0 means a single queue shared between all the handlers.   A value of 1 means that each handler has its own queue.,0.1
hbase.ipc.server.callqueue.read.ratio,"Split the call queues into read and write queues.   The specified interval (which should be between 0.0 and 1.0)   will be multiplied by the number of call queues.   A value of 0 indicate to not split the call queues, meaning that both read and write   requests will be pushed to the same set of queues.   A value lower than 0.5 means that there will be less read queues than write queues.   A value of 0.5 means there will be the same number of read and write queues.   A value greater than 0.5 means that there will be more read queues than write queues.   A value of 1.0 means that all the queues except one are used to dispatch read requests.   Example: Given the total number of call queues being 10   a read.ratio of 0 means that: the 10 queues will contain both read/write requests.   a read.ratio of 0.3 means that: 3 queues will contain only read requests   and 7 queues will contain only write requests.   a read.ratio of 0.5 means that: 5 queues will contain only read requests   and 5 queues will contain only write requests.   a read.ratio of 0.8 means that: 8 queues will contain only read requests   and 2 queues will contain only write requests.   a read.ratio of 1 means that: 9 queues will contain only read requests   and 1 queues will contain only write requests. ",0
hbase.ipc.server.callqueue.scan.ratio,"Given the number of read call queues, calculated from the total number   of call queues multiplied by the callqueue.read.ratio, the scan.ratio property   will split the read call queues into small-read and long-read queues.   A value lower than 0.5 means that there will be less long-read queues than short-read queues.   A value of 0.5 means that there will be the same number of short-read and long-read queues.   A value greater than 0.5 means that there will be more long-read queues than short-read queues   A value of 0 or 1 indicate to use the same set of queues for gets and scans.   Example: Given the total number of read call queues being 8   a scan.ratio of 0 or 1 means that: 8 queues will contain both long and short read requests.   a scan.ratio of 0.3 means that: 2 queues will contain only long-read requests   and 6 queues will contain only short-read requests.   a scan.ratio of 0.5 means that: 4 queues will contain only long-read requests   and 4 queues will contain only short-read requests.   a scan.ratio of 0.8 means that: 6 queues will contain only long-read requests   and 2 queues will contain only short-read requests. ",0
hbase.regionserver.msginterval,Interval between messages from the RegionServer to Master in milliseconds.,3000
hbase.regionserver.logroll.period,Period at which we will roll the commit log regardless of how many edits it has.,3600000
hbase.regionserver.logroll.errors.tolerated,The number of consecutive WAL close errors we will allow before triggering a server abort.  A setting of 0 will cause the region server to abort if closing the current WAL writer fails during log rolling.  Even a small value (2 or 3) will allow a region server to ride over transient HDFS errors.,2
hbase.regionserver.hlog.reader.impl,The WAL file reader implementation.,org.apache.hadoop.hbase.regionserver.wal.ProtobufLogReader
hbase.regionserver.hlog.writer.impl,The WAL file writer implementation.,org.apache.hadoop.hbase.regionserver.wal.ProtobufLogWriter
hbase.regionserver.global.memstore.size,Maximum size of all memstores in a region server before new   updates are blocked and flushes are forced. Defaults to 40% of heap (0.4).   Updates are blocked and flushes are forced until size of all memstores   in a region server hits hbase.regionserver.global.memstore.size.lower.limit.   The default value in this configuration has been intentionally left empty in order to   honor the old hbase.regionserver.global.memstore.upperLimit property if present. ,
hbase.regionserver.global.memstore.size.lower.limit,Maximum size of all memstores in a region server before flushes   are forced. Defaults to 95% of hbase.regionserver.global.memstore.size   (0.95). A 100% value for this value causes the minimum possible flushing   to occur when updates are blocked due to memstore limiting. The default   value in this configuration has been intentionally left empty in order to   honor the old hbase.regionserver.global.memstore.lowerLimit property if   present. ,
hbase.systemtables.compacting.memstore.type,"Determines the type of memstore to be used for system tables like   META, namespace tables etc. By default NONE is the type and hence we use the   default memstore for all the system tables. If we need to use compacting   memstore for system tables then set this property to BASIC/EAGER ",NONE
hbase.regionserver.optionalcacheflushinterval, Maximum amount of time an edit lives in memory before being automatically flushed. Default 1 hour. Set it to 0 to disable automatic flushing.  ,3600000
hbase.regionserver.dns.interface,The name of the Network Interface from which a region server   should report its IP address.,default
hbase.regionserver.dns.nameserver,The host name or IP address of the name server (DNS)   which a region server should use to determine the host name used by the   master for communication and display purposes.,default
hbase.regionserver.region.split.policy,"   A split policy determines when a region should be split. The various   other split policies that are available currently are BusyRegionSplitPolicy,   ConstantSizeRegionSplitPolicy, DisabledRegionSplitPolicy,   DelimitedKeyPrefixRegionSplitPolicy, KeyPrefixRegionSplitPolicy, and   SteppingSplitPolicy. DisabledRegionSplitPolicy blocks manual region splitting. ",org.apache.hadoop.hbase.regionserver.SteppingSplitPolicy
hbase.regionserver.regionSplitLimit,   Limit for the number of regions after which no more region splitting   should take place. This is not hard limit for the number of regions   but acts as a guideline for the regionserver to stop splitting after   a certain limit. Default is set to 1000. ,1000
zookeeper.session.timeout,"ZooKeeper session timeout in milliseconds. It is used in two different ways.   First, this value is used in the ZK client that HBase uses to connect to the ensemble.   It is also used by HBase when it starts a ZK server and it is passed as the 'maxSessionTimeout'.   See http://hadoop.apache.org/zookeeper/docs/current/zookeeperProgrammers.html#ch_zkSessions.   For example, if an HBase region server connects to a ZK ensemble that's also managed   by HBase, then the session timeout will be the one specified by this configuration.   But, a region server that connects to an ensemble managed with a different configuration   will be subjected that ensemble's maxSessionTimeout. So, even though HBase might propose   using 90 seconds, the ensemble can have a max timeout lower than this and it will take   precedence. The current default that ZK ships with is 40 seconds, which is lower than   HBase's. ",90000
zookeeper.znode.parent,"Root ZNode for HBase in ZooKeeper. All of HBase's ZooKeeper   files that are configured with a relative path will go under this node.   By default, all of HBase's ZooKeeper file paths are configured with a   relative path, so they will all go under this directory unless changed. ",/hbase
zookeeper.znode.acl.parent,Root ZNode for access control lists.,acl
hbase.zookeeper.dns.interface,The name of the Network Interface from which a ZooKeeper server   should report its IP address.,default
hbase.zookeeper.dns.nameserver,The host name or IP address of the name server (DNS)   which a ZooKeeper server should use to determine the host name used by the   master for communication and display purposes.,default
hbase.zookeeper.peerport,Port used by ZooKeeper peers to talk to each other. See http://hadoop.apache.org/zookeeper/docs/r3.1.1/zookeeperStarted.html#sc_RunningReplicatedZooKeeper for more information.,2888
hbase.zookeeper.leaderport,Port used by ZooKeeper for leader election. See http://hadoop.apache.org/zookeeper/docs/r3.1.1/zookeeperStarted.html#sc_RunningReplicatedZooKeeper for more information.,3888
hbase.zookeeper.property.initLimit,Property from ZooKeeper's config zoo.cfg. The number of ticks that the initial synchronization phase can take.,10
hbase.zookeeper.property.syncLimit,Property from ZooKeeper's config zoo.cfg. The number of ticks that can pass between sending a request and getting an acknowledgment.,5
hbase.zookeeper.property.dataDir,Property from ZooKeeper's config zoo.cfg. The directory where the snapshot is stored.,${hbase.tmp.dir}/zookeeper
hbase.zookeeper.property.clientPort,Property from ZooKeeper's config zoo.cfg. The port at which the clients will connect.,2181
hbase.zookeeper.property.maxClientCnxns,"Property from ZooKeeper's config zoo.cfg. Limit on number of concurrent connections (at the socket level) that a single client, identified by IP address, may make to a single member of the ZooKeeper ensemble. Set high to avoid zk connection issues running standalone and pseudo-distributed.",300
hbase.client.write.buffer,"Default size of the BufferedMutator write buffer in bytes. A bigger buffer takes more memory -- on both the client and server side since server instantiates the passed write buffer to process it -- but a larger buffer size reduces the number of RPCs made. For an estimate of server-side memory-used, evaluate hbase.client.write.buffer * hbase.regionserver.handler.count",2097152
hbase.client.pause,"General client pause value.  Used mostly as value to wait before running a retry of a failed get, region lookup, etc. See hbase.client.retries.number for description of how we backoff from this initial pause amount and how this pause works w/ retries.",100
hbase.client.pause.cqtbe,Whether or not to use a special client pause for CallQueueTooBigException (cqtbe). Set this property to a higher value than hbase.client.pause if you observe frequent CQTBE from the same RegionServer and the call queue there keeps full,
hbase.client.retries.number,"Maximum retries.  Used as maximum for all retryable operations such as the getting of a cell's value, starting a row update, etc.  Retry interval is a rough function based on hbase.client.pause.  At first we retry at this interval but then with backoff, we pretty quickly reach retrying every ten seconds.  See HConstants#RETRY_BACKOFF for how the backup ramps up.  Change this setting and hbase.client.pause to suit your workload.",15
hbase.client.max.total.tasks,The maximum number of concurrent mutation tasks a single HTable instance will send to the cluster.,100
hbase.client.max.perserver.tasks,The maximum number of concurrent mutation tasks a single HTable instance will send to a single region server.,2
hbase.client.max.perregion.tasks,"The maximum number of concurrent mutation tasks the client will maintain to a single Region. That is, if there is already hbase.client.max.perregion.tasks writes in progress for this region, new puts won't be sent to this region until some writes finishes.",1
hbase.client.perserver.requests.threshold,"The max number of concurrent pending requests for one server in all client threads (process level). Exceeding requests will be thrown ServerTooBusyException immediately to prevent user's threads being occupied and blocked by only one slow region server. If you use a fix number of threads to access HBase in a synchronous way, set this to a suitable value which is related to the number of threads will help you. See https://issues.apache.org/jira/browse/HBASE-16388 for details.",2147483647
hbase.client.scanner.caching,"Number of rows that we try to fetch when calling next on a scanner if it is not served from (local, client) memory. This configuration works together with hbase.client.scanner.max.result.size to try and use the network efficiently. The default value is Integer.MAX_VALUE by default so that the network will fill the chunk size defined by hbase.client.scanner.max.result.size rather than be limited by a particular number of rows since the size of rows varies table to table. If you know ahead of time that you will not require more than a certain number of rows from a scan, this configuration should be set to that row limit via Scan#setCaching. Higher caching values will enable faster scanners but will eat up more memory and some calls of next may take longer and longer times when the cache is empty. Do not set this value such that the time between invocations is greater than the scanner timeout; i.e. hbase.client.scanner.timeout.period",2147483647
hbase.client.keyvalue.maxsize,Specifies the combined maximum allowed size of a KeyValue instance. This is to set an upper boundary for a single entry saved in a storage file. Since they cannot be split it helps avoiding that a region cannot be split any further because the data is too large. It seems wise to set this to a fraction of the maximum region size. Setting it to zero or less disables the check.,10485760
hbase.server.keyvalue.maxsize,"Maximum allowed size of an individual cell, inclusive of value and all key components. A value of 0 or less disables the check. The default value is 10MB. This is a safety setting to protect the server from OOM situations. ",10485760
hbase.client.scanner.timeout.period,Client scanner lease period in milliseconds.,60000
hbase.client.localityCheck.threadPoolSize,,2
hbase.bulkload.retries.number,Maximum retries.  This is maximum number of iterations to atomic bulk loads are attempted in the face of splitting operations 0 means never give up.,10
hbase.master.balancer.maxRitPercent,"The max percent of regions in transition when balancing.   The default value is 1.0. So there are no balancer throttling. If set this config to 0.01,   It means that there are at most 1% regions in transition when balancing.   Then the cluster's availability is at least 99% when balancing.",1.0
"hbase.balancer.period
    ",Period at which the region balancer runs in the Master.,300000
hbase.normalizer.period,Period at which the region normalizer runs in the Master.,300000
hbase.regions.slop,"Rebalance if any regionserver has average + (average * slop) regions.   The default value of this parameter is 0.001 in StochasticLoadBalancer (the default load balancer),   while the default is 0.2 in other load balancers (i.e., SimpleLoadBalancer).",0.001
hbase.server.thread.wakefrequency,Time to sleep in between searches for work (in milliseconds). Used as sleep interval by service threads such as log roller.,10000
hbase.server.versionfile.writeattempts, How many times to retry attempting to write a version file before just aborting. Each attempt is separated by the hbase.server.thread.wakefrequency milliseconds.,3
hbase.hregion.memstore.flush.size, Memstore will be flushed to disk if size of the memstore exceeds this number of bytes.  Value is checked by a thread that runs every hbase.server.thread.wakefrequency.,134217728
hbase.hregion.percolumnfamilyflush.size.lower.bound.min," If FlushLargeStoresPolicy is used and there are multiple column families, then every time that we hit the total memstore limit, we find out all the column families whose memstores exceed a ""lower bound"" and only flush them while retaining the others in memory. The ""lower bound"" will be ""hbase.hregion.memstore.flush.size / column_family_number"" by default unless value of this property is larger than that. If none of the families have their memstore size more than lower bound, all the memstores will be flushed (just as usual). ",16777216
hbase.hregion.preclose.flush.size,"   If the memstores in a region are this size or larger when we go   to close, run a ""pre-flush"" to clear out memstores before we put up   the region closed flag and take the region offline.  On close,   a flush is run under the close flag to empty memory.  During   this time the region is offline and we are not taking on any writes.   If the memstore content is large, this flush could take a long time to   complete.  The preflush is meant to clean out the bulk of the memstore   before putting up the close flag and taking the region offline so the   flush that runs under the close flag has little to do.",5242880
hbase.hregion.memstore.block.multiplier," Block updates if memstore has hbase.hregion.memstore.block.multiplier times hbase.hregion.memstore.flush.size bytes.  Useful preventing runaway memstore during spikes in update traffic.  Without an upper-bound, memstore fills such that when it flushes the resultant flush files take a long time to compact or split, or worse, we OOME.",4
hbase.hregion.memstore.mslab.enabled,"   Enables the MemStore-Local Allocation Buffer,   a feature which works to prevent heap fragmentation under   heavy write loads. This can reduce the frequency of stop-the-world   GC pauses on large heaps.",true
hbase.hregion.max.filesize," Maximum HFile size. If the sum of the sizes of a region's HFiles has grown to exceed this value, the region is split in two.",10737418240
hbase.hregion.majorcompaction,"Time between major compactions, expressed in milliseconds. Set to 0 to disable   time-based automatic major compactions. User-requested and size-based major compactions will   still run. This value is multiplied by hbase.hregion.majorcompaction.jitter to cause   compaction to start at a somewhat-random time during a given window of time. The default value   is 7 days, expressed in milliseconds. If major compactions are causing disruption in your   environment, you can configure them to run at off-peak times for your deployment, or disable   time-based major compactions by setting this parameter to 0, and run major compactions in a   cron job or by another external mechanism.",604800000
hbase.hregion.majorcompaction.jitter,"A multiplier applied to hbase.hregion.majorcompaction to cause compaction to occur   a given amount of time either side of hbase.hregion.majorcompaction. The smaller the number,   the closer the compactions will happen to the hbase.hregion.majorcompaction   interval.",0.50
hbase.hstore.compactionThreshold," If more than this number of StoreFiles exist in any one Store   (one StoreFile is written per flush of MemStore), a compaction is run to rewrite all   StoreFiles into a single StoreFile. Larger values delay compaction, but when compaction does   occur, it takes longer to complete.",3
hbase.hstore.flusher.count," The number of flush threads. With fewer threads, the MemStore flushes will be   queued. With more threads, the flushes will be executed in parallel, increasing the load on   HDFS, and potentially causing more compactions. ",2
hbase.hstore.blockingStoreFiles," If more than this number of StoreFiles exist in any one Store (one StoreFile  is written per flush of MemStore), updates are blocked for this region until a compaction is   completed, or until hbase.hstore.blockingWaitTime has been exceeded.",16
hbase.hstore.blockingWaitTime," The time for which a region will block updates after reaching the StoreFile limit defined by hbase.hstore.blockingStoreFiles. After this time has elapsed, the region will stop blocking updates even if a compaction has not been completed.",90000
hbase.hstore.compaction.min,"The minimum number of StoreFiles which must be eligible for compaction before   compaction can run. The goal of tuning hbase.hstore.compaction.min is to avoid ending up with   too many tiny StoreFiles to compact. Setting this value to 2 would cause a minor compaction   each time you have two StoreFiles in a Store, and this is probably not appropriate. If you   set this value too high, all the other values will need to be adjusted accordingly. For most   cases, the default value is appropriate. In previous versions of HBase, the parameter   hbase.hstore.compaction.min was named hbase.hstore.compactionThreshold.",3
hbase.hstore.compaction.max,"The maximum number of StoreFiles which will be selected for a single minor   compaction, regardless of the number of eligible StoreFiles. Effectively, the value of   hbase.hstore.compaction.max controls the length of time it takes a single compaction to   complete. Setting it larger means that more StoreFiles are included in a compaction. For most   cases, the default value is appropriate.",10
hbase.hstore.compaction.min.size,"A StoreFile (or a selection of StoreFiles, when using ExploringCompactionPolicy)   smaller than this size will always be eligible for minor compaction.   HFiles this size or larger are evaluated by hbase.hstore.compaction.ratio to determine if   they are eligible. Because this limit represents the ""automatic include"" limit for all   StoreFiles smaller than this value, this value may need to be reduced in write-heavy   environments where many StoreFiles in the 1-2 MB range are being flushed, because every   StoreFile will be targeted for compaction and the resulting StoreFiles may still be under the   minimum size and require further compaction. If this parameter is lowered, the ratio check is   triggered more quickly. This addressed some issues seen in earlier versions of HBase but   changing this parameter is no longer necessary in most situations. Default: 128 MB expressed   in bytes.",134217728
hbase.hstore.compaction.max.size,"A StoreFile (or a selection of StoreFiles, when using ExploringCompactionPolicy)   larger than this size will be excluded from compaction. The effect of   raising hbase.hstore.compaction.max.size is fewer, larger StoreFiles that do not get   compacted often. If you feel that compaction is happening too often without much benefit, you   can try raising this value. Default: the value of LONG.MAX_VALUE, expressed in bytes.",9223372036854775807
hbase.hstore.compaction.ratio,"For minor compaction, this ratio is used to determine whether a given StoreFile   which is larger than hbase.hstore.compaction.min.size is eligible for compaction. Its   effect is to limit compaction of large StoreFiles. The value of hbase.hstore.compaction.ratio   is expressed as a floating-point decimal. A large ratio, such as 10, will produce a single   giant StoreFile. Conversely, a low value, such as .25, will produce behavior similar to the   BigTable compaction algorithm, producing four StoreFiles. A moderate value of between 1.0 and   1.4 is recommended. When tuning this value, you are balancing write costs with read costs.   Raising the value (to something like 1.4) will have more write costs, because you will   compact larger StoreFiles. However, during reads, HBase will need to seek through fewer   StoreFiles to accomplish the read. Consider this approach if you cannot take advantage of   Bloom filters. Otherwise, you can lower this value to something like 1.0 to reduce the   background cost of writes, and use Bloom filters to control the number of StoreFiles touched   during reads. For most cases, the default value is appropriate.",1.2F
hbase.hstore.compaction.ratio.offpeak,"Allows you to set a different (by default, more aggressive) ratio for determining   whether larger StoreFiles are included in compactions during off-peak hours. Works in the   same way as hbase.hstore.compaction.ratio. Only applies if hbase.offpeak.start.hour and   hbase.offpeak.end.hour are also enabled.",5.0F
hbase.hstore.time.to.purge.deletes,"The amount of time to delay purging of delete markers with future timestamps. If   unset, or set to 0, all delete markers, including those with future timestamps, are purged   during the next major compaction. Otherwise, a delete marker is kept until the major compaction   which occurs after the marker's timestamp plus the value of this setting, in milliseconds. ",0
hbase.offpeak.start.hour,"The start of off-peak hours, expressed as an integer between 0 and 23, inclusive.   Set to -1 to disable off-peak.",-1
hbase.offpeak.end.hour,"The end of off-peak hours, expressed as an integer between 0 and 23, inclusive. Set   to -1 to disable off-peak.",-1
hbase.regionserver.thread.compaction.throttle,"There are two different thread pools for compactions, one for large compactions and   the other for small compactions. This helps to keep compaction of lean tables (such as   hbase:meta) fast. If a compaction is larger than this threshold, it   goes into the large compaction pool. In most cases, the default value is appropriate. Default:   2 x hbase.hstore.compaction.max x hbase.hregion.memstore.flush.size (which defaults to 128MB).   The value field assumes that the value of hbase.hregion.memstore.flush.size is unchanged from   the default.",2684354560
hbase.regionserver.majorcompaction.pagecache.drop,"Specifies whether to drop pages read/written into the system page cache by   major compactions. Setting it to true helps prevent major compactions from   polluting the page cache, which is almost always required, especially for clusters   with low/moderate memory to storage ratio.",true
hbase.regionserver.minorcompaction.pagecache.drop,"Specifies whether to drop pages read/written into the system page cache by   minor compactions. Setting it to true helps prevent minor compactions from   polluting the page cache, which is most beneficial on clusters with low   memory to storage ratio or very write heavy clusters. You may want to set it to   false under moderate to low write workload when bulk of the reads are   on the most recently written data.",true
hbase.hstore.compaction.kv.max,"The maximum number of KeyValues to read and then write in a batch when flushing or   compacting. Set this lower if you have big KeyValues and problems with Out Of Memory   Exceptions Set this higher if you have wide, small rows. ",10
hbase.storescanner.parallel.seek.enable,"   Enables StoreFileScanner parallel-seeking in StoreScanner,   a feature which can reduce response latency under special conditions.",false
hbase.storescanner.parallel.seek.threads,   The default thread pool size if parallel-seeking feature enabled.,10
hfile.block.cache.size,Percentage of maximum heap (-Xmx setting) to allocate to block cache  used by a StoreFile. Default of 0.4 means allocate 40%.  Set to 0 to disable but it's not recommended; you need at least  enough cache to hold the storefile indices.,0.4
hfile.block.index.cacheonwrite,This allows to put non-root multi-level index blocks into the block    cache at the time the index is being written.,false
hfile.index.block.max.size,"When the size of a leaf-level, intermediate-level, or root-level    index block in a multi-level block index grows to this size, the    block is written out and a new block is started.",131072
hbase.bucketcache.ioengine,"Where to store the contents of the bucketcache. One of: offheap, file, files or mmap. If a file or files, set it to file(s):PATH_TO_FILE. mmap means the content will be in an mmaped file. Use mmap:PATH_TO_FILE. See http://hbase.apache.org/book.html#offheap.blockcache for more information. ",
hbase.bucketcache.size,"A float that EITHER represents a percentage of total heap memory size to give to the cache (if < 1.0) OR, it is the total capacity in megabytes of BucketCache. Default: 0.0",
hbase.bucketcache.bucket.sizes,"A comma-separated list of sizes for buckets for the bucketcache. Can be multiple sizes. List block sizes in order from smallest to largest. The sizes you use will depend on your data access patterns. Must be a multiple of 256 else you will run into 'java.io.IOException: Invalid HFile block magic' when you go to read from cache. If you specify no values here, then you pick up the default bucketsizes set in code (See BucketAllocator#DEFAULT_BUCKET_SIZES).  ",
hfile.format.version,The HFile format version to use for new files.   Version 3 adds support for tags in hfiles (See http://hbase.apache.org/book.html#hbase.tags).   Also see the configuration 'hbase.replication.rpc.codec'.   ,3
hfile.block.bloom.cacheonwrite,Enables cache-on-write for inline blocks of a compound Bloom filter.,false
io.storefile.bloom.block.size,"The size in bytes of a single block (""chunk"") of a compound Bloom    filter. This size is approximate, because Bloom blocks can only be    inserted at data block boundaries, and the number of keys per data    block varies.",131072
hbase.rs.cacheblocksonwrite,Whether an HFile block should be added to the block cache when the  block is finished.,false
hbase.rpc.timeout,This is for the RPC layer to define how long (millisecond) HBase client applications  take for a remote call to time out. It uses pings to check connections  but will eventually throw a TimeoutException.,60000
hbase.client.operation.timeout,"Operation timeout is a top-level restriction (millisecond) that makes sure a   blocking operation in Table will not be blocked more than this. In each operation, if rpc   request fails because of timeout or other reason, it will retry until success or throw   RetriesExhaustedException. But if the total time being blocking reach the operation timeout   before retries exhausted, it will break early and throw SocketTimeoutException.",1200000
hbase.cells.scanned.per.heartbeat.check,The number of cells scanned in between heartbeat checks. Heartbeat  checks occur during the processing of scans to determine whether or not the  server should stop scanning in order to send back a heartbeat message to the  client. Heartbeat messages are used to keep the client-server connection alive  during long running scans. Small values mean that the heartbeat checks will  occur more often and thus will provide a tighter bound on the execution time of  the scan. Larger values mean that the heartbeat checks occur less frequently  ,10000
hbase.rpc.shortoperation.timeout,"This is another version of ""hbase.rpc.timeout"". For those RPC operation  within cluster, we rely on this configuration to set a short timeout limitation  for short operation. For example, short rpc timeout for region server's trying  to report to active master can benefit quicker master failover process.",10000
hbase.ipc.client.tcpnodelay,Set no delay on rpc socket connections.  See http://docs.oracle.com/javase/1.5.0/docs/api/java/net/Socket.html#getTcpNoDelay(),true
hbase.regionserver.hostname,"This config is for experts: don't set its value unless you really know what you are doing. When set to a non-empty value, this represents the (external facing) hostname for the underlying server. See https://issues.apache.org/jira/browse/HBASE-12954 for details.",
hbase.regionserver.hostname.disable.master.reversedns,"This config is for experts: don't set its value unless you really know what you are doing. When set to true, regionserver will use the current node hostname for the servername and HMaster will skip reverse DNS lookup and use the hostname sent by regionserver instead. Note that this config and hbase.regionserver.hostname are mutually exclusive. See https://issues.apache.org/jira/browse/HBASE-18226 for more details.",false
hbase.master.keytab.file,Full path to the kerberos keytab file to use for logging in the configured HMaster server principal.,
hbase.master.kerberos.principal,"Ex. ""hbase/_HOST@EXAMPLE.COM"".  The kerberos principal name that should be used to run the HMaster process.  The principal name should be in the form: user/hostname@DOMAIN.  If ""_HOST"" is used as the hostname portion, it will be replaced with the actual hostname of the running instance.",
hbase.regionserver.keytab.file,Full path to the kerberos keytab file to use for logging in the configured HRegionServer server principal.,
hbase.regionserver.kerberos.principal,"Ex. ""hbase/_HOST@EXAMPLE.COM"".  The kerberos principal name that should be used to run the HRegionServer process.  The principal name should be in the form: user/hostname@DOMAIN.  If ""_HOST"" is used as the hostname portion, it will be replaced with the actual hostname of the running instance.  An entry for this principal must exist in the file specified in hbase.regionserver.keytab.file",
hadoop.policy.file,The policy configuration file used by RPC servers to make   authorization decisions on client requests.  Only used when HBase   security is enabled.,hbase-policy.xml
hbase.superuser,"List of users or groups (comma-separated), who are allowed full privileges, regardless of stored ACLs, across the cluster. Only used when HBase security is enabled.",
hbase.auth.key.update.interval,The update interval for master key for authentication tokens in servers in milliseconds.  Only used when HBase security is enabled.,86400000
hbase.auth.token.max.lifetime,The maximum lifetime in milliseconds after which an authentication token expires.  Only used when HBase security is enabled.,604800000
hbase.ipc.client.fallback-to-simple-auth-allowed,"When a client is configured to attempt a secure connection, but attempts to   connect to an insecure server, that server may instruct the client to   switch to SASL SIMPLE (unsecure) authentication. This setting controls   whether or not the client will accept this instruction from the server.   When false (the default), the client will not allow the fallback to SIMPLE   authentication, and will abort the connection.",false
hbase.ipc.server.fallback-to-simple-auth-allowed,"When a server is configured to require secure connections, it will   reject connection attempts from clients using SASL SIMPLE (unsecure) authentication.   This setting allows secure servers to accept SASL SIMPLE connections from clients   when the client requests.  When false (the default), the server will not allow the fallback   to SIMPLE authentication, and will reject the connection.  WARNING: This setting should ONLY   be used as a temporary measure while converting clients over to secure authentication.  It   MUST BE DISABLED for secure operation.",false
hbase.display.keys,"When this is set to true the webUI and such will display all start/end keys     as part of the table details, region names, etc. When this is set to false,     the keys are hidden.",true
hbase.coprocessor.enabled,"Enables or disables coprocessor loading. If 'false' (disabled), any other coprocessor related configuration will be ignored. ",true
hbase.coprocessor.user.enabled,"Enables or disables user (aka. table) coprocessor loading. If 'false' (disabled), any table coprocessor attributes in table descriptors will be ignored. If ""hbase.coprocessor.enabled"" is 'false' this setting has no effect. ",true
hbase.coprocessor.region.classes,"A comma-separated list of Coprocessors that are loaded by default on all tables. For any override coprocessor method, these classes will be called in order. After implementing your own Coprocessor, just put it in HBase's classpath and add the fully qualified class name here. A coprocessor can also be loaded on demand by setting HTableDescriptor.",
hbase.coprocessor.master.classes,"A comma-separated list of org.apache.hadoop.hbase.coprocessor.MasterObserver coprocessors that are loaded by default on the active HMaster process. For any implemented coprocessor methods, the listed classes will be called in order. After implementing your own MasterObserver, just put it in HBase's classpath and add the fully qualified class name here.",
hbase.coprocessor.abortonerror,"Set to true to cause the hosting server (master or regionserver)   to abort if a coprocessor fails to load, fails to initialize, or throws an   unexpected Throwable object. Setting this to false will allow the server to   continue execution but the system wide state of the coprocessor in question   will become inconsistent as it will be properly executing in only a subset   of servers, so this is most useful for debugging only.",true
hbase.rest.port,The port for the HBase REST server.,8080
hbase.rest.readonly,Defines the mode the REST server will be started in. Possible values are: false: All HTTP methods are permitted - GET/PUT/POST/DELETE. true: Only the GET method is permitted.,false
hbase.rest.threads.max,"The maximum number of threads of the REST server thread pool.  Threads in the pool are reused to process REST requests. This  controls the maximum number of requests processed concurrently.  It may help to control the memory used by the REST server to  avoid OOM issues. If the thread pool is full, incoming requests  will be queued up and wait for some free threads.",100
hbase.rest.threads.min,The minimum number of threads of the REST server thread pool.  The thread pool always has at least these number of threads so  the REST server is ready to serve incoming requests.,2
hbase.rest.support.proxyuser,Enables running the REST server to support proxy-user mode.,false
hbase.defaults.for.version,This defaults file was compiled for version ${project.version}. This variable is used to make sure that a user doesn't have an old version of hbase-default.xml on the classpath.,@@@VERSION@@@
hbase.defaults.for.version.skip,"Set to true to skip the 'hbase.defaults.for.version' check. Setting this to true can be useful in contexts other than the other side of a maven generation; i.e. running in an IDE.  You'll want to set this boolean to true to avoid seeing the RuntimeException complaint: ""hbase-default.xml file seems to be for and old version of HBase (\${hbase.version}), this version is X.X.X-SNAPSHOT""",false
hbase.table.lock.enable,Set to true to enable locking the table in zookeeper for schema change operations. Table locking from master prevents concurrent schema modifications to corrupt table state.,true
hbase.table.max.rowsize,   Maximum size of single row in bytes (default is 1 Gb) for Get'ting   or Scan'ning without in-row scan flag set. If row size exceeds this limit   RowTooBigException is thrown to client. ,1073741824
hbase.thrift.minWorkerThreads,"The ""core size"" of the thread pool. New threads are created on every connection until this many threads are created.",16
hbase.thrift.maxWorkerThreads,"The maximum size of the thread pool. When the pending request queue overflows, new threads are created until their number reaches this number. After that, the server starts dropping connections.",1000
hbase.thrift.maxQueuedRequests,"The maximum number of pending Thrift connections waiting in the queue. If  there are no idle threads in the pool, the server queues requests. Only  when the queue overflows, new threads are added, up to  hbase.thrift.maxQueuedRequests threads.",1000
hbase.regionserver.thrift.framed,"Use Thrift TFramedTransport on the server side.   This is the recommended transport for thrift servers and requires a similar setting   on the client side. Changing this to false will select the default transport,   vulnerable to DoS when malformed requests are issued due to THRIFT-601. ",false
hbase.regionserver.thrift.framed.max_frame_size_in_mb,"Default frame size when using framed transport, in MB",2
hbase.regionserver.thrift.compact,Use Thrift TCompactProtocol binary serialization protocol.,false
hbase.rootdir.perms,"FS Permissions for the root data subdirectory in a secure (kerberos) setup. When master starts, it creates the rootdir with this permissions or sets the permissions if it does not match.",700
hbase.wal.dir.perms,"FS Permissions for the root WAL directory in a secure(kerberos) setup.   When master starts, it creates the WAL dir with this permissions or sets the permissions   if it does not match.",700
hbase.data.umask.enable,"Enable, if true, that file permissions should be assigned   to the files written by the regionserver",false
hbase.data.umask,File permissions that should be used to write data   files when hbase.data.umask.enable is true,000
hbase.snapshot.enabled,Set to true to allow snapshots to be taken / restored / cloned.,true
hbase.snapshot.restore.take.failsafe.snapshot,"Set to true to take a snapshot before the restore operation.   The snapshot taken will be used in case of failure, to restore the previous state.   At the end of the restore operation this snapshot will be deleted",true
hbase.snapshot.restore.failsafe.name,"Name of the failsafe snapshot taken by the restore operation.   You can use the {snapshot.name}, {table.name} and {restore.timestamp} variables   to create a name based on what you are restoring.",hbase-failsafe-{snapshot.name}-{restore.timestamp}
hbase.server.compactchecker.interval.multiplier,"The number that determines how often we scan to see if compaction is necessary.  Normally, compactions are done after some events (such as memstore flush), but if  region didn't receive a lot of writes for some time, or due to different compaction  policies, it may be necessary to check it periodically. The interval between checks is  hbase.server.compactchecker.interval.multiplier multiplied by  hbase.server.thread.wakefrequency.",1000
hbase.lease.recovery.timeout,How long we wait on dfs lease recovery in total before giving up.,900000
hbase.lease.recovery.dfs.timeout,"How long between dfs recover lease invocations. Should be larger than the sum of  the time it takes for the namenode to issue a block recovery command as part of  datanode; dfs.heartbeat.interval and the time it takes for the primary  datanode, performing block recovery to timeout on a dead datanode; usually  dfs.client.socket-timeout. See the end of HBASE-8389 for more.",64000
hbase.column.max.version,New column family descriptors will use this value as the default number of versions   to keep.,1
dfs.client.read.shortcircuit,"   If set to true, this configuration parameter enables short-circuit local   reads. ",false
dfs.domain.socket.path,"   This is a path to a UNIX domain socket that will be used for   communication between the DataNode and local HDFS clients, if   dfs.client.read.shortcircuit is set to true. If the string ""_PORT"" is   present in this path, it will be replaced by the TCP port of the DataNode.   Be careful about permissions for the directory that hosts the shared   domain socket; dfsclient will complain if open to other users than the HBase user. ",none
hbase.dfs.client.read.shortcircuit.buffer.size,"If the DFSClient configuration dfs.client.read.shortcircuit.buffer.size is unset, we will use what is configured here as the short circuit read default direct byte buffer size. DFSClient native default is 1MB; HBase keeps its HDFS files open so number of file blocks * 1MB soon starts to add up and threaten OOME because of a shortage of direct memory.  So, we set it down from the default.  Make it > the default hbase block size set in the HColumnDescriptor which is usually 64k. ",131072
hbase.regionserver.checksum.verify,"  If set to true (the default), HBase verifies the checksums for hfile  blocks. HBase writes checksums inline with the data when it writes out  hfiles. HDFS (as of this writing) writes checksums to a separate file  than the data file necessitating extra seeks.  Setting this flag saves  some on i/o.  Checksum verification by HDFS will be internally disabled  on hfile streams when this flag is set.  If the hbase-checksum verification  fails, we will switch back to using HDFS checksums (so do not disable HDFS  checksums!  And besides this feature applies to hfiles only, not to WALs).  If this parameter is set to false, then hbase will not verify any checksums,  instead it will depend on checksum verification being done in the HDFS client. ",true
hbase.hstore.bytes.per.checksum,  Number of bytes in a newly created checksum chunk for HBase-level  checksums in hfile blocks. ,16384
hbase.hstore.checksum.algorithm,"   Name of an algorithm that is used to compute checksums. Possible values   are NULL, CRC32, CRC32C. ",CRC32C
hbase.client.scanner.max.result.size,"Maximum number of bytes returned when calling a scanner's next method. Note that when a single row is larger than this limit the row is still returned completely. The default value is 2MB, which is good for 1ge networks. With faster and/or high latency networks this value should be increased. ",2097152
hbase.server.scanner.max.result.size,Maximum number of bytes returned when calling a scanner's next method. Note that when a single row is larger than this limit the row is still returned completely. The default value is 100MB. This is a safety setting to protect the server from OOM situations. ,104857600
hbase.status.published,"   This setting activates the publication by the master of the status of the region server.   When a region server dies and its recovery starts, the master will push this information   to the client application, to let them cut the connection immediately instead of waiting   for a timeout. ",false
hbase.status.publisher.class,   Implementation of the status publication with a multicast message. ,org.apache.hadoop.hbase.master.ClusterStatusPublisher$MulticastPublisher
hbase.status.listener.class,   Implementation of the status listener with a multicast message. ,org.apache.hadoop.hbase.client.ClusterStatusListener$MulticastListener
hbase.status.multicast.address.ip,   Multicast address to use for the status publication by multicast. ,226.1.1.3
hbase.status.multicast.address.port,   Multicast port to use for the status publication by multicast. ,16100
hbase.dynamic.jars.dir,"   The directory from which the custom filter JARs can be loaded   dynamically by the region server without the need to restart. However,   an already loaded filter/co-processor class would not be un-loaded. See   HBASE-1936 for more details.   Does not apply to coprocessors. ",${hbase.rootdir}/lib
hbase.security.authentication,"   Controls whether or not secure authentication is enabled for HBase.   Possible values are 'simple' (no authentication), and 'kerberos'. ",simple
hbase.rest.filter.classes,   Servlet filters for REST service. ,org.apache.hadoop.hbase.rest.filter.GzipFilter
hbase.master.loadbalancer.class,   Class used to execute the regions balancing when the period occurs.   See the class comment for more on how it works   http://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/master/balancer/StochasticLoadBalancer.html   It replaces the DefaultLoadBalancer as the default (since renamed   as the SimpleLoadBalancer). ,org.apache.hadoop.hbase.master.balancer.StochasticLoadBalancer
hbase.master.loadbalance.bytable,Factor Table name when the balancer runs.   Default: false. ,false
hbase.master.normalizer.class,   Class used to execute the region normalization when the period occurs.   See the class comment for more on how it works   http://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/master/normalizer/SimpleRegionNormalizer.html ,org.apache.hadoop.hbase.master.normalizer.SimpleRegionNormalizer
hbase.rest.csrf.enabled, Set to true to enable protection against cross-site request forgery (CSRF)	,false
hbase.rest-csrf.browser-useragents-regex," A comma-separated list of regular expressions used to match against an HTTP request's User-Agent header when protection against cross-site request forgery (CSRF) is enabled for REST server by setting hbase.rest.csrf.enabled to true.  If the incoming User-Agent matches any of these regular expressions, then the request is considered to be sent by a browser, and therefore CSRF prevention is enforced.  If the request's User-Agent does not match any of these regular expressions, then the request is considered to be sent by something other than a browser, such as scripted automation.  In this case, CSRF is not a potential attack vector, so the prevention is not enforced.  This helps achieve backwards-compatibility with existing automation that has not been updated to send the CSRF prevention header.  ","^Mozilla.*,^Opera.*"
hbase.security.exec.permission.checks,"   If this setting is enabled and ACL based access control is active (the   AccessController coprocessor is installed either as a system coprocessor   or on a table as a table coprocessor) then you must grant all relevant   users EXEC privilege if they require the ability to execute coprocessor   endpoint calls. EXEC privilege, like any other permission, can be   granted globally to a user, or to a user on a per table or per namespace   basis. For more information on coprocessor endpoints, see the coprocessor   section of the HBase online manual. For more information on granting or   revoking permissions using the AccessController, see the security   section of the HBase online manual. ",false
hbase.procedure.regionserver.classes,"A comma-separated list of org.apache.hadoop.hbase.procedure.RegionServerProcedureManager procedure managers that are loaded by default on the active HRegionServer process. The lifecycle methods (init/start/stop) will be called by the active HRegionServer process to perform the specific globally barriered procedure. After implementing your own RegionServerProcedureManager, just put it in HBase's classpath and add the fully qualified class name here. ",
hbase.procedure.master.classes,"A comma-separated list of org.apache.hadoop.hbase.procedure.MasterProcedureManager procedure managers that are loaded by default on the active HMaster process. A procedure is identified by its signature and users can use the signature and an instant name to trigger an execution of a globally barriered procedure. After implementing your own MasterProcedureManager, just put it in HBase's classpath and add the fully qualified class name here.",
hbase.coordinated.state.manager.class,Fully qualified name of class implementing coordinated state manager.,org.apache.hadoop.hbase.coordination.ZkCoordinatedStateManager
hbase.regionserver.storefile.refresh.period,   The period (in milliseconds) for refreshing the store files for the secondary regions. 0   means this feature is disabled. Secondary regions sees new files (from flushes and   compactions) from primary once the secondary region refreshes the list of files in the   region (there is no notification mechanism). But too frequent refreshes might cause   extra Namenode pressure. If the files cannot be refreshed for longer than HFile TTL   (hbase.master.hfilecleaner.ttl) the requests are rejected. Configuring HFile TTL to a larger   value is also recommended with this setting. ,0
hbase.region.replica.replication.enabled,"   Whether asynchronous WAL replication to the secondary region replicas is enabled or not.   If this is enabled, a replication peer named ""region_replica_replication"" will be created   which will tail the logs and replicate the mutations to region replicas for tables that   have region replication > 1. If this is enabled once, disabling this replication also   requires disabling the replication peer using shell or Admin java class.   Replication to secondary region replicas works over standard inter-cluster replication. ",false
hbase.http.filter.initializers,"   A comma separated list of class names. Each class in the list must extend   org.apache.hadoop.hbase.http.FilterInitializer. The corresponding Filter will   be initialized. Then, the Filter will be applied to all user facing jsp   and servlet web pages.   The ordering of the list defines the ordering of the filters.   The default StaticUserWebFilter add a user principal as defined by the   hbase.http.staticuser.user property. ",org.apache.hadoop.hbase.http.lib.StaticUserWebFilter
hbase.security.visibility.mutations.checkauths,"   This property if enabled, will check whether the labels in the visibility   expression are associated with the user issuing the mutation ",false
hbase.http.max.threads,   The maximum number of threads that the HTTP Server will create in its   ThreadPool. ,16
hbase.replication.rpc.codec,  		The codec that is to be used when replication is enabled so that  		the tags are also replicated. This is used along with HFileV3 which  		supports tags in them.  If tags are not used or if the hfile version used  		is HFileV2 then KeyValueCodec can be used as the replication codec. Note that  		using KeyValueCodecWithTags for replication when there are no tags causes no harm.  	,org.apache.hadoop.hbase.codec.KeyValueCodecWithTags
hbase.replication.source.maxthreads,  The maximum number of threads any replication source will use for  shipping edits to the sinks in parallel. This also limits the number of  chunks each replication batch is broken into. Larger values can improve  the replication throughput between the master and slave clusters. The  default of 10 will rarely need to be changed. ,10
hbase.http.staticuser.user,"   The user name to filter as, on static web filters   while rendering content. An example use is the HDFS   web UI (user to be used for browsing files). ",dr.stack
hbase.regionserver.handler.abort.on.error.percent,The percent of region server RPC threads failed to abort RS. -1 Disable aborting; 0 Abort if even a single handler has died; 0.x Abort only when this percent of handlers have died; 1 Abort only all of the handers have died.,0.5
hbase.mob.file.cache.size,"   Number of opened file handlers to cache.   A larger value will benefit reads by providing more file handlers per mob   file cache and would reduce frequent file opening and closing.   However, if this is set too high, this could lead to a ""too many opened file handlers""   The default value is 1000. ",1000
hbase.mob.cache.evict.period,   The amount of time in seconds before the mob cache evicts cached mob files.   The default value is 3600 seconds. ,3600
hbase.mob.cache.evict.remain.ratio,   The ratio (between 0.0 and 1.0) of files that remains cached after an eviction   is triggered when the number of cached mob files exceeds the hbase.mob.file.cache.size.   The default value is 0.5f. ,0.5f
hbase.master.mob.ttl.cleaner.period,   The period that ExpiredMobFileCleanerChore runs. The unit is second.   The default value is one day. The MOB file name uses only the date part of   the file creation time in it. We use this time for deciding TTL expiry of   the files. So the removal of TTL expired files might be delayed. The max   delay might be 24 hrs. ,86400
hbase.mob.compaction.mergeable.threshold,"   If the size of a mob file is less than this value, it's regarded as a small   file and needs to be merged in mob compaction. The default value is 1280MB. ",1342177280
hbase.mob.delfile.max.count,"   The max number of del files that is allowed in the mob compaction.   In the mob compaction, when the number of existing del files is larger than   this value, they are merged until number of del files is not larger this value.   The default value is 3. ",3
hbase.mob.compaction.batch.size,"   The max number of the mob files that is allowed in a batch of the mob compaction.   The mob compaction merges the small mob files to bigger ones. If the number of the   small files is very large, it could lead to a ""too many opened file handlers"" in the merge.   And the merge has to be split into batches. This value limits the number of mob files   that are selected in a batch of the mob compaction. The default value is 100. ",100
hbase.mob.compaction.chore.period,   The period that MobCompactionChore runs. The unit is second.   The default value is one week. ,604800
hbase.mob.compactor.class,"   Implementation of mob compactor, the default one is PartitionedMobCompactor. ",org.apache.hadoop.hbase.mob.compactions.PartitionedMobCompactor
hbase.mob.compaction.threads.max,   The max number of threads used in MobCompactor. ,1
hbase.snapshot.master.timeout.millis,    Timeout for master for the snapshot procedure execution. ,300000
hbase.snapshot.region.timeout,    Timeout for regionservers to keep threads in snapshot request pool waiting. ,300000
hbase.rpc.rows.warning.threshold,   Number of rows in a batch operation above which a warning will be logged. ,5000
hbase.master.wait.on.service.seconds,Default is 5 minutes. Make it 30 seconds for tests. See HBASE-19794 for some context.,30
hadoop.hdfs.configuration.version,version of this configuration file,1
dfs.namenode.rpc-address," RPC address that handles all clients requests. In the case of HA/Federation where multiple namenodes exist, the name service id is added to the name e.g. dfs.namenode.rpc-address.ns1 dfs.namenode.rpc-address.EXAMPLENAMESERVICE The value of this property will take the form of nn-host1:rpc-port.  ",
dfs.namenode.rpc-bind-host," The actual address the RPC server will bind to. If this optional address is set, it overrides only the hostname portion of dfs.namenode.rpc-address. It can also be specified per name node or name service for HA/Federation. This is useful for making the name node listen on all interfaces by setting it to 0.0.0.0.  ",
dfs.namenode.servicerpc-address," RPC address for HDFS Services communication. BackupNode, Datanodes and all other services should be connecting to this address if it is configured. In the case of HA/Federation where multiple namenodes exist, the name service id is added to the name e.g. dfs.namenode.servicerpc-address.ns1 dfs.namenode.rpc-address.EXAMPLENAMESERVICE The value of this property will take the form of nn-host1:rpc-port. If the value of this property is unset the value of dfs.namenode.rpc-address will be used as the default.  ",
dfs.namenode.servicerpc-bind-host," The actual address the service RPC server will bind to. If this optional address is set, it overrides only the hostname portion of dfs.namenode.servicerpc-address. It can also be specified per name node or name service for HA/Federation. This is useful for making the name node listen on all interfaces by setting it to 0.0.0.0.  ",
dfs.namenode.lifeline.rpc-address," NameNode RPC lifeline address.  This is an optional separate RPC address that can be used to isolate health checks and liveness to protect against resource exhaustion in the main RPC handler pool.  In the case of HA/Federation where multiple NameNodes exist, the name service ID is added to the name e.g. dfs.namenode.lifeline.rpc-address.ns1.  The value of this property will take the form of nn-host1:rpc-port.  If this property is not defined, then the NameNode will not start a lifeline RPC server.  By default, the property is not defined.  ",
dfs.namenode.lifeline.rpc-bind-host," The actual address the lifeline RPC server will bind to.  If this optional address is set, it overrides only the hostname portion of dfs.namenode.lifeline.rpc-address.  It can also be specified per name node or name service for HA/Federation.  This is useful for making the name node listen on all interfaces by setting it to 0.0.0.0.  ",
dfs.namenode.secondary.http-address, The secondary namenode http server address and port.  ,0.0.0.0:50090
dfs.namenode.secondary.https-address, The secondary namenode HTTPS server address and port.  ,0.0.0.0:50091
dfs.datanode.address, The datanode server address and port for data transfer.  ,0.0.0.0:50010
dfs.datanode.http.address, The datanode http server address and port.  ,0.0.0.0:50075
dfs.datanode.ipc.address, The datanode ipc server address and port.  ,0.0.0.0:50020
dfs.datanode.http.internal-proxy.port, The datanode's internal web proxy port. By default it selects a random port available in runtime.  ,0
dfs.datanode.handler.count,The number of server threads for the datanode.,10
dfs.namenode.http-address, The address and the base port where the dfs namenode web ui will listen on.  ,0.0.0.0:50070
dfs.namenode.http-bind-host," The actual adress the HTTP server will bind to. If this optional address is set, it overrides only the hostname portion of dfs.namenode.http-address. It can also be specified per name node or name service for HA/Federation. This is useful for making the name node HTTP server listen on all interfaces by setting it to 0.0.0.0.  ",
dfs.namenode.heartbeat.recheck-interval," This time decides the interval to check for expired datanodes. With this value and dfs.heartbeat.interval, the interval of deciding the datanode is stale or not is also calculated. The unit of this configuration is millisecond.  ",300000
dfs.http.policy,Decide if HTTPS(SSL) is supported on HDFS This configures the HTTP endpoint for HDFS daemons:   The following values are supported:   - HTTP_ONLY : Service is provided only on http   - HTTPS_ONLY : Service is provided only on https   - HTTP_AND_HTTPS : Service is provided both on http and https  ,HTTP_ONLY
dfs.client.https.need-auth,Whether SSL client certificate authentication is required  ,false
dfs.client.cached.conn.retry,"The number of times the HDFS client will pull a socket from the   cache.  Once this number is exceeded, the client will try to create a new   socket.  ",3
dfs.https.server.keystore.resource,Resource file from which ssl server keystore  information will be extracted  ,ssl-server.xml
dfs.client.https.keystore.resource,Resource file from which ssl client keystore  information will be extracted  ,ssl-client.xml
dfs.datanode.https.address,The datanode secure http server address and port.,0.0.0.0:50475
dfs.namenode.https-address,The namenode secure http server address and port.,0.0.0.0:50470
dfs.namenode.https-bind-host," The actual adress the HTTPS server will bind to. If this optional address is set, it overrides only the hostname portion of dfs.namenode.https-address. It can also be specified per name node or name service for HA/Federation. This is useful for making the name node HTTPS server listen on all interfaces by setting it to 0.0.0.0.  ",
dfs.datanode.dns.interface,  The name of the Network Interface from which a data node should  report its IP address. e.g. eth2. This setting may be required for some  multi-homed nodes where the DataNodes are assigned multiple hostnames  and it is desirable for the DataNodes to use a non-default hostname.  Prefer using hadoop.security.dns.interface over  dfs.datanode.dns.interface.   ,default
dfs.datanode.dns.nameserver, The host name or IP address of the name server (DNS) which a DataNode should use to determine its own host name. Prefer using hadoop.security.dns.nameserver over dfs.datanode.dns.nameserver.  ,default
dfs.namenode.backup.address, The backup node server address and port. If the port is 0 then the server will start on a free port.  ,0.0.0.0:50100
dfs.namenode.backup.http-address, The backup node http server address and port. If the port is 0 then the server will start on a free port.  ,0.0.0.0:50105
dfs.namenode.replication.considerLoad,Decide if chooseTarget considers the target's load or not  ,true
dfs.namenode.replication.considerLoad.factor,"The factor by which a node's load can exceed the average   before being rejected for writes, only if considerLoad is true. ",2.0
dfs.default.chunk.view.size,The number of bytes to view for a file on the browser.  ,32768
dfs.datanode.du.reserved.calculator,"Determines the class of ReservedSpaceCalculator to be used for calculating disk space reservedfor non-HDFS data. The default calculator is ReservedSpaceCalculatorAbsolute which will use dfs.datanode.du.reserved for a static reserved number of bytes. ReservedSpaceCalculatorPercentage will use dfs.datanode.du.reserved.pct to calculate the reserved number of bytes based on the size of the storage. ReservedSpaceCalculatorConservative and ReservedSpaceCalculatorAggressive will use their combination, Conservative will use maximum, Aggressive minimum. For more details see ReservedSpaceCalculator.  ",org.apache.hadoop.hdfs.server.datanode.fsdataset.impl.ReservedSpaceCalculator$ReservedSpaceCalculatorAbsolute
dfs.datanode.du.reserved,"Reserved space in bytes per volume. Always leave this much space free for non dfs use.   Specific storage type based reservation is also supported. The property can be followed with   corresponding storage types ([ssd]/[disk]/[archive]/[ram_disk]) for cluster with heterogeneous storage.   For example, reserved space for RAM_DISK storage can be configured using property   'dfs.datanode.du.reserved.ram_disk'. If specific storage type reservation is not configured   then dfs.datanode.du.reserved will be used.  ",0
dfs.datanode.du.reserved.pct,"Reserved space in percentage. Read dfs.datanode.du.reserved.calculator to see when this takes effect. The actual number of bytes reserved will be calculated by using the total capacity of the data directory in question. Specific storage type based reservation is also supported. The property can be followed with corresponding storage types ([ssd]/[disk]/[archive]/[ram_disk]) for cluster with heterogeneous storage. For example, reserved percentage space for RAM_DISK storage can be configured using property 'dfs.datanode.du.reserved.pct.ram_disk'. If specific storage type reservation is not configured then dfs.datanode.du.reserved.pct will be used.  ",0
dfs.namenode.name.dir,"Determines where on the local filesystem the DFS name node   should store the name table(fsimage).  If this is a comma-delimited list   of directories then the name table is replicated in all of the   directories, for redundancy. ",file://${hadoop.tmp.dir}/dfs/name
dfs.namenode.name.dir.restore,"Set to true to enable NameNode to attempt recovering a   previously failed dfs.namenode.name.dir. When enabled, a recovery of any   failed directory is attempted during checkpoint.",false
dfs.namenode.fs-limits.max-component-length,Defines the maximum number of bytes in UTF-8 encoding in each   component of a path.  A value of 0 will disable the check.,255
dfs.namenode.fs-limits.max-directory-items,Defines the maximum number of items that a directory may   contain. Cannot set the property to a value less than 1 or more than   6400000.,1048576
dfs.namenode.fs-limits.min-block-size,"Minimum block size in bytes, enforced by the Namenode at create   time. This prevents the accidental creation of files with tiny block   sizes (and thus many blocks), which can degrade   performance.",1048576
dfs.namenode.fs-limits.max-blocks-per-file,"Maximum number of blocks per file, enforced by the Namenode on  write. This prevents the creation of extremely large files which can  degrade performance.",1048576
dfs.namenode.edits.dir,"Determines where on the local filesystem the DFS name node   should store the transaction (edits) file. If this is a comma-delimited list   of directories then the transaction file is replicated in all of the    directories, for redundancy. Default value is same as dfs.namenode.name.dir  ",${dfs.namenode.name.dir}
dfs.namenode.edits.dir.required,"This should be a subset of dfs.namenode.edits.dir,   to ensure that the transaction (edits) file   in these places is always up-to-date.  ",
dfs.namenode.shared.edits.dir,A directory on shared storage between the multiple namenodes  in an HA cluster. This directory will be written by the active and read  by the standby in order to keep the namespaces synchronized. This directory  does not need to be listed in dfs.namenode.edits.dir above. It should be  left empty in a non-HA cluster.  ,
dfs.namenode.edits.journal-plugin.qjournal,,org.apache.hadoop.hdfs.qjournal.client.QuorumJournalManager
dfs.permissions.enabled," If ""true"", enable permission checking in HDFS. If ""false"", permission checking is turned off, but all other behavior is unchanged. Switching from one parameter value to the other does not change the mode, owner or group of files or directories.  ",true
dfs.permissions.superusergroup,The name of the group of super-users. The value should be a single group name.  ,supergroup
dfs.cluster.administrators,"ACL for the admins, this configuration is used to control  who can access the default servlets in the namenode, etc. The value  should be a comma separated list of users and groups. The user list  comes first and is separated by a space followed by the group list,  e.g. ""user1,user2 group1,group2"". Both users and groups are optional,  so ""user1"", "" group1"", """", ""user1 group1"", ""user1,user2 group1,group2""  are all valid (note the leading space in "" group1""). '*' grants access  to all users and groups, e.g. '*', '* ' and ' *' are all valid.   ",
dfs.namenode.acls.enabled," Set to true to enable support for HDFS ACLs (Access Control Lists).  By default, ACLs are disabled.  When ACLs are disabled, the NameNode rejects all RPCs related to setting or getting ACLs.  ",false
dfs.namenode.lazypersist.file.scrub.interval.sec, The NameNode periodically scans the namespace for LazyPersist files with missing blocks and unlinks them from the namespace. This configuration key controls the interval between successive scans. Set it to a negative value to disable this behavior.  ,300
dfs.block.access.token.enable," If ""true"", access tokens are used as capabilities for accessing datanodes. If ""false"", no access tokens are checked on accessing datanodes.  ",false
dfs.block.access.key.update.interval, Interval in minutes at which namenode updates its access keys.  ,600
dfs.block.access.token.lifetime,The lifetime of access tokens in minutes.,600
dfs.datanode.data.dir,"Determines where on the local filesystem an DFS data node  should store its blocks.  If this is a comma-delimited  list of directories, then data will be stored in all named  directories, typically on different devices. The directories should be tagged  with corresponding storage types ([SSD]/[DISK]/[ARCHIVE]/[RAM_DISK]) for HDFS  storage policies. The default storage type will be DISK if the directory does  not have a storage type tagged explicitly. Directories that do not exist will  be created if local filesystem permission allows.  ",file://${hadoop.tmp.dir}/dfs/data
dfs.datanode.data.dir.perm,Permissions for the directories on on the local filesystem where  the DFS data node store its blocks. The permissions can either be octal or  symbolic.,700
dfs.replication,Default block replication.   The actual number of replications can be specified when the file is created.  The default is used if replication is not specified in create time.  ,3
dfs.replication.max,Maximal block replication.   ,512
dfs.namenode.replication.min,Minimal block replication.   ,1
dfs.namenode.maintenance.replication.min,Minimal live block replication in existence of maintenance mode.  ,1
dfs.namenode.safemode.replication.min,   a separate minimum replication factor for calculating safe block count.   This is an expert level setting.   Setting this lower than the dfs.namenode.replication.min   is not recommend and/or dangerous for production setups.   When it's not set it takes value from dfs.namenode.replication.min  ,
dfs.namenode.max-corrupt-file-blocks-returned,"   The maximum number of corrupt file blocks listed by NameNode Web UI,   JMX and other client request.  ",100
dfs.blocksize,"   The default block size for new files, in bytes.   You can use the following suffix (case insensitive):   k(kilo), m(mega), g(giga), t(tera), p(peta), e(exa) to specify the size (such as 128k, 512m, 1g, etc.),   Or provide complete size in bytes (such as 134217728 for 128 MB).  ",134217728
dfs.client.block.write.retries,"The number of retries for writing blocks to the data nodes,   before we signal failure to the application.  ",3
dfs.client.block.write.replace-datanode-on-failure.enable," If there is a datanode/network failure in the write pipeline, DFSClient will try to remove the failed datanode from the pipeline and then continue writing with the remaining datanodes. As a result, the number of datanodes in the pipeline is decreased.  The feature is to add new datanodes to the pipeline. This is a site-wide property to enable/disable the feature. When the cluster size is extremely small, e.g. 3 nodes or less, cluster administrators may want to set the policy to NEVER in the default configuration file or disable this feature.  Otherwise, users may experience an unusually high rate of pipeline failures since it is impossible to find new datanodes for replacement. See also dfs.client.block.write.replace-datanode-on-failure.policy  ",true
dfs.client.block.write.replace-datanode-on-failure.policy, This property is used only if the value of dfs.client.block.write.replace-datanode-on-failure.enable is true. ALWAYS: always add a new datanode when an existing datanode is removed.  NEVER: never add a new datanode. DEFAULT:    Let r be the replication number.   Let n be the number of existing datanodes.   Add a new datanode only if r is greater than or equal to 3 and either   (1) floor(r/2) is greater than or equal to n; or   (2) r is greater than n and the block is hflushed/appended.  ,DEFAULT
dfs.client.block.write.replace-datanode-on-failure.best-effort," This property is used only if the value of dfs.client.block.write.replace-datanode-on-failure.enable is true. Best effort means that the client will try to replace a failed datanode in write pipeline (provided that the policy is satisfied), however, it  continues the write operation in case that the datanode replacement also fails. Suppose the datanode replacement fails. false: An exception should be thrown so that the write will fail. true : The write should be resumed with the remaining datandoes.   Note that setting this property to true allows writing to a pipeline with a smaller number of datanodes.  As a result, it increases the probability of data loss.  ",false
dfs.client.block.write.replace-datanode-on-failure.min-replication,"   The minimum number of replications that are needed to not to fail   the write pipeline if new datanodes can not be found to replace   failed datanodes (could be due to network failure) in the write pipeline.   If the number of the remaining datanodes in the write pipeline is greater   than or equal to this property value, continue writing to the remaining nodes.   Otherwise throw exception.   If this is set to 0, an exception will be thrown, when a replacement   can not be found.   See also dfs.client.block.write.replace-datanode-on-failure.policy ",0
dfs.blockreport.intervalMsec,Determines block reporting interval in milliseconds.,21600000
dfs.blockreport.initialDelay,Delay for first block report in seconds.,0
dfs.blockreport.split.threshold,If the number of blocks on the DataNode is below this threshold then it will send block reports for all Storage Directories in a single message. If the number of blocks exceeds this threshold then the DataNode will send block reports for each Storage Directory in separate messages. Set to zero to always split. ,1000000
dfs.namenode.max.full.block.report.leases,The maximum number of leases for full block reports that the NameNode will issue at any given time.  This prevents the NameNode from being flooded with full block reports that use up all the RPC handler threads.  This number should never be more than the number of RPC handler threads or less than 1.  ,6
dfs.namenode.full.block.report.lease.length.ms, The number of milliseconds that the NameNode will wait before invalidating a full block report lease.  This prevents a crashed DataNode from permanently using up a full block report lease.  ,300000
dfs.datanode.directoryscan.interval,Interval in seconds for Datanode to scan data directories and  reconcile the difference between blocks in memory and on the disk.  ,21600
dfs.datanode.directoryscan.threads,How many threads should the threadpool used to compile reports  for volumes in parallel have.  ,1
dfs.datanode.directoryscan.throttle.limit.ms.per.sec,"The report compilation threads are limited to only running for  a given number of milliseconds per second, as configured by the  property. The limit is taken per thread, not in aggregate, e.g. setting  a limit of 100ms for 4 compiler threads will result in each thread being  limited to 100ms, not 25ms.  Note that the throttle does not interrupt the report compiler threads, so the  actual running time of the threads per second will typically be somewhat  higher than the throttle limit, usually by no more than 20%.  Setting this limit to 1000 disables compiler thread throttling. Only  values between 1 and 1000 are valid. Setting an invalid value will result  in the throttle being disabled and an error message being logged. 1000 is  the default setting.  ",1000
dfs.heartbeat.interval,Determines datanode heartbeat interval in seconds.,3
dfs.datanode.lifeline.interval.seconds," Sets the interval in seconds between sending DataNode Lifeline Protocol messages from the DataNode to the NameNode.  The value must be greater than the value of dfs.heartbeat.interval.  If this property is not defined, then the default behavior is to calculate the interval as 3x the value of dfs.heartbeat.interval.  Note that normal heartbeat processing may cause the DataNode to postpone sending lifeline messages if they are not required. Under normal operations with speedy heartbeat processing, it is possible that no lifeline messages will need to be sent at all.  This property has no effect if dfs.namenode.lifeline.rpc-address is not defined.  ",
dfs.namenode.handler.count,The number of Namenode RPC server threads that listen to  requests from clients.  If dfs.namenode.servicerpc-address is not configured then  Namenode RPC server threads listen to requests from all nodes.  ,10
dfs.namenode.service.handler.count,The number of Namenode RPC server threads that listen to  requests from DataNodes and from all other non-client nodes.  dfs.namenode.service.handler.count will be valid only if  dfs.namenode.servicerpc-address is configured.  ,10
dfs.namenode.lifeline.handler.ratio," A ratio applied to the value of dfs.namenode.handler.count, which then provides the number of RPC server threads the NameNode runs for handling the lifeline RPC server.  For example, if dfs.namenode.handler.count is 100, and dfs.namenode.lifeline.handler.factor is 0.10, then the NameNode starts 100 * 0.10 = 10 threads for handling the lifeline RPC server.  It is common to tune the value of dfs.namenode.handler.count as a function of the number of DataNodes in a cluster.  Using this property allows for the lifeline RPC server handler threads to be tuned automatically without needing to touch a separate property.  Lifeline message processing is lightweight, so it is expected to require many fewer threads than the main NameNode RPC server. This property is not used if dfs.namenode.lifeline.handler.count is defined, which sets an absolute thread count.  This property has no effect if dfs.namenode.lifeline.rpc-address is not defined.  ",0.10
dfs.namenode.lifeline.handler.count," Sets an absolute number of RPC server threads the NameNode runs for handling the DataNode Lifeline Protocol and HA health check requests from ZKFC.  If this property is defined, then it overrides the behavior of dfs.namenode.lifeline.handler.ratio.  By default, it is not defined.  This property has no effect if dfs.namenode.lifeline.rpc-address is not defined.  ",
dfs.namenode.safemode.threshold-pct, Specifies the percentage of blocks that should satisfy  the minimal replication requirement defined by dfs.namenode.replication.min. Values less than or equal to 0 mean not to wait for any particular percentage of blocks before exiting safemode. Values greater than 1 will make safe mode permanent.  ,0.999f
dfs.namenode.safemode.min.datanodes, Specifies the number of datanodes that must be considered alive before the name node exits safemode. Values less than or equal to 0 mean not to take the number of live datanodes into account when deciding whether to remain in safe mode during startup. Values greater than the number of datanodes in the cluster will make safe mode permanent.  ,0
dfs.namenode.safemode.extension," Determines extension of safe mode in milliseconds after the threshold level is reached.  Support multiple time unit suffix (case insensitive), as described in dfs.heartbeat.interval.  ",30000
dfs.namenode.resource.check.interval," The interval in milliseconds at which the NameNode resource checker runs. The checker calculates the number of the NameNode storage volumes whose available spaces are more than dfs.namenode.resource.du.reserved, and enters safemode if the number becomes lower than the minimum value specified by dfs.namenode.resource.checked.volumes.minimum.  ",5000
dfs.namenode.resource.du.reserved, The amount of space to reserve/require for a NameNode storage directory in bytes. The default is 100MB.  ,104857600
dfs.namenode.resource.checked.volumes, A list of local directories for the NameNode resource checker to check in addition to the local edits directories.  ,
dfs.namenode.resource.checked.volumes.minimum, The minimum number of redundant NameNode storage volumes required.  ,1
dfs.datanode.balance.bandwidthPerSec,"  Specifies the maximum amount of bandwidth that each datanode  can utilize for the balancing purpose in term of  the number of bytes per second. You can use the following  suffix (case insensitive):  k(kilo), m(mega), g(giga), t(tera), p(peta), e(exa)to specify the size  (such as 128k, 512m, 1g, etc.).  Or provide complete size in bytes (such as 134217728 for 128 MB).  ",10m
dfs.hosts,"Names a file that contains a list of hosts that are  permitted to connect to the namenode. The full pathname of the file  must be specified.  If the value is empty, all hosts are  permitted.",
dfs.hosts.exclude,"Names a file that contains a list of hosts that are  not permitted to connect to the namenode.  The full pathname of the  file must be specified.  If the value is empty, no hosts are  excluded.",
dfs.namenode.max.objects,"The maximum number of files, directories and blocks  dfs supports. A value of zero indicates no limit to the number  of objects that dfs supports.  ",0
dfs.namenode.datanode.registration.ip-hostname-check," If true (the default), then the namenode requires that a connecting datanode's address must be resolved to a hostname.  If necessary, a reverse DNS lookup is performed.  All attempts to register a datanode from an unresolvable address are rejected. It is recommended that this setting be left on to prevent accidental registration of datanodes listed by hostname in the excludes file during a DNS outage.  Only set this to false in environments where there is no infrastructure to support reverse DNS lookup.  ",true
dfs.namenode.decommission.interval,"Namenode periodicity in seconds to check if decommission or maintenance is complete. Support multiple time unit suffix(case insensitive), as described in dfs.heartbeat.interval.  ",30
dfs.namenode.decommission.blocks.per.interval,"The approximate number of blocks to process per decommission or maintenance interval, as defined in dfs.namenode.decommission.interval.  ",500000
dfs.namenode.decommission.max.concurrent.tracked.nodes, The maximum number of decommission-in-progress or entering-maintenance datanodes nodes that will be tracked at one time by the namenode. Tracking these datanode consumes additional NN memory proportional to the number of blocks on the datnode. Having a conservative limit reduces the potential impact of decommissioning or maintenance of a large number of nodes at once.    A value of 0 means no limit will be enforced.  ,100
dfs.namenode.replication.interval,The periodicity in seconds with which the namenode computes   replication work for datanodes. ,3
dfs.namenode.accesstime.precision,The access time for HDFS file is precise upto this value.    The default value is 1 hour. Setting a value of 0 disables      access times for HDFS.  ,3600000
dfs.datanode.plugins,Comma-separated list of datanode plug-ins to be activated.  ,
dfs.namenode.plugins,Comma-separated list of namenode plug-ins to be activated.  ,
dfs.namenode.block-placement-policy.default.prefer-local-node,"Controls how the default block placement policy places  the first replica of a block. When true, it will prefer the node where  the client is running.  When false, it will prefer a node in the same rack  as the client. Setting to false avoids situations where entire copies of  large files end up on a single node, thus creating hotspots.  ",true
dfs.stream-buffer-size,"The size of buffer to stream files.  The size of this buffer should probably be a multiple of hardware  page size (4096 on Intel x86), and it determines how much data is  buffered during read and write operations.",4096
dfs.bytes-per-checksum,The number of bytes per checksum.  Must not be larger than  dfs.stream-buffer-size,512
dfs.client-write-packet-size,Packet size for clients to write,65536
dfs.client.write.exclude.nodes.cache.expiry.interval.millis,"The maximum period to keep a DN in the excluded nodes list  at a client. After this period, in milliseconds, the previously excluded node(s) will  be removed automatically from the cache and will be considered good for block allocations  again. Useful to lower or raise in situations where you keep a file open for very long  periods (such as a Write-Ahead-Log (WAL) file) to make the writer tolerant to cluster maintenance  restarts. Defaults to 10 minutes.",600000
dfs.namenode.checkpoint.dir,Determines where on the local filesystem the DFS secondary   name node should store the temporary images to merge.   If this is a comma-delimited list of directories then the image is   replicated in all of the directories for redundancy.  ,file://${hadoop.tmp.dir}/dfs/namesecondary
dfs.namenode.checkpoint.edits.dir,Determines where on the local filesystem the DFS secondary   name node should store the temporary edits to merge.   If this is a comma-delimited list of directories then the edits is   replicated in all of the directories for redundancy.   Default value is same as dfs.namenode.checkpoint.dir  ,${dfs.namenode.checkpoint.dir}
dfs.namenode.checkpoint.period,The number of seconds between two periodic checkpoints.  ,3600
dfs.namenode.checkpoint.txns,"The Secondary NameNode or CheckpointNode will create a checkpoint  of the namespace every 'dfs.namenode.checkpoint.txns' transactions, regardless  of whether 'dfs.namenode.checkpoint.period' has expired.  ",1000000
dfs.namenode.checkpoint.check.period,The SecondaryNameNode and CheckpointNode will poll the NameNode  every 'dfs.namenode.checkpoint.check.period' seconds to query the number  of uncheckpointed transactions.  ,60
dfs.namenode.checkpoint.max-retries,"The SecondaryNameNode retries failed checkpointing. If the   failure occurs while loading fsimage or replaying edits, the number of  retries is limited by this variable.   ",3
dfs.namenode.num.checkpoints.retained,The number of image checkpoint files (fsimage_*) that will be retained by  the NameNode and Secondary NameNode in their storage directories. All edit  logs (stored on edits_* files) necessary to recover an up-to-date namespace from the oldest retained  checkpoint will also be retained.  ,2
dfs.namenode.num.extra.edits.retained,"The number of extra transactions which should be retained  beyond what is minimally necessary for a NN restart.  It does not translate directly to file's age, or the number of files kept,  but to the number of transactions (here ""edits"" means transactions).  One edit file may contain several transactions (edits).  During checkpoint, NameNode will identify the total number of edits to retain as extra by  checking the latest checkpoint transaction value, subtracted by the value of this property.  Then, it scans edits files to identify the older ones that don't include the computed range of  retained transactions that are to be kept around, and purges them subsequently.  The retainment can be useful for audit purposes or for an HA setup where a remote Standby Node may have  been offline for some time and need to have a longer backlog of retained  edits in order to start again.  Typically each edit is on the order of a few hundred bytes, so the default  of 1 million edits should be on the order of hundreds of MBs or low GBs.  NOTE: Fewer extra edits may be retained than value specified for this setting  if doing so would mean that more segments would be retained than the number  configured by dfs.namenode.max.extra.edits.segments.retained.  ",1000000
dfs.namenode.max.extra.edits.segments.retained,"The maximum number of extra edit log segments which should be retained  beyond what is minimally necessary for a NN restart. When used in conjunction with  dfs.namenode.num.extra.edits.retained, this configuration property serves to cap  the number of extra edits files to a reasonable value.  ",10000
dfs.namenode.delegation.key.update-interval,The update interval for master key for delegation tokens  in the namenode in milliseconds.  ,86400000
dfs.namenode.delegation.token.max-lifetime,The maximum lifetime in milliseconds for which a delegation    token is valid.  ,604800000
dfs.namenode.delegation.token.renew-interval,The renewal interval for delegation token in milliseconds.  ,86400000
dfs.datanode.failed.volumes.tolerated,The number of volumes that are allowed to  fail before a datanode stops offering service. By default  any volume failure will cause a datanode to shutdown.  ,0
dfs.image.compress,Should the dfs image be compressed?  ,false
dfs.image.compression.codec,"If the dfs image is compressed, how should they be compressed?      This has to be a codec defined in io.compression.codecs.  ",org.apache.hadoop.io.compress.DefaultCodec
dfs.image.transfer.timeout,"  Socket timeout for the HttpURLConnection instance used in the image  transfer. This is measured in milliseconds.  This timeout prevents client hangs if the connection is idle  for this configured timeout, during image transfer.  ",60000
dfs.image.transfer.bandwidthPerSec,"  Maximum bandwidth used for regular image transfers (instead of  bootstrapping the standby namenode), in bytes per second.  This can help keep normal namenode operations responsive during  checkpointing.  A default value of 0 indicates that throttling is disabled.  The maximum bandwidth used for bootstrapping standby namenode is  configured with dfs.image.transfer-bootstrap-standby.bandwidthPerSec.  ",0
dfs.image.transfer-bootstrap-standby.bandwidthPerSec,"   Maximum bandwidth used for transferring image to bootstrap standby   namenode, in bytes per second.   A default value of 0 indicates that throttling is disabled. This default   value should be used in most cases, to ensure timely HA operations.   The maximum bandwidth used for regular image transfers is configured   with dfs.image.transfer.bandwidthPerSec. ",0
dfs.image.transfer.chunksize,  Chunksize in bytes to upload the checkpoint.  Chunked streaming is used to avoid internal buffering of contents  of image file of huge size.  ,65536
dfs.namenode.support.allow.format,"Does HDFS namenode allow itself to be formatted?      You may consider setting this to false for any production      cluster, to avoid any possibility of formatting a running DFS.  ",true
dfs.datanode.max.transfer.threads,  Specifies the maximum number of threads to use for transferring data  in and out of the DN.  ,4096
dfs.datanode.scan.period.hours,"  If this is positive, the DataNode will not scan any  individual block more than once in the specified scan period.  If this is negative, the block scanner is disabled.  If this is set to zero, then the default value of 504 hours  or 3 weeks is used. Prior versions of HDFS incorrectly documented  that setting this key to zero will disable the block scanner.  ",504
dfs.block.scanner.volume.bytes.per.second,"  If this is 0, the DataNode's block scanner will be disabled.  If this  is positive, this is the number of bytes per second that the DataNode's  block scanner will try to scan from each volume.  ",1048576
dfs.datanode.readahead.bytes,"  While reading block files, if the Hadoop native libraries are available,  the datanode can use the posix_fadvise system call to explicitly  page data into the operating system buffer cache ahead of the current  reader's position. This can improve performance especially when  disks are highly contended.  This configuration specifies the number of bytes ahead of the current  read position which the datanode will attempt to read ahead. This  feature may be disabled by configuring this property to 0.  If the native libraries are not available, this configuration has no  effect.  ",4194304
dfs.datanode.drop.cache.behind.reads,"  In some workloads, the data read from HDFS is known to be significantly  large enough that it is unlikely to be useful to cache it in the  operating system buffer cache. In this case, the DataNode may be  configured to automatically purge all data from the buffer cache  after it is delivered to the client. This behavior is automatically  disabled for workloads which read only short sections of a block  (e.g HBase random-IO workloads).  This may improve performance for some workloads by freeing buffer  cache space usage for more cacheable data.  If the Hadoop native libraries are not available, this configuration  has no effect.  ",false
dfs.datanode.drop.cache.behind.writes,"  In some workloads, the data written to HDFS is known to be significantly  large enough that it is unlikely to be useful to cache it in the  operating system buffer cache. In this case, the DataNode may be  configured to automatically purge all data from the buffer cache  after it is written to disk.  This may improve performance for some workloads by freeing buffer  cache space usage for more cacheable data.  If the Hadoop native libraries are not available, this configuration  has no effect.  ",false
dfs.datanode.sync.behind.writes,"  If this configuration is enabled, the datanode will instruct the  operating system to enqueue all written data to the disk immediately  after it is written. This differs from the usual OS policy which  may wait for up to 30 seconds before triggering writeback.  This may improve performance for some workloads by smoothing the  IO profile for data written to disk.  If the Hadoop native libraries are not available, this configuration  has no effect.  ",false
dfs.client.failover.max.attempts, Expert only. The number of client failover attempts that should be made before the failover is considered failed.  ,15
dfs.client.failover.sleep.base.millis," Expert only. The time to wait, in milliseconds, between failover attempts increases exponentially as a function of the number of attempts made so far, with a random factor of +/- 50%. This option specifies the base value used in the failover calculation. The first failover will retry immediately. The 2nd failover attempt will delay at least dfs.client.failover.sleep.base.millis milliseconds. And so on.  ",500
dfs.client.failover.sleep.max.millis," Expert only. The time to wait, in milliseconds, between failover attempts increases exponentially as a function of the number of attempts made so far, with a random factor of +/- 50%. This option specifies the maximum value to wait between failovers.  Specifically, the time between two failover attempts will not exceed +/- 50% of dfs.client.failover.sleep.max.millis milliseconds.  ",15000
dfs.client.failover.connection.retries, Expert only. Indicates the number of retries a failover IPC client will make to establish a server connection.  ,0
dfs.client.failover.connection.retries.on.timeouts, Expert only. The number of retry attempts a failover IPC client will make on socket timeout when establishing a server connection.  ,0
dfs.client.datanode-restart.timeout," Expert only. The time to wait, in seconds, from reception of an datanode shutdown notification for quick restart, until declaring the datanode dead and invoking the normal recovery mechanisms. The notification is sent by a datanode when it is being shutdown using the shutdownDatanode admin command with the upgrade option.  ",30
dfs.nameservices, Comma-separated list of nameservices.  ,
dfs.nameservice.id, The ID of this nameservice. If the nameservice ID is not configured or more than one nameservice is configured for dfs.nameservices it is determined automatically by matching the local node's address with the configured address.  ,
dfs.internal.nameservices, Comma-separated list of nameservices that belong to this cluster. Datanode will report to all the nameservices in this list. By default this is set to the value of dfs.nameservices.  ,
dfs.ha.namenodes.EXAMPLENAMESERVICE," The prefix for a given nameservice, contains a comma-separated list of namenodes for a given nameservice (eg EXAMPLENAMESERVICE). Unique identifiers for each NameNode in the nameservice, delimited by commas. This will be used by DataNodes to determine all the NameNodes in the cluster. For example, if you used “mycluster” as the nameservice ID previously, and you wanted to use “nn1” and “nn2” as the individual IDs of the NameNodes, you would configure a property dfs.ha.namenodes.mycluster, and its value ""nn1,nn2"".  ",
dfs.ha.namenode.id, The ID of this namenode. If the namenode ID is not configured it is determined automatically by matching the local node's address with the configured address.  ,
dfs.ha.log-roll.period," How often, in seconds, the StandbyNode should ask the active to roll edit logs. Since the StandbyNode only reads from finalized log segments, the StandbyNode will only be as up-to-date as how often the logs are rolled. Note that failover triggers a log roll so the StandbyNode will be up to date before it becomes active.  ",120
dfs.ha.tail-edits.period," How often, in seconds, the StandbyNode should check for new finalized log segments in the shared edits log.  ",60
dfs.ha.tail-edits.rolledits.timeout,The timeout in seconds of calling rollEdits RPC on Active NN.  ,60
dfs.ha.automatic-failover.enabled, Whether automatic failover is enabled. See the HDFS High Availability documentation for details on automatic HA configuration.  ,false
dfs.client.use.datanode.hostname,Whether clients should use datanode hostnames when connecting to datanodes.  ,false
dfs.datanode.use.datanode.hostname,Whether datanodes should use datanode hostnames when connecting to other datanodes for data transfer.  ,false
dfs.client.local.interfaces,"A comma separated list of network interface names to use for data transfer between the client and datanodes. When creating a connection to read from or write to a datanode, the client chooses one of the specified interfaces at random and binds its socket to the IP of that interface. Individual names may be specified as either an interface name (eg ""eth0""), a subinterface name (eg ""eth0:0""), or an IP address (which may be specified using CIDR notation to match a range of IPs).  ",
dfs.datanode.shared.file.descriptor.paths," A comma-separated list of paths to use when creating file descriptors that will be shared between the DataNode and the DFSClient.  Typically we use /dev/shm, so that the file descriptors will not be written to disk. Systems that don't have /dev/shm will fall back to /tmp by default.  ","/dev/shm,/tmp"
dfs.short.circuit.shared.memory.watcher.interrupt.check.ms, The length of time in milliseconds that the short-circuit shared memory watcher will go between checking for java interruptions sent from other threads.  This is provided mainly for unit tests.  ,60000
dfs.namenode.kerberos.principal, The NameNode service principal. This is typically set to nn/_HOST@REALM.TLD. Each NameNode will substitute _HOST with its own fully qualified hostname at startup. The _HOST placeholder allows using the same configuration setting on both NameNodes in an HA setup.  ,
dfs.namenode.keytab.file, The keytab file used by each NameNode daemon to login as its service principal. The principal name is configured with dfs.namenode.kerberos.principal.  ,
dfs.datanode.kerberos.principal, The DataNode service principal. This is typically set to dn/_HOST@REALM.TLD. Each DataNode will substitute _HOST with its own fully qualified hostname at startup. The _HOST placeholder allows using the same configuration setting on all DataNodes.  ,
dfs.datanode.keytab.file, The keytab file used by each DataNode daemon to login as its service principal. The principal name is configured with dfs.datanode.kerberos.principal.  ,
dfs.journalnode.kerberos.principal, The JournalNode service principal. This is typically set to jn/_HOST@REALM.TLD. Each JournalNode will substitute _HOST with its own fully qualified hostname at startup. The _HOST placeholder allows using the same configuration setting on all JournalNodes.  ,
dfs.journalnode.keytab.file, The keytab file used by each JournalNode daemon to login as its service principal. The principal name is configured with dfs.journalnode.kerberos.principal.  ,
dfs.namenode.kerberos.internal.spnego.principal," The server principal used by the NameNode for web UI SPNEGO authentication when Kerberos security is enabled. This is typically set to HTTP/_HOST@REALM.TLD The SPNEGO server principal begins with the prefix HTTP/ by convention. If the value is '*', the web server will attempt to login with every principal specified in the keytab file dfs.web.authentication.kerberos.keytab.",${dfs.web.authentication.kerberos.principal}
dfs.journalnode.kerberos.internal.spnego.principal," The server principal used by the JournalNode HTTP Server for SPNEGO authentication when Kerberos security is enabled. This is typically set to HTTP/_HOST@REALM.TLD. The SPNEGO server principal begins with the prefix HTTP/ by convention. If the value is '*', the web server will attempt to login with every principal specified in the keytab file dfs.web.authentication.kerberos.keytab. For most deployments this can be set to ${dfs.web.authentication.kerberos.principal} i.e use the value of dfs.web.authentication.kerberos.principal.  ",
dfs.secondary.namenode.kerberos.internal.spnego.principal," The server principal used by the Secondary NameNode for web UI SPNEGO authentication when Kerberos security is enabled. Like all other Secondary NameNode settings, it is ignored in an HA setup. If the value is '*', the web server will attempt to login with every principal specified in the keytab file dfs.web.authentication.kerberos.keytab.  ",${dfs.web.authentication.kerberos.principal}
dfs.web.authentication.kerberos.principal, The server principal used by the NameNode for WebHDFS SPNEGO authentication. Required when WebHDFS and security are enabled. In most secure clusters this setting is also used to specify the values for dfs.namenode.kerberos.internal.spnego.principal and dfs.journalnode.kerberos.internal.spnego.principal.  ,
dfs.web.authentication.kerberos.keytab, The keytab file for the principal corresponding to dfs.web.authentication.kerberos.principal.  ,
dfs.namenode.kerberos.principal.pattern, A client-side RegEx that can be configured to control allowed realms to authenticate with (useful in cross-realm env.)  ,*
dfs.namenode.avoid.read.stale.datanode," Indicate whether or not to avoid reading from ""stale"" datanodes whose heartbeat messages have not been received by the namenode  for more than a specified time interval. Stale datanodes will be moved to the end of the node list returned for reading. See dfs.namenode.avoid.write.stale.datanode for a similar setting for writes.  ",false
dfs.namenode.avoid.write.stale.datanode," Indicate whether or not to avoid writing to ""stale"" datanodes whose  heartbeat messages have not been received by the namenode  for more than a specified time interval. Writes will avoid using  stale datanodes unless more than a configured ratio  (dfs.namenode.write.stale.datanode.ratio) of datanodes are marked as  stale. See dfs.namenode.avoid.read.stale.datanode for a similar setting for reads.  ",false
dfs.namenode.stale.datanode.interval," Default time interval in milliseconds for marking a datanode as ""stale"", i.e., if the namenode has not received heartbeat msg from a datanode for more than this time interval, the datanode will be marked and treated  as ""stale"" by default. The stale interval cannot be too small since  otherwise this may cause too frequent change of stale states.  We thus set a minimum stale interval value (the default value is 3 times  of heartbeat interval) and guarantee that the stale interval cannot be less than the minimum value. A stale data node is avoided during lease/block recovery. It can be conditionally avoided for reads (see dfs.namenode.avoid.read.stale.datanode) and for writes (see dfs.namenode.avoid.write.stale.datanode).  ",30000
dfs.namenode.write.stale.datanode.ratio," When the ratio of number stale datanodes to total datanodes marked is greater than this ratio, stop avoiding writing to stale nodes so as to prevent causing hotspots.  ",0.5f
dfs.namenode.invalidate.work.pct.per.iteration," *Note*: Advanced property. Change with caution. This determines the percentage amount of block invalidations (deletes) to do over a single DN heartbeat deletion command. The final deletion count is determined by applying this percentage to the number of live nodes in the system. The resultant number is the number of blocks from the deletion list chosen for proper invalidation over a single heartbeat of a single DN. Value should be a positive, non-zero percentage in float notation (X.Yf), with 1.0f meaning 100%.  ",0.32f
dfs.namenode.replication.work.multiplier.per.iteration," *Note*: Advanced property. Change with caution. This determines the total amount of block transfers to begin in parallel at a DN, for replication, when such a command list is being sent over a DN heartbeat by the NN. The actual number is obtained by multiplying this multiplier with the total number of live nodes in the cluster. The result number is the number of blocks to begin transfers immediately for, per DN heartbeat. This number can be any positive, non-zero integer.  ",2
nfs.server.port,   Specify the port number used by Hadoop NFS.  ,2049
nfs.mountd.port,   Specify the port number used by Hadoop mount daemon.  ,4242
nfs.dump.dir," This directory is used to temporarily save out-of-order writes before writing to HDFS. For each file, the out-of-order writes are dumped after they are accumulated to exceed certain threshold (e.g., 1MB) in memory.  One needs to make sure the directory has enough space.  ",/tmp/.hdfs-nfs
nfs.rtmax,"This is the maximum size in bytes of a READ request supported by the NFS gateway. If you change this, make sure you also update the nfs mount's rsize(add rsize= # of bytes to the  mount directive).  ",1048576
nfs.wtmax,"This is the maximum size in bytes of a WRITE request supported by the NFS gateway. If you change this, make sure you also update the nfs mount's wsize(add wsize= # of bytes to the  mount directive).  ",1048576
nfs.keytab.file, *Note*: Advanced property. Change with caution. This is the path to the keytab file for the hdfs-nfs gateway. This is required when the cluster is kerberized.  ,
nfs.kerberos.principal, *Note*: Advanced property. Change with caution. This is the name of the kerberos principal. This is required when the cluster is kerberized.It must be of this format: nfs-gateway-user/nfs-gateway-host@kerberos-realm  ,
nfs.allow.insecure.ports," When set to false, client connections originating from unprivileged ports (those above 1023) will be rejected. This is to ensure that clients connecting to this NFS Gateway must have had root privilege on the machine where they're connecting from.  ",true
dfs.webhdfs.enabled, Enable WebHDFS (REST API) in Namenodes and Datanodes.  ,true
hadoop.fuse.connection.timeout, The minimum number of seconds that we'll cache libhdfs connection objects in fuse_dfs. Lower values will result in lower memory consumption; higher values may speed up access by avoiding the overhead of creating new connection objects.  ,300
hadoop.fuse.timer.period, The number of seconds between cache expiry checks in fuse_dfs. Lower values will result in fuse_dfs noticing changes to Kerberos ticket caches more quickly.  ,5
dfs.namenode.metrics.logger.period.seconds, This setting controls how frequently the NameNode logs its metrics. The logging configuration must also define one or more appenders for NameNodeMetricsLog for the metrics to be logged. NameNode metrics logging is disabled if this value is set to zero or less than zero.  ,600
dfs.datanode.metrics.logger.period.seconds, This setting controls how frequently the DataNode logs its metrics. The logging configuration must also define one or more appenders for DataNodeMetricsLog for the metrics to be logged. DataNode metrics logging is disabled if this value is set to zero or less than zero.  ,600
dfs.metrics.percentiles.intervals," Comma-delimited set of integers denoting the desired rollover intervals  (in seconds) for percentile latency metrics on the Namenode and Datanode. By default, percentile latency metrics are disabled.  ",
dfs.datanode.peer.stats.enabled, A switch to turn on/off tracking DataNode peer statistics.  ,false
dfs.datanode.outliers.report.interval, This setting controls how frequently DataNodes will report their peer latencies to the NameNode via heartbeats.  This setting supports multiple time unit suffixes as described in dfs.heartbeat.interval. If no suffix is specified then milliseconds is assumed. It is ignored if dfs.datanode.peer.stats.enabled is false.  ,1800000
dfs.datanode.fileio.profiling.sampling.percentage, This setting controls the percentage of file I/O events which will be profiled for DataNode disk statistics. The default value of 0 disables disk statistics. Set to an integer value between 1 and 100 to enable disk statistics.  ,0
hadoop.user.group.metrics.percentiles.intervals," A comma-separated list of the granularity in seconds for the metrics which describe the 50/75/90/95/99th percentile latency for group resolution in milliseconds. By default, percentile latency metrics are disabled.  ",
dfs.encrypt.data.transfer," Whether or not actual block data that is read/written from/to HDFS should be encrypted on the wire. This only needs to be set on the NN and DNs, clients will deduce this automatically. It is possible to override this setting  per connection by specifying custom logic via dfs.trustedchannel.resolver.class.   ",false
dfs.encrypt.data.transfer.algorithm," This value may be set to either ""3des"" or ""rc4"". If nothing is set, then the configured JCE default on the system is used (usually 3DES.) It is widely believed that 3DES is more cryptographically secure, but RC4 is substantially faster.  Note that if AES is supported by both the client and server then this  encryption algorithm will only be used to initially transfer keys for AES. (See dfs.encrypt.data.transfer.cipher.suites.)  ",
dfs.encrypt.data.transfer.cipher.suites," This value may be either undefined or AES/CTR/NoPadding.  If defined, then dfs.encrypt.data.transfer uses the specified cipher suite for data encryption.  If not defined, then only the algorithm specified in dfs.encrypt.data.transfer.algorithm is used.  By default, the property is not defined.  ",
dfs.encrypt.data.transfer.cipher.key.bitlength," The key bitlength negotiated by dfsclient and datanode for encryption. This value may be set to either 128, 192 or 256.  ",128
dfs.trustedchannel.resolver.class,"   TrustedChannelResolver is used to determine whether a channel    is trusted for plain data transfer. The TrustedChannelResolver is   invoked on both client and server side. If the resolver indicates    that the channel is trusted, then the data transfer will not be    encrypted even if dfs.encrypt.data.transfer is set to true. The   default implementation returns false indicating that the channel    is not trusted.  ",
dfs.data.transfer.protection," A comma-separated list of SASL protection values used for secured connections to the DataNode when reading or writing block data.  Possible values are authentication, integrity and privacy.  authentication means authentication only and no integrity or privacy; integrity implies authentication and integrity are enabled; and privacy implies all of authentication, integrity and privacy are enabled.  If dfs.encrypt.data.transfer is set to true, then it supersedes the setting for dfs.data.transfer.protection and enforces that all connections must use a specialized encrypted SASL handshake.  This property is ignored for connections to a DataNode listening on a privileged port.  In this case, it is assumed that the use of a privileged port establishes sufficient trust.  ",
dfs.data.transfer.saslproperties.resolver.class," SaslPropertiesResolver used to resolve the QOP used for a connection to the DataNode when reading or writing block data. If not specified, the value of hadoop.security.saslproperties.resolver.class is used as the default value.  ",
dfs.datanode.hdfs-blocks-metadata.enabled, Boolean which enables backend datanode-side support for the experimental DistributedFileSystem#getFileVBlockStorageLocations API.  ,false
dfs.client.file-block-storage-locations.num-threads, Number of threads used for making parallel RPCs in DistributedFileSystem#getFileBlockStorageLocations().  ,10
dfs.client.file-block-storage-locations.timeout.millis, Timeout (in milliseconds) for the parallel RPCs made in DistributedFileSystem#getFileBlockStorageLocations().  ,1000
dfs.journalnode.rpc-address, The JournalNode RPC server address and port.  ,0.0.0.0:8485
dfs.journalnode.rpc-bind-host," The actual address the RPC server will bind to. If this optional address is set, it overrides only the hostname portion of dfs.journalnode.rpc-address. This is useful for making the JournalNode listen on all interfaces by setting it to 0.0.0.0.  ",
dfs.journalnode.http-address, The address and port the JournalNode HTTP server listens on. If the port is 0 then the server will start on a free port.  ,0.0.0.0:8480
dfs.journalnode.http-bind-host," The actual address the HTTP server will bind to. If this optional address is set, it overrides only the hostname portion of dfs.journalnode.http-address. This is useful for making the JournalNode HTTP server listen on allinterfaces by setting it to 0.0.0.0.  ",
dfs.journalnode.https-address, The address and port the JournalNode HTTPS server listens on. If the port is 0 then the server will start on a free port.  ,0.0.0.0:8481
dfs.journalnode.https-bind-host," The actual address the HTTP server will bind to. If this optional address is set, it overrides only the hostname portion of dfs.journalnode.https-address. This is useful for making the JournalNode HTTP server listen on all interfaces by setting it to 0.0.0.0.  ",
dfs.namenode.audit.loggers," List of classes implementing audit loggers that will receive audit events. These should be implementations of org.apache.hadoop.hdfs.server.namenode.AuditLogger. The special value ""default"" can be used to reference the default audit logger, which uses the configured log system. Installing custom audit loggers may affect the performance and stability of the NameNode. Refer to the custom logger's documentation for more details.  ",default
dfs.datanode.available-space-volume-choosing-policy.balanced-space-threshold," Only used when the dfs.datanode.fsdataset.volume.choosing.policy is set to org.apache.hadoop.hdfs.server.datanode.fsdataset.AvailableSpaceVolumeChoosingPolicy. This setting controls how much DN volumes are allowed to differ in terms of bytes of free disk space before they are considered imbalanced. If the free space of all the volumes are within this range of each other, the volumes will be considered balanced and block assignments will be done on a pure round robin basis.  ",10737418240
dfs.datanode.available-space-volume-choosing-policy.balanced-space-preference-fraction," Only used when the dfs.datanode.fsdataset.volume.choosing.policy is set to org.apache.hadoop.hdfs.server.datanode.fsdataset.AvailableSpaceVolumeChoosingPolicy. This setting controls what percentage of new block allocations will be sent to volumes with more available disk space than others. This setting should be in the range 0.0 - 1.0, though in practice 0.5 - 1.0, since there should be no reason to prefer that volumes with less available disk space receive more block allocations.  ",0.75f
dfs.namenode.edits.noeditlogchannelflush," Specifies whether to flush edit log file channel. When set, expensive FileChannel#force calls are skipped and synchronous disk writes are enabled instead by opening the edit log file with RandomAccessFile(""rws"") flags. This can significantly improve the performance of edit log writes on the Windows platform. Note that the behavior of the ""rws"" flags is platform and hardware specific and might not provide the same level of guarantees as FileChannel#force. For example, the write will skip the disk-cache on SAS and SCSI devices while it might not on SATA devices. This is an expert level setting, change with caution.  ",false
dfs.client.cache.drop.behind.writes," Just like dfs.datanode.drop.cache.behind.writes, this setting causes the page cache to be dropped behind HDFS writes, potentially freeing up more memory for other uses.  Unlike dfs.datanode.drop.cache.behind.writes, this is a client-side setting rather than a setting for the entire datanode. If present, this setting will override the DataNode default. If the native libraries are not available to the DataNode, this configuration has no effect.  ",
dfs.client.cache.drop.behind.reads," Just like dfs.datanode.drop.cache.behind.reads, this setting causes the page cache to be dropped behind HDFS reads, potentially freeing up more memory for other uses.  Unlike dfs.datanode.drop.cache.behind.reads, this is a client-side setting rather than a setting for the entire datanode.  If present, this setting will override the DataNode default. If the native libraries are not available to the DataNode, this configuration has no effect.  ",
dfs.client.cache.readahead," When using remote reads, this setting causes the datanode to read ahead in the block file using posix_fadvise, potentially decreasing I/O wait times.  Unlike dfs.datanode.readahead.bytes, this is a client-side setting rather than a setting for the entire datanode.  If present, this setting will override the DataNode default. When using local reads, this setting determines how much readahead we do in BlockReaderLocal. If the native libraries are not available to the DataNode, this configuration has no effect.  ",
dfs.client.server-defaults.validity.period.ms, The amount of milliseconds after which cached server defaults are updated. By default this parameter is set to 1 hour.  ,3600000
dfs.namenode.enable.retrycache," This enables the retry cache on the namenode. Namenode tracks for non-idempotent requests the corresponding response. If a client retries the request, the response from the retry cache is sent. Such operations are tagged with annotation @AtMostOnce in namenode protocols. It is recommended that this flag be set to true. Setting it to false, will result in clients getting failure responses to retried request. This flag must  be enabled in HA setup for transparent fail-overs. The entries in the cache have expiration time configurable using dfs.namenode.retrycache.expirytime.millis.  ",true
dfs.namenode.retrycache.expirytime.millis, The time for which retry cache entries are retained.  ,600000
dfs.namenode.retrycache.heap.percent," This parameter configures the heap size allocated for retry cache (excluding the response cached). This corresponds to approximately 4096 entries for every 64MB of namenode process java heap size. Assuming retry cache entry expiration time (configured using dfs.namenode.retrycache.expirytime.millis) of 10 minutes, this enables retry cache to support 7 operations per second sustained for 10 minutes. As the heap size is increased, the operation rate linearly increases.  ",0.03f
dfs.client.mmap.enabled," If this is set to false, the client won't attempt to perform memory-mapped reads.  ",true
dfs.client.mmap.cache.size," When zero-copy reads are used, the DFSClient keeps a cache of recently used memory mapped regions.  This parameter controls the maximum number of entries that we will keep in that cache. The larger this number is, the more file descriptors we will potentially use for memory-mapped files.  mmaped files also use virtual address space. You may need to increase your ulimit virtual address space limits before increasing the client mmap cache size. Note that you can still do zero-copy reads when this size is set to 0.  ",256
dfs.client.mmap.cache.timeout.ms," The minimum length of time that we will keep an mmap entry in the cache between uses.  If an entry is in the cache longer than this, and nobody uses it, it will be removed by a background thread.  ",3600000
dfs.client.mmap.retry.timeout.ms, The minimum amount of time that we will wait before retrying a failed mmap operation.  ,300000
dfs.client.short.circuit.replica.stale.threshold.ms," The maximum amount of time that we will consider a short-circuit replica to be valid, if there is no communication from the DataNode.  After this time has elapsed, we will re-fetch the short-circuit replica even if it is in the cache.  ",1800000
dfs.namenode.path.based.cache.block.map.allocation.percent, The percentage of the Java heap which we will allocate to the cached blocks map.  The cached blocks map is a hash map which uses chained hashing. Smaller maps may be accessed more slowly if the number of cached blocks is large; larger maps will consume more memory.  ,0.25
dfs.datanode.max.locked.memory," The amount of memory in bytes to use for caching of block replicas in memory on the datanode. The datanode's maximum locked memory soft ulimit (RLIMIT_MEMLOCK) must be set to at least this value, else the datanode will abort on startup. By default, this parameter is set to 0, which disables in-memory caching. If the native libraries are not available to the DataNode, this configuration has no effect.  ",0
dfs.namenode.list.cache.directives.num.responses, This value controls the number of cache directives that the NameNode will send over the wire in response to a listDirectives RPC.  ,100
dfs.namenode.list.cache.pools.num.responses, This value controls the number of cache pools that the NameNode will send over the wire in response to a listPools RPC.  ,100
dfs.namenode.path.based.cache.refresh.interval.ms," The amount of milliseconds between subsequent path cache rescans.  Path cache rescans are when we calculate which blocks should be cached, and on what datanodes. By default, this parameter is set to 30 seconds.  ",30000
dfs.namenode.path.based.cache.retry.interval.ms," When the NameNode needs to uncache something that is cached, or cache something that is not cached, it must direct the DataNodes to do so by sending a DNA_CACHE or DNA_UNCACHE command in response to a DataNode heartbeat.  This parameter controls how frequently the NameNode will resend these commands.  ",30000
dfs.datanode.fsdatasetcache.max.threads.per.volume, The maximum number of threads per volume to use for caching new data on the datanode. These threads consume both I/O and CPU. This can affect normal datanode operations.  ,4
dfs.cachereport.intervalMsec," Determines cache reporting interval in milliseconds.  After this amount of time, the DataNode sends a full report of its cache state to the NameNode. The NameNode uses the cache report to update its map of cached blocks to DataNode locations. This configuration has no effect if in-memory caching has been disabled by setting dfs.datanode.max.locked.memory to 0 (which is the default). If the native libraries are not available to the DataNode, this configuration has no effect.  ",10000
dfs.namenode.edit.log.autoroll.multiplier.threshold," Determines when an active namenode will roll its own edit log. The actual threshold (in number of edits) is determined by multiplying this value by dfs.namenode.checkpoint.txns. This prevents extremely large edit files from accumulating on the active namenode, which can cause timeouts during namenode startup and pose an administrative hassle. This behavior is intended as a failsafe for when the standby or secondary namenode fail to roll the edit log by the normal checkpoint threshold.  ",2.0
dfs.namenode.edit.log.autoroll.check.interval.ms," How often an active namenode will check if it needs to roll its edit log, in milliseconds.  ",300000
dfs.webhdfs.user.provider.user.pattern," Valid pattern for user and group names for webhdfs, it must be a valid java regex.  ",^[A-Za-z_][A-Za-z0-9._-]*[$]?$
dfs.webhdfs.acl.provider.permission.pattern," Valid pattern for user and group names in webhdfs acl operations, it must be a valid java regex.  ","^(default:)?(user|group|mask|other):[[A-Za-z_][A-Za-z0-9._-]]*:([rwx-]{3})?(,(default:)?(user|group|mask|other):[[A-Za-z_][A-Za-z0-9._-]]*:([rwx-]{3})?)*$"
dfs.webhdfs.socket.connect-timeout," Socket timeout for connecting to WebHDFS servers. This prevents a WebHDFS client from hanging if the server hostname is misconfigured, or the server does not response before the timeout expires. Value is followed by a unit specifier: ns, us, ms, s, m, h, d for nanoseconds, microseconds, milliseconds, seconds, minutes, hours, days respectively. Values should provide units, but milliseconds are assumed.  ",60s
dfs.webhdfs.socket.read-timeout," Socket timeout for reading data from WebHDFS servers. This prevents a WebHDFS client from hanging if the server stops sending data. Value is followed by a unit specifier: ns, us, ms, s, m, h, d for nanoseconds, microseconds, milliseconds, seconds, minutes, hours, days respectively. Values should provide units, but milliseconds are assumed.  ",60s
dfs.client.context," The name of the DFSClient context that we should use.  Clients that share a context share a socket cache and short-circuit cache, among other things. You should only change this if you don't want to share with another set of threads.  ",default
dfs.client.read.shortcircuit, This configuration parameter turns on short-circuit local reads.  ,false
dfs.client.socket.send.buffer.size," Socket send buffer size for a write pipeline in DFSClient side. This may affect TCP connection throughput. If it is set to zero or negative value, no buffer size will be set explicitly, thus enable tcp auto-tuning on some system. The default value is 0.  ",0
dfs.domain.socket.path," Optional.  This is a path to a UNIX domain socket that will be used for communication between the DataNode and local HDFS clients. If the string ""_PORT"" is present in this path, it will be replaced by the TCP port of the DataNode.  ",
dfs.client.read.shortcircuit.skip.checksum," If this configuration parameter is set, short-circuit local reads will skip checksums. This is normally not recommended, but it may be useful for special setups. You might consider using this if you are doing your own checksumming outside of HDFS.  ",false
dfs.client.read.shortcircuit.streams.cache.size," The DFSClient maintains a cache of recently opened file descriptors. This parameter controls the maximum number of file descriptors in the cache. Setting this higher will use more file descriptors, but potentially provide better performance on workloads involving lots of seeks.  ",256
dfs.client.read.shortcircuit.streams.cache.expiry.ms, This controls the minimum amount of time file descriptors need to sit in the client cache context before they can be closed for being inactive for too long.  ,300000
dfs.datanode.shared.file.descriptor.paths, Comma separated paths to the directory on which shared memory segments are created. The client and the DataNode exchange information via this shared memory segment. It tries paths in order until creation of shared memory segment succeeds.  ,"/dev/shm,/tmp"
dfs.namenode.audit.log.debug.cmdlist, A comma separated list of NameNode commands that are written to the HDFS namenode audit log only if the audit log level is debug.  ,
dfs.client.use.legacy.blockreader.local, Legacy short-circuit reader implementation based on HDFS-2246 is used if this configuration parameter is true. This is for the platforms other than Linux where the new implementation based on HDFS-347 is not available.  ,false
dfs.block.local-path-access.user, Comma separated list of the users allowed to open block files on legacy short-circuit local read.  ,
dfs.client.domain.socket.data.traffic, This control whether we will try to pass normal data traffic over UNIX domain socket rather than over TCP socket on node-local data transfer. This is currently experimental and turned off by default.  ,false
dfs.namenode.reject-unresolved-dn-topology-mapping," If the value is set to true, then namenode will reject datanode  registration if the topology mapping for a datanode is not resolved and  NULL is returned (script defined by net.topology.script.file.name fails  to execute). Otherwise, datanode will be registered and the default rack  will be assigned as the topology path. Topology paths are important for  data resiliency, since they define fault domains. Thus it may be unwanted  behavior to allow datanode registration with the default rack if the  resolving topology failed.  ",false
dfs.client.slow.io.warning.threshold.ms,"The threshold in milliseconds at which we will log a slow io warning in a dfsclient. By default, this parameter is set to 30000 milliseconds (30 seconds).  ",30000
dfs.datanode.slow.io.warning.threshold.ms,"The threshold in milliseconds at which we will log a slow io warning in a datanode. By default, this parameter is set to 300 milliseconds.  ",300
dfs.namenode.xattrs.enabled, Whether support for extended attributes is enabled on the NameNode.  ,true
dfs.namenode.fs-limits.max-xattrs-per-inode, Maximum number of extended attributes per inode.  ,32
dfs.namenode.fs-limits.max-xattr-size," The maximum combined size of the name and value of an extended attribute in bytes. It should be larger than 0, and less than or equal to maximum size hard limit which is 32768.  ",16384
dfs.namenode.lease-recheck-interval-ms,During the release of lease a lock is hold that make any operations on the namenode stuck. In order to not block them during a too long duration we stop releasing lease after this max lock limit.  ,2000
dfs.namenode.max-lock-hold-to-release-lease-ms,During the release of lease a lock is hold that make any operations on the namenode stuck. In order to not block them during a too long duration we stop releasing lease after this max lock limit.  ,25
dfs.namenode.write-lock-reporting-threshold-ms,"When a write lock is held on the namenode for a long time, this will be logged as the lock is released. This sets how long the lock must be held for logging to occur.  ",5000
dfs.namenode.read-lock-reporting-threshold-ms,"When a read lock is held on the namenode for a long time, this will be logged as the lock is released. This sets how long the lock must be held for logging to occur.  ",5000
dfs.namenode.lock.detailed-metrics.enabled,"If true, the namenode will keep track of how long various operations hold the Namesystem lock for and emit this as metrics. These metrics have names of the form FSN(Read|Write)LockNanosOperationName, where OperationName denotes the name of the operation that initiated the lock hold (this will be OTHER for certain uncategorized operations) and they export the hold time values in nanoseconds.  ",false
dfs.namenode.fslock.fair,"If this is true, the FS Namesystem lock will be used in Fair mode, which will help to prevent writer threads from being starved, but can provide lower lock throughput. See java.util.concurrent.locks.ReentrantReadWriteLock for more information on fair/non-fair locks.  ",true
dfs.namenode.startup.delay.block.deletion.sec,"The delay in seconds at which we will pause the blocks deletion after Namenode startup. By default it's disabled. In the case a directory has large number of directories and files are deleted, suggested delay is one hour to give the administrator enough time to notice large number of pending deletion blocks and take corrective action.  ",0
dfs.namenode.list.encryption.zones.num.responses,"When listing encryption zones, the maximum number of zones that will be returned in a batch. Fetching the list incrementally in batches improves namenode performance.  ",100
dfs.namenode.list.openfiles.num.responses,"   When listing open files, the maximum number of open files that will be   returned in a single batch. Fetching the list incrementally in batches   improves namenode performance. ",1000
dfs.namenode.edekcacheloader.interval.ms,"When KeyProvider is configured, the interval time of warming up edek cache on NN starts up / becomes active. All edeks will be loaded from KMS into provider cache. The edek cache loader will try to warm up the cache until succeed or NN leaves active state.  ",1000
dfs.namenode.edekcacheloader.initial.delay.ms,"When KeyProvider is configured, the time delayed until the first attempt to warm up edek cache on NN start up / become active.  ",3000
dfs.namenode.inotify.max.events.per.rpc,Maximum number of events that will be sent to an inotify client in a single RPC response. The default value attempts to amortize away the overhead for this RPC while avoiding huge memory requirements for the client and NameNode (1000 events should consume no more than 1 MB.)  ,1000
dfs.user.home.dir.prefix,The directory to prepend to user name to get the user's home direcotry.  ,/user
dfs.datanode.cache.revocation.timeout.ms,"When the DFSClient reads from a block file which the DataNode is caching, the DFSClient can skip verifying checksums.  The DataNode will keep the block file in cache until the client is done.  If the client takes an unusually long time, though, the DataNode may need to evict the block file from the cache anyway.  This value controls how long the DataNode will wait for the client to release a replica that it is reading without checksums.  ",900000
dfs.datanode.cache.revocation.polling.ms,How often the DataNode should poll to see if the clients have stopped using a replica that the DataNode wants to uncache.  ,500
dfs.datanode.block.id.layout.upgrade.threads,The number of threads to use when creating hard links from current to previous blocks during upgrade of a DataNode to block ID-based block layout (see HDFS-6482 for details on the layout).,12
dfs.storage.policy.enabled, Allow users to change the storage policy on files and directories.  ,true
dfs.namenode.legacy-oiv-image.dir,"Determines where to save the namespace in the old fsimage format during checkpointing by standby NameNode or SecondaryNameNode. Users can dump the contents of the old format fsimage by oiv_legacy command. If the value is not specified, old format fsimage will not be saved in checkpoint.  ",
dfs.namenode.top.enabled,Enable nntop: reporting top users on namenode  ,true
dfs.namenode.top.window.num.buckets,Number of buckets in the rolling window implementation of nntop  ,10
dfs.namenode.top.num.users,Number of top users returned by the top tool  ,10
dfs.namenode.top.windows.minutes,comma separated list of nntop reporting periods in minutes  ,"1,5,25"
dfs.webhdfs.ugi.expire.after.access,"How long in milliseconds after the last access   the cached UGI will expire. With 0, never expire. ",600000
dfs.namenode.blocks.per.postponedblocks.rescan,Number of blocks to rescan for each iteration of postponedMisreplicatedBlocks.  ,10000
dfs.datanode.block-pinning.enabled,Whether pin blocks on favored DataNode.,false
dfs.client.block.write.locateFollowingBlock.initial.delay.ms,"The initial delay (unit is ms) for locateFollowingBlock, the delay time will increase exponentially(double) for each retry.  ",400
dfs.ha.zkfc.nn.http.timeout.ms," The HTTP connection and read timeout value (unit is ms ) when DFS ZKFC tries to get local NN thread dump after local NN becomes SERVICE_NOT_RESPONDING or SERVICE_UNHEALTHY. If it is set to zero, DFS ZKFC won't get local NN thread dump.  ",20000
dfs.namenode.quota.init-threads," The number of concurrent threads to be used in quota initialization. The speed of quota initialization also affects the namenode fail-over latency. If the size of name space is big, try increasing this.  ",4
dfs.datanode.transfer.socket.send.buffer.size," Socket send buffer size for DataXceiver (mirroring packets to downstream in pipeline). This may affect TCP connection throughput. If it is set to zero or negative value, no buffer size will be set explicitly, thus enable tcp auto-tuning on some system. The default value is 0.  ",0
dfs.datanode.transfer.socket.recv.buffer.size," Socket receive buffer size for DataXceiver (receiving packets from client during block writing). This may affect TCP connection throughput. If it is set to zero or negative value, no buffer size will be set explicitly, thus enable tcp auto-tuning on some system. The default value is 0.  ",0
dfs.namenode.upgrade.domain.factor," This is valid only when block placement policy is set to BlockPlacementPolicyWithUpgradeDomain. It defines the number of unique upgrade domains any block's replicas should have. When the number of replicas is less or equal to this value, the policy ensures each replica has an unique upgrade domain. When the number of replicas is greater than this value, the policy ensures the number of unique domains is at least this value.  ",${dfs.replication}
dfs.ha.zkfc.port, RPC port for Zookeeper Failover Controller.  ,8019
dfs.datanode.bp-ready.timeout, The maximum wait time for datanode to be ready before failing the received request. Setting this to 0 fails requests right away if the datanode is not yet registered with the namenode. This wait time reduces initial request failures after datanode restart.  ,20
dfs.datanode.cached-dfsused.check.interval.ms," The interval check time of loading DU_CACHE_FILE in each volume. When the cluster doing the rolling upgrade operations, it will usually lead dfsUsed cache file of each volume expired and redo the du operations in datanode and that makes datanode start slowly. Adjust this property can make cache file be available for the time as you want.  ",600000
dfs.webhdfs.rest-csrf.enabled," If true, then enables WebHDFS protection against cross-site request forgery (CSRF).  The WebHDFS client also uses this property to determine whether or not it needs to send the custom CSRF prevention header in its HTTP requests.  ",false
dfs.webhdfs.rest-csrf.custom-header, The name of a custom header that HTTP requests must send when protection against cross-site request forgery (CSRF) is enabled for WebHDFS by setting dfs.webhdfs.rest-csrf.enabled to true.  The WebHDFS client also uses this property to determine whether or not it needs to send the custom CSRF prevention header in its HTTP requests.  ,X-XSRF-HEADER
dfs.webhdfs.rest-csrf.methods-to-ignore, A comma-separated list of HTTP methods that do not require HTTP requests to include a custom header when protection against cross-site request forgery (CSRF) is enabled for WebHDFS by setting dfs.webhdfs.rest-csrf.enabled to true.  The WebHDFS client also uses this property to determine whether or not it needs to send the custom CSRF prevention header in its HTTP requests.  ,"GET,OPTIONS,HEAD,TRACE"
dfs.webhdfs.rest-csrf.browser-useragents-regex," A comma-separated list of regular expressions used to match against an HTTP request's User-Agent header when protection against cross-site request forgery (CSRF) is enabled for WebHDFS by setting dfs.webhdfs.reset-csrf.enabled to true.  If the incoming User-Agent matches any of these regular expressions, then the request is considered to be sent by a browser, and therefore CSRF prevention is enforced.  If the request's User-Agent does not match any of these regular expressions, then the request is considered to be sent by something other than a browser, such as scripted automation.  In this case, CSRF is not a potential attack vector, so the prevention is not enforced.  This helps achieve backwards-compatibility with existing automation that has not been updated to send the CSRF prevention header.  ","^Mozilla.*,^Opera.*"
dfs.xframe.enabled,"   If true, then enables protection against clickjacking by returning   X_FRAME_OPTIONS header value set to SAMEORIGIN.   Clickjacking protection prevents an attacker from using transparent or   opaque layers to trick a user into clicking on a button   or link on another page. ",true
dfs.xframe.value,"   This configration value allows user to specify the value for the   X-FRAME-OPTIONS. The possible values for this field are   DENY, SAMEORIGIN and ALLOW-FROM. Any other value will throw an   exception when namenode and datanodes are starting up. ",SAMEORIGIN
dfs.http.client.retry.policy.enabled," If ""true"", enable the retry policy of WebHDFS client. If ""false"", retry policy is turned off. Enabling the retry policy can be quite useful while using WebHDFS to copy large files between clusters that could timeout, or copy files between HA clusters that could failover during the copy.  ",false
dfs.http.client.retry.policy.spec," Specify a policy of multiple linear random retry for WebHDFS client, e.g. given pairs of number of retries and sleep time (n0, t0), (n1, t1), ..., the first n0 retries sleep t0 milliseconds on average, the following n1 retries sleep t1 milliseconds on average, and so on.  ","10000,6,60000,10"
dfs.http.client.failover.max.attempts, Specify the max number of failover attempts for WebHDFS client in case of network exception.  ,15
dfs.http.client.retry.max.attempts," Specify the max number of retry attempts for WebHDFS client, if the difference between retried attempts and failovered attempts is larger than the max number of retry attempts, there will be no more retries.  ",10
dfs.http.client.failover.sleep.base.millis, Specify the base amount of time in milliseconds upon which the exponentially increased sleep time between retries or failovers is calculated for WebHDFS client.  ,500
dfs.http.client.failover.sleep.max.millis, Specify the upper bound of sleep time in milliseconds between retries or failovers for WebHDFS client.  ,15000
dfs.namenode.hosts.provider.classname," The class that provides access for host files. org.apache.hadoop.hdfs.server.blockmanagement.HostFileManager is used by default which loads files specified by dfs.hosts and dfs.hosts.exclude. If org.apache.hadoop.hdfs.server.blockmanagement.CombinedHostFileManager is used, it will load the JSON file defined in dfs.hosts. To change class name, nn restart is required. ""dfsadmin -refreshNodes"" only refreshes the configuration files used by the class.  ",org.apache.hadoop.hdfs.server.blockmanagement.HostFileManager
datanode.https.port, HTTPS port for DataNode.  ,50475
dfs.balancer.dispatcherThreads, Size of the thread pool for the HDFS balancer block mover. dispatchExecutor  ,200
dfs.balancer.movedWinWidth, Window of time in ms for the HDFS balancer tracking blocks and its locations.  ,5400000
dfs.balancer.moverThreads, Thread pool size for executing block moves. moverThreadAllocator  ,1000
dfs.balancer.max-size-to-move, Maximum number of bytes that can be moved by the balancer in a single thread.  ,10737418240
dfs.balancer.getBlocks.min-block-size, Minimum block threshold size in bytes to ignore when fetching a source's block list.  ,10485760
dfs.balancer.getBlocks.size, Total size in bytes of Datanode blocks to get when fetching a source's block list.  ,2147483648
dfs.balancer.block-move.timeout," Maximum amount of time in milliseconds for a block to move. If this is set greater than 0, Balancer will stop waiting for a block move completion after this time. In typical clusters, a 3 to 5 minute timeout is reasonable. If timeout happens to a large proportion of block moves, this needs to be increased. It could also be that too much work is dispatched and many nodes are constantly exceeding the bandwidth limit as a result. In that case, other balancer parameters might need to be adjusted. It is disabled (0) by default.  ",0
dfs.balancer.max-no-move-interval," If this specified amount of time has elapsed and no block has been moved out of a source DataNode, on more effort will be made to move blocks out of this DataNode in the current Balancer iteration.  ",60000
dfs.block.invalidate.limit," The maximum number of invalidate blocks sent by namenode to a datanode per heartbeat deletion command. This property works with ""dfs.namenode.invalidate.work.pct.per.iteration"" to throttle block deletions.  ",1000
dfs.block.misreplication.processing.limit, Maximum number of blocks to process for initializing replication queues.  ,10000
dfs.block.replicator.classname," Class representing block placement policy for non-striped files. There are four block placement policies currently being supported: BlockPlacementPolicyDefault, BlockPlacementPolicyWithNodeGroup, BlockPlacementPolicyRackFaultTolerant and BlockPlacementPolicyWithUpgradeDomain. BlockPlacementPolicyDefault chooses the desired number of targets for placing block replicas in a default way. BlockPlacementPolicyWithNodeGroup places block replicas on environment with node-group layer. BlockPlacementPolicyRackFaultTolerant places the replicas to more racks. BlockPlacementPolicyWithUpgradeDomain places block replicas that honors upgrade domain policy. The details of placing replicas are documented in the javadoc of the corresponding policy classes. The default policy is BlockPlacementPolicyDefault, and the corresponding class is org.apache.hadoop.hdfs.server.blockmanagement.BlockPlacementPolicyDefault.  ",org.apache.hadoop.hdfs.server.blockmanagement.BlockPlacementPolicyDefault
dfs.blockreport.incremental.intervalMsec," If set to a positive integer, the value in ms to wait between sending incremental block reports from the Datanode to the Namenode.  ",0
dfs.checksum.type, Checksum type  ,CRC32C
dfs.client.block.write.locateFollowingBlock.retries, Number of retries to use when finding the next block during HDFS writes.  ,5
dfs.client.failover.proxy.provider," The prefix (plus a required nameservice ID) for the class name of the configured Failover proxy provider for the host.  For more detailed information, please consult the ""Configuration Details"" section of the HDFS High Availability documentation.  ",
dfs.client.failover.random.order, Determines if the failover proxies are picked in random order instead of the configured order. The prefix can be used with an optional nameservice ID (of form dfs.client.failover.random.order[.nameservice]) in case multiple nameservices exist and random order should be enabled for specific nameservices.  ,false
dfs.client.key.provider.cache.expiry, DFS client security key cache expiration in milliseconds.  ,864000000
dfs.client.max.block.acquire.failures, Maximum failures allowed when trying to get block information from a specific datanode.  ,3
dfs.client.read.prefetch.size, The number of bytes for the DFSClient will fetch from the Namenode during a read operation.  Defaults to 10 * ${dfs.blocksize}.  ,
dfs.client.read.short.circuit.replica.stale.threshold.ms, Threshold in milliseconds for read entries during short-circuit local reads.  ,1800000
dfs.client.read.shortcircuit.buffer.size, Buffer size in bytes for short-circuit local reads.  ,1048576
dfs.client.replica.accessor.builder.classes," Comma-separated classes for building ReplicaAccessor.  If the classes are specified, client will use external BlockReader that uses the ReplicaAccessor built by the builder.  ",
dfs.client.retry.interval-ms.get-last-block-length, Retry interval in milliseconds to wait between retries in getting block lengths from the datanodes.  ,4000
dfs.client.retry.max.attempts, Max retry attempts for DFSClient talking to namenodes.  ,10
dfs.client.retry.policy.enabled," If true, turns on DFSClient retry policy.  ",false
dfs.client.retry.policy.spec, Set to pairs of timeouts and retries for DFSClient.  ,"10000,6,60000,10"
dfs.client.retry.times.get-last-block-length, Number of retries for calls to fetchLocatedBlocksAndGetLastBlockLength().  ,3
dfs.client.retry.window.base," Base time window in ms for DFSClient retries.  For each retry attempt, this value is extended linearly (e.g. 3000 ms for first attempt and first retry, 6000 ms for second retry, 9000 ms for third retry, etc.).  ",3000
dfs.client.socket-timeout, Default timeout value in milliseconds for all sockets.  ,60000
dfs.client.socketcache.capacity, Socket cache capacity (in entries) for short-circuit reads.  ,16
dfs.client.socketcache.expiryMsec, Socket cache expiration for short-circuit reads in msec.  ,3000
dfs.client.test.drop.namenode.response.number, The number of Namenode responses dropped by DFSClient for each RPC call.  Used for testing the NN retry cache.  ,0
dfs.client.hedged.read.threadpool.size," Support 'hedged' reads in DFSClient. To enable this feature, set the parameter to a positive number. The threadpool size is how many threads to dedicate to the running of these 'hedged', concurrent reads in your client.  ",0
dfs.client.hedged.read.threshold.millis, Configure 'hedged' reads in DFSClient. This is the number of milliseconds to wait before starting up a 'hedged' read.  ,500
dfs.client.use.legacy.blockreader," If true, use the RemoteBlockReader class for local read short circuit.  If false, use the newer RemoteBlockReader2 class.  ",false
dfs.client.write.byte-array-manager.count-limit, The maximum number of arrays allowed for each array length.  ,2048
dfs.client.write.byte-array-manager.count-reset-time-period-ms, The time period in milliseconds that the allocation count for each array length is reset to zero if there is no increment.  ,10000
dfs.client.write.byte-array-manager.count-threshold," The count threshold for each array length so that a manager is created only after the allocation count exceeds the threshold. In other words, the particular array length is not managed until the allocation count exceeds the threshold.  ",128
dfs.client.write.byte-array-manager.enabled," If true, enables byte array manager used by DFSOutputStream.  ",false
dfs.client.write.max-packets-in-flight, The maximum number of DFSPackets allowed in flight.  ,80
dfs.content-summary.limit, The maximum content summary counts allowed in one locking period. 0 or a negative number means no limit (i.e. no yielding).  ,5000
dfs.content-summary.sleep-microsec," The length of time in microseconds to put the thread to sleep, between reaquiring the locks in content summary computation.  ",500
dfs.data.transfer.client.tcpnodelay," If true, set TCP_NODELAY to sockets for transferring data from DFS client.  ",true
dfs.datanode.balance.max.concurrent.moves," Maximum number of threads for Datanode balancer pending moves.  This value is reconfigurable via the ""dfsadmin -reconfig"" command.  ",50
dfs.datanode.fsdataset.factory, The class name for the underlying storage that stores replicas for a Datanode.  Defaults to org.apache.hadoop.hdfs.server.datanode.fsdataset.impl.FsDatasetFactory.  ,
dfs.datanode.fsdataset.volume.choosing.policy," The class name of the policy for choosing volumes in the list of directories.  Defaults to org.apache.hadoop.hdfs.server.datanode.fsdataset.RoundRobinVolumeChoosingPolicy. If you would like to take into account available disk space, set the value to ""org.apache.hadoop.hdfs.server.datanode.fsdataset.AvailableSpaceVolumeChoosingPolicy"".  ",
dfs.datanode.hostname, Optional.  The hostname for the Datanode containing this configuration file.  Will be different for each machine. Defaults to current hostname.  ,
dfs.datanode.lazywriter.interval.sec, Interval in seconds for Datanodes for lazy persist writes.  ,60
dfs.datanode.network.counts.cache.max.size, The maximum number of entries the datanode per-host network error count cache may contain.  ,2147483647
dfs.datanode.oob.timeout-ms," Timeout value when sending OOB response for each OOB type, which are OOB_RESTART, OOB_RESERVED1, OOB_RESERVED2, and OOB_RESERVED3, respectively.  Currently, only OOB_RESTART is used.  ","1500,0,0,0"
dfs.datanode.parallel.volumes.load.threads.num, Maximum number of threads to use for upgrading data directories. The default value is the number of storage directories in the DataNode.  ,
dfs.datanode.ram.disk.replica.tracker, Name of the class implementing the RamDiskReplicaTracker interface. Defaults to org.apache.hadoop.hdfs.server.datanode.fsdataset.impl.RamDiskReplicaLruTracker.  ,
dfs.datanode.restart.replica.expiration," During shutdown for restart, the amount of time in seconds budgeted for datanode restart.  ",50
dfs.datanode.socket.reuse.keepalive," The window of time in ms before the DataXceiver closes a socket for a single request.  If a second request occurs within that window, the socket can be reused.  ",4000
dfs.datanode.socket.write.timeout, Timeout in ms for clients socket writes to DataNodes.  ,480000
dfs.datanode.sync.behind.writes.in.background," If set to true, then sync_file_range() system call will occur asynchronously.  This property is only valid when the property dfs.datanode.sync.behind.writes is true.  ",false
dfs.datanode.transferTo.allowed," If false, break block transfers on 32-bit machines greater than or equal to 2GB into smaller chunks.  ",true
dfs.ha.fencing.methods, A list of scripts or Java classes which will be used to fence the Active NameNode during a failover.  See the HDFS High Availability documentation for details on automatic HA configuration.  ,
dfs.ha.standby.checkpoints," If true, a NameNode in Standby state periodically takes a checkpoint of the namespace, saves it to its local storage and then upload to the remote NameNode.  ",true
dfs.ha.zkfc.port, The port number that the zookeeper failover controller RPC server binds to.  ,8019
dfs.http.port," The http port for used for Hftp, HttpFS, and WebHdfs file systems.  ",
dfs.https.port, The https port for used for Hsftp and SWebHdfs file systems.  ,
dfs.journalnode.edits.dir, The directory where the journal edit files are stored.  ,/tmp/hadoop/dfs/journalnode/
dfs.journalnode.kerberos.internal.spnego.principal, Kerberos SPNEGO principal name used by the journal node.  ,
dfs.journalnode.kerberos.principal, Kerberos principal name for the journal node.  ,
dfs.journalnode.keytab.file, Kerberos keytab file for the journal node.  ,
dfs.ls.limit," Limit the number of files printed by ls. If less or equal to zero, at most DFS_LIST_LIMIT_DEFAULT (= 1000) will be printed.  ",1000
dfs.mover.movedWinWidth," The minimum time interval, in milliseconds, that a block can be moved to another location again.  ",5400000
dfs.mover.moverThreads, Configure the balancer's mover thread pool size.  ,1000
dfs.mover.retry.max.attempts, The maximum number of retries before the mover consider the move failed.  ,10
dfs.mover.max-no-move-interval," If this specified amount of time has elapsed and no block has been moved out of a source DataNode, on more effort will be made to move blocks out of this DataNode in the current Mover iteration.  ",60000
dfs.namenode.audit.log.async," If true, enables asynchronous audit log.  ",false
dfs.namenode.audit.log.token.tracking.id," If true, adds a tracking ID for all audit log events.  ",false
dfs.namenode.available-space-block-placement-policy.balanced-space-preference-fraction," Only used when the dfs.block.replicator.classname is set to org.apache.hadoop.hdfs.server.blockmanagement.AvailableSpaceBlockPlacementPolicy. Special value between 0 and 1, noninclusive.  Increases chance of placing blocks on Datanodes with less disk space used.  ",0.6
dfs.namenode.backup.dnrpc-address, Service RPC address for the backup Namenode.  ,
dfs.namenode.delegation.token.always-use," For testing.  Setting to true always allows the DT secret manager to be used, even if security is disabled.  ",false
dfs.namenode.edits.asynclogging," If set to true, enables asynchronous edit logs in the Namenode.  If set to false, the Namenode uses the traditional synchronous edit logs.  ",true
dfs.namenode.edits.dir.minimum," dfs.namenode.edits.dir includes both required directories (specified by dfs.namenode.edits.dir.required) and optional directories. The number of usable optional directories must be greater than or equal to this property.  If the number of usable optional directories falls below dfs.namenode.edits.dir.minimum, HDFS will issue an error. This property defaults to 1.  ",1
dfs.namenode.edits.journal-plugin," When FSEditLog is creating JournalManagers from dfs.namenode.edits.dir, and it encounters a URI with a schema different to ""file"" it loads the name of the implementing class from ""dfs.namenode.edits.journal-plugin.[schema]"". This class must implement JournalManager and have a constructor which takes (Configuration, URI).  ",
dfs.namenode.file.close.num-committed-allowed," Normally a file can only be closed with all its blocks are committed. When this value is set to a positive integer N, a file can be closed when N blocks are committed and the rest complete.  ",0
dfs.namenode.inode.attributes.provider.class, Name of class to use for delegating HDFS authorization.  ,
dfs.namenode.inode.attributes.provider.bypass.users, A list of user principals (in secure cluster) or user names (in insecure cluster) for whom the external attributes provider will be bypassed for all operations. This means file attributes stored in HDFS instead of the external provider will be used for permission checking and be returned when requested.  ,
dfs.namenode.max-num-blocks-to-log, Puts a limit on the number of blocks printed to the log by the Namenode after a block report.  ,1000
dfs.namenode.max.op.size, Maximum opcode size in bytes.  ,52428800
dfs.namenode.name.cache.threshold, Frequently accessed files that are accessed more times than this threshold are cached in the FSDirectory nameCache.  ,10
dfs.namenode.replication.max-streams, Hard limit for the number of highest-priority replication streams.  ,2
dfs.namenode.replication.max-streams-hard-limit, Hard limit for all replication streams.  ,4
dfs.namenode.replication.pending.timeout-sec," Timeout in seconds for block replication.  If this value is 0 or less, then it will default to 5 minutes.  ",-1
dfs.namenode.stale.datanode.minimum.interval," Minimum number of missed heartbeats intervals for a datanode to be marked stale by the Namenode.  The actual interval is calculated as (dfs.namenode.stale.datanode.minimum.interval * dfs.heartbeat.interval) in seconds.  If this value is greater than the property dfs.namenode.stale.datanode.interval, then the calculated value above is used.  ",3
dfs.namenode.snapshot.capture.openfiles," If true, snapshots taken will have an immutable shared copy of the open files that have valid leases. Even after the open files grow or shrink in size, snapshot will always have the previous point-in-time version of the open files, just like all other closed files. Default is false. Note: The file length captured for open files in snapshot is whats recorded in NameNode at the time of snapshot and it may be shorter than what the client has written till then. In order to capture the latest length, the client can call hflush/hsync with the flag SyncFlag.UPDATE_LENGTH on the open files handles.  ",false
dfs.namenode.snapshot.skip.capture.accesstime-only-change," If accessTime of a file/directory changed but there is no other modification made to the file/directory, the changed accesstime will not be captured in next snapshot. However, if there is other modification made to the file/directory, the latest access time will be captured together with the modification in next snapshot.  ",false
dfs.pipeline.ecn," If true, allows ECN (explicit congestion notification) from the Datanode.  ",false
dfs.qjournal.accept-recovery.timeout.ms, Quorum timeout in milliseconds during accept phase of recovery/synchronization for a specific segment.  ,120000
dfs.qjournal.finalize-segment.timeout.ms, Quorum timeout in milliseconds during finalizing for a specific segment.  ,120000
dfs.qjournal.get-journal-state.timeout.ms, Timeout in milliseconds when calling getJournalState(). JournalNodes.  ,120000
dfs.qjournal.new-epoch.timeout.ms, Timeout in milliseconds when getting an epoch number for write access to JournalNodes.  ,120000
dfs.qjournal.prepare-recovery.timeout.ms, Quorum timeout in milliseconds during preparation phase of recovery/synchronization for a specific segment.  ,120000
dfs.qjournal.queued-edits.limit.mb, Queue size in MB for quorum journal edits.  ,10
dfs.qjournal.select-input-streams.timeout.ms, Timeout in milliseconds for accepting streams from JournalManagers.  ,20000
dfs.qjournal.start-segment.timeout.ms, Quorum timeout in milliseconds for starting a log segment.  ,20000
dfs.qjournal.write-txns.timeout.ms, Write timeout in milliseconds when writing to a quorum of remote journals.  ,20000
dfs.quota.by.storage.type.enabled," If true, enables quotas based on storage type.  ",true
dfs.secondary.namenode.kerberos.principal, Kerberos principal name for the Secondary NameNode.  ,
dfs.secondary.namenode.keytab.file, Kerberos keytab file for the Secondary NameNode.  ,
dfs.support.append, Enables append support on the NameNode.  ,true
dfs.web.authentication.filter, Authentication filter class used for WebHDFS.  ,org.apache.hadoop.hdfs.web.AuthFilter
dfs.web.authentication.simple.anonymous.allowed," If true, allow anonymous user to access WebHDFS. Set to false to disable anonymous authentication.  ",
dfs.web.ugi, dfs.web.ugi is deprecated. Use hadoop.http.staticuser.user instead.  ,
dfs.webhdfs.netty.high.watermark, High watermark configuration to Netty for Datanode WebHdfs.  ,65535
dfs.webhdfs.netty.low.watermark, Low watermark configuration to Netty for Datanode WebHdfs.  ,32768
dfs.webhdfs.oauth2.access.token.provider, Access token provider class for WebHDFS using OAuth2. Defaults to org.apache.hadoop.hdfs.web.oauth2.ConfCredentialBasedAccessTokenProvider.  ,
dfs.webhdfs.oauth2.client.id, Client id used to obtain access token with either credential or refresh token.  ,
dfs.webhdfs.oauth2.enabled," If true, enables OAuth2 in WebHDFS  ",false
dfs.webhdfs.oauth2.refresh.url, URL against which to post for obtaining bearer token with either credential or refresh token.  ,
ssl.server.keystore.keypassword, Keystore key password for HTTPS SSL configuration  ,
ssl.server.keystore.location, Keystore location for HTTPS SSL configuration  ,
ssl.server.keystore.password, Keystore password for HTTPS SSL configuration  ,
dfs.balancer.keytab.enabled, Set to true to enable login using a keytab for Kerberized Hadoop.  ,false
dfs.balancer.address, The hostname used for a keytab based Kerberos login. Keytab based login can be enabled with dfs.balancer.keytab.enabled.  ,0.0.0.0:0
dfs.balancer.keytab.file, The keytab file used by the Balancer to login as its service principal. The principal name is configured with dfs.balancer.kerberos.principal. Keytab based login can be enabled with dfs.balancer.keytab.enabled.  ,
dfs.balancer.kerberos.principal, The Balancer principal. This is typically set to balancer/_HOST@REALM.TLD. The Balancer will substitute _HOST with its own fully qualified hostname at startup. The _HOST placeholder allows using the same configuration setting on different servers. Keytab based login can be enabled with dfs.balancer.keytab.enabled.  ,
ssl.server.truststore.location, Truststore location for HTTPS SSL configuration  ,
ssl.server.truststore.password, Truststore password for HTTPS SSL configuration  ,
dfs.lock.suppress.warning.interval,Instrumentation reporting long critical sections will suppress consecutive warnings within this interval.,10s
dfs.webhdfs.use.ipc.callq,Enables routing of webhdfs calls through rpc   call queue,true
httpfs.buffer.size, The size buffer to be used when creating or opening httpfs filesystem IO stream. ,4096
dfs.datanode.disk.check.min.gap,   The minimum gap between two successive checks of the same DataNode   volume. This setting supports multiple time unit suffixes as described   in dfs.heartbeat.interval. If no suffix is specified then milliseconds   is assumed. ,15m
dfs.datanode.disk.check.timeout,   Maximum allowed time for a disk check to complete during DataNode   startup. If the check does not complete within this time interval   then the disk is declared as failed. This setting supports   multiple time unit suffixes as described in dfs.heartbeat.interval.   If no suffix is specified then milliseconds is assumed. ,10m
dfs.use.dfs.network.topology,  Enables DFSNetworkTopology to choose nodes for placing replicas. ,true
dfs.qjm.operations.timeout,   Common key to set timeout for related operations in   QuorumJournalManager. This setting supports multiple time unit suffixes   as described in dfs.heartbeat.interval.   If no suffix is specified then milliseconds is assumed. ,60s
dfs.reformat.disabled,"   Disable reformat of NameNode. If it's value is set to ""true""   and metadata directories already exist then attempt to format NameNode   will throw NameNodeFormatException. ",false
mapreduce.job.hdfs-servers,,${fs.defaultFS}
mapreduce.job.committer.setup.cleanup.needed," true, if job needs job-setup and job-cleanup.    false, otherwise  ",true
mapreduce.task.io.sort.factor,The number of streams to merge at once while sorting  files.  This determines the number of open file handles.,10
mapreduce.task.io.sort.mb,"The total amount of buffer memory to use while sorting  files, in megabytes.  By default, gives each merge stream 1MB, which  should minimize seeks.",100
mapreduce.map.sort.spill.percent,"The soft limit in the serialization buffer. Once reached, a  thread will begin to spill the contents to disk in the background. Note that  collection will not block if this threshold is exceeded while a spill is  already in progress, so spills may be larger than this threshold when it is  set to less than .5",0.80
mapreduce.jobtracker.address,"The host and port that the MapReduce job tracker runs  at.  If ""local"", then jobs are run in-process as a single map  and reduce task.  ",local
mapreduce.local.clientfactory.class.name,This the client factory that is responsible for   creating local job runner client,org.apache.hadoop.mapred.LocalClientFactory
mapreduce.jobtracker.system.dir,The directory where MapReduce stores control files.  ,${hadoop.tmp.dir}/mapred/system
mapreduce.jobtracker.staging.root.dir,"The root of the staging area for users' job files  In practice, this should be the directory where users' home  directories are located (usually /user)  ",${hadoop.tmp.dir}/mapred/staging
mapreduce.cluster.temp.dir,A shared directory for temporary files.  ,${hadoop.tmp.dir}/mapred/temp
mapreduce.job.maps,"The default number of map tasks per job.  Ignored when mapreduce.framework.name is ""local"".  ",2
mapreduce.job.reduces,"The default number of reduce tasks per job. Typically set to 99%  of the cluster's reduce capacity, so that if a node fails the reduces can  still be executed in a single wave.  Ignored when mapreduce.framework.name is ""local"".  ",1
mapreduce.job.running.map.limit,The maximum number of simultaneous map tasks per job.  There is no limit if this value is 0 or negative.  ,0
mapreduce.job.running.reduce.limit,The maximum number of simultaneous reduce tasks per job.  There is no limit if this value is 0 or negative.  ,0
mapreduce.job.max.map,Limit on the number of map tasks allowed per job.  There is no limit if this value is negative.  ,-1
mapreduce.job.reducer.preempt.delay.sec,"The threshold (in seconds) after which an unsatisfied   mapper request triggers reducer preemption when there is no anticipated   headroom. If set to 0 or a negative value, the reducer is preempted as   soon as lack of headroom is detected. Default is 0. ",0
mapreduce.job.reducer.unconditional-preempt.delay.sec,"The threshold (in seconds) after which an unsatisfied   mapper request triggers a forced reducer preemption irrespective of the   anticipated headroom. By default, it is set to 5 mins. Setting it to 0   leads to immediate reducer preemption. Setting to -1 disables this   preemption altogether. ",300
mapreduce.job.max.split.locations,The max number of block locations to store for each split for locality calculation. ,10
mapreduce.job.split.metainfo.maxsize,The maximum permissible size of the split metainfo file.  The MapReduce ApplicationMaster won't attempt to read submitted split metainfo  files bigger than this configured value.  No limits if set to -1.  ,10000000
mapreduce.map.maxattempts,"Expert: The maximum number of attempts per map task.  In other words, framework will try to execute a map task these many number  of times before giving up on it.  ",4
mapreduce.reduce.maxattempts,"Expert: The maximum number of attempts per reduce task.  In other words, framework will try to execute a reduce task these many number  of times before giving up on it.  ",4
mapreduce.reduce.shuffle.fetch.retry.enabled,Set to enable fetch retry during host restart.,${yarn.nodemanager.recovery.enabled}
mapreduce.reduce.shuffle.fetch.retry.interval-ms,Time of interval that fetcher retry to fetch again when some  non-fatal failure happens because of some events like NM restart.  ,1000
mapreduce.reduce.shuffle.fetch.retry.timeout-ms,Timeout value for fetcher to retry to fetch again when some  non-fatal failure happens because of some events like NM restart.,30000
mapreduce.reduce.shuffle.retry-delay.max.ms,The maximum number of ms the reducer will delay before retrying  to download map data.  ,60000
mapreduce.reduce.shuffle.parallelcopies,The default number of parallel transfers run by reduce  during the copy(shuffle) phase.  ,5
mapreduce.reduce.shuffle.connect.timeout,Expert: The maximum amount of time (in milli seconds) reduce  task spends in trying to connect to a remote node for getting map output.  ,180000
mapreduce.reduce.shuffle.read.timeout,Expert: The maximum amount of time (in milli seconds) reduce  task waits for map output data to be available for reading after obtaining  connection.  ,180000
mapreduce.shuffle.listen.queue.size,The length of the shuffle server listen queue.,128
mapreduce.shuffle.connection-keep-alive.enable,set to true to support keep-alive connections.,false
mapreduce.shuffle.connection-keep-alive.timeout,"The number of seconds a shuffle client attempts to retain   http connection. Refer ""Keep-Alive: timeout="" header in   Http specification  ",5
mapreduce.task.timeout,"The number of milliseconds before a task will be  terminated if it neither reads an input, writes an output, nor  updates its status string.  A value of 0 disables the timeout.  ",600000
mapreduce.map.memory.mb,The amount of memory to request from the scheduler for each  map task.  ,1024
mapreduce.map.cpu.vcores,The number of virtual cores to request from the scheduler for  each map task.  ,1
mapreduce.reduce.memory.mb,The amount of memory to request from the scheduler for each  reduce task.  ,1024
mapreduce.reduce.cpu.vcores,The number of virtual cores to request from the scheduler for  each reduce task.  ,1
mapred.child.java.opts,"Java opts for the task processes.  The following symbol, if present, will be interpolated: @taskid@ is replaced  by current TaskID. Any other occurrences of '@' will go unchanged.  For example, to enable verbose gc logging to a file named for the taskid in  /tmp and to set the heap maximum to be a gigabyte, pass a 'value' of:  -Xmx1024m -verbose:gc -Xloggc:/tmp/@taskid@.gc Usage of -Djava.library.path can cause programs to no longer function if  hadoop native libraries are used. These values should instead be set as part  of LD_LIBRARY_PATH in the map / reduce JVM env using the mapreduce.map.env and  mapreduce.reduce.env config settings.  ",-Xmx200m
mapred.child.env,User added environment variables for the task processes.  Example :  1) A=foo  This will set the env variable A to foo  2) B=$B:c This is inherit nodemanager's B env variable on Unix.  3) B=%B%;c This is inherit nodemanager's B env variable on Windows.  ,
mapreduce.admin.user.env,"  Expert: Additional execution environment entries for  map and reduce task processes. This is not an additive property.  You must preserve the original value if you want your map and  reduce tasks to have access to native libraries (compression, etc).  When this value is empty, the command to set execution  envrionment will be OS dependent:  For linux, use LD_LIBRARY_PATH=$HADOOP_COMMON_HOME/lib/native.  For windows, use PATH = %PATH%;%HADOOP_COMMON_HOME%\\bin.  ",
yarn.app.mapreduce.am.log.level,"The logging level for the MR ApplicationMaster. The allowed  levels are: OFF, FATAL, ERROR, WARN, INFO, DEBUG, TRACE and ALL.  The setting here could be overriden if ""mapreduce.job.log4j-properties-file""  is set.  ",INFO
mapreduce.map.log.level,"The logging level for the map task. The allowed levels are:  OFF, FATAL, ERROR, WARN, INFO, DEBUG, TRACE and ALL.  The setting here could be overridden if ""mapreduce.job.log4j-properties-file""  is set.  ",INFO
mapreduce.reduce.log.level,"The logging level for the reduce task. The allowed levels are:  OFF, FATAL, ERROR, WARN, INFO, DEBUG, TRACE and ALL.  The setting here could be overridden if ""mapreduce.job.log4j-properties-file""  is set.  ",INFO
mapreduce.reduce.merge.inmem.threshold,"The threshold, in terms of the number of files  for the in-memory merge process. When we accumulate threshold number of files  we initiate the in-memory merge and spill to disk. A value of 0 or less than  0 indicates we want to DON'T have any threshold and instead depend only on  the ramfs's memory consumption to trigger the merge.  ",1000
mapreduce.reduce.shuffle.merge.percent,"The usage threshold at which an in-memory merge will be  initiated, expressed as a percentage of the total memory allocated to  storing in-memory map outputs, as defined by  mapreduce.reduce.shuffle.input.buffer.percent.  ",0.66
mapreduce.reduce.shuffle.input.buffer.percent,The percentage of memory to be allocated from the maximum heap  size to storing map outputs during the shuffle.  ,0.70
mapreduce.reduce.input.buffer.percent,"The percentage of memory- relative to the maximum heap size- to  retain map outputs during the reduce. When the shuffle is concluded, any  remaining map outputs in memory must consume less than this threshold before  the reduce can begin.  ",0.0
mapreduce.reduce.shuffle.memory.limit.percent,"Expert: Maximum percentage of the in-memory limit that a  single shuffle can consume. Range of valid values is [0.0, 1.0]. If the value  is 0.0 map outputs are shuffled directly to disk.",0.25
mapreduce.shuffle.ssl.enabled, Whether to use SSL for for the Shuffle HTTP endpoints.  ,false
mapreduce.shuffle.ssl.file.buffer.size,Buffer size for reading spills from file when using SSL.  ,65536
mapreduce.shuffle.max.connections,Max allowed connections for the shuffle.  Set to 0 (zero)      to indicate no limit on the number of connections.  ,0
mapreduce.shuffle.max.threads,"Max allowed threads for serving shuffle connections. Set to zero  to indicate the default of 2 times the number of available  processors (as reported by Runtime.availableProcessors()). Netty is used to  serve requests, so a thread is not needed for each connection.  ",0
mapreduce.shuffle.transferTo.allowed,"This option can enable/disable using nio transferTo method in  the shuffle phase. NIO transferTo does not perform well on windows in the  shuffle phase. Thus, with this configuration property it is possible to  disable it, in which case custom transfer method will be used. Recommended  value is false when running Hadoop on Windows. For Linux, it is recommended  to set it to true. If nothing is set then the default value is false for  Windows, and true for Linux.  ",
mapreduce.shuffle.transfer.buffer.size,"This property is used only if  mapreduce.shuffle.transferTo.allowed is set to false. In that case,  this property defines the size of the buffer used in the buffer copy code  for the shuffle phase. The size of this buffer determines the size of the IO  requests.  ",131072
mapreduce.reduce.markreset.buffer.percent,The percentage of memory -relative to the maximum heap size- to  be used for caching values when using the mark-reset functionality.  ,0.0
mapreduce.map.speculative,"If true, then multiple instances of some map tasks      may be executed in parallel.",true
mapreduce.reduce.speculative,"If true, then multiple instances of some reduce tasks      may be executed in parallel.",true
mapreduce.job.speculative.speculative-cap-running-tasks,The max percent (0-1) of running tasks that  can be speculatively re-executed at any time.,0.1
mapreduce.job.speculative.speculative-cap-total-tasks,The max percent (0-1) of all tasks that  can be speculatively re-executed at any time.,0.01
mapreduce.job.speculative.minimum-allowed-tasks,The minimum allowed tasks that  can be speculatively re-executed at any time.,10
mapreduce.job.speculative.retry-after-no-speculate,The waiting time(ms) to do next round of speculation  if there is no task speculated in this round.,1000
mapreduce.job.speculative.retry-after-speculate,The waiting time(ms) to do next round of speculation  if there are tasks speculated in this round.,15000
mapreduce.job.map.output.collector.class," The MapOutputCollector implementation(s) to use. This may be a comma-separated list of class names, in which case the map task will try to initialize each of the collectors in turn. The first to successfully initialize will be used.  ",org.apache.hadoop.mapred.MapTask$MapOutputBuffer
mapreduce.job.speculative.slowtaskthreshold,The number of standard deviations by which a task's  ave progress-rates must be lower than the average of all running tasks'  for the task to be considered too slow.  ,1.0
mapreduce.job.ubertask.enable,"Whether to enable the small-jobs ""ubertask"" optimization,  which runs ""sufficiently small"" jobs sequentially within a single JVM.  ""Small"" is defined by the following maxmaps, maxreduces, and maxbytes  settings. Note that configurations for application masters also affect  the ""Small"" definition - yarn.app.mapreduce.am.resource.mb must be  larger than both mapreduce.map.memory.mb and mapreduce.reduce.memory.mb,  and yarn.app.mapreduce.am.resource.cpu-vcores must be larger than  both mapreduce.map.cpu.vcores and mapreduce.reduce.cpu.vcores to enable  ubertask. Users may override this value.  ",false
mapreduce.job.ubertask.maxmaps,"Threshold for number of maps, beyond which job is considered  too big for the ubertasking optimization.  Users may override this value,  but only downward.  ",9
mapreduce.job.ubertask.maxreduces,"Threshold for number of reduces, beyond which job is considered  too big for the ubertasking optimization.  CURRENTLY THE CODE CANNOT SUPPORT  MORE THAN ONE REDUCE and will ignore larger values.  (Zero is a valid max,  however.)  Users may override this value, but only downward.  ",1
mapreduce.job.ubertask.maxbytes,"Threshold for number of input bytes, beyond which job is  considered too big for the ubertasking optimization.  If no value is  specified, dfs.block.size is used as a default.  Be sure to specify a  default value in mapred-site.xml if the underlying filesystem is not HDFS.  Users may override this value, but only downward.  ",
mapreduce.job.emit-timeline-data,Specifies if the Application Master should emit timeline data to the timeline server. Individual jobs can override this value. ,false
mapreduce.job.sharedcache.mode," A comma delimited list of resource categories to submit to the shared cache. The valid categories are: jobjar, libjars, files, archives. If ""disabled"" is specified then the job submission code will not use the shared cache.  ",disabled
mapreduce.input.fileinputformat.split.minsize,The minimum size chunk that map input should be split  into.  Note that some file formats may have minimum split sizes that  take priority over this setting.,0
mapreduce.input.fileinputformat.list-status.num-threads,The number of threads to use to list and fetch block locations  for the specified input paths. Note: multiple threads should not be used  if a custom non thread-safe path filter is used.  ,1
mapreduce.input.lineinputformat.linespermap,"When using NLineInputFormat, the number of lines of input data  to include in each split.",1
mapreduce.client.submit.file.replication,The replication level for submitted job files.  This  should be around the square root of the number of nodes.  ,10
mapreduce.task.files.preserve.failedtasks,"Should the files for failed tasks be kept. This should only be      used on jobs that are failing, because the storage is never      reclaimed. It also prevents the map outputs from being erased      from the reduce directory as they are consumed.",false
mapreduce.output.fileoutputformat.compress,Should the job outputs be compressed?  ,false
mapreduce.output.fileoutputformat.compress.type,"If the job outputs are to compressed as SequenceFiles, how should      they be compressed? Should be one of NONE, RECORD or BLOCK.  ",RECORD
mapreduce.output.fileoutputformat.compress.codec,"If the job outputs are compressed, how should they be compressed?  ",org.apache.hadoop.io.compress.DefaultCodec
mapreduce.map.output.compress,Should the outputs of the maps be compressed before being      sent across the network. Uses SequenceFile compression.  ,false
mapreduce.map.output.compress.codec,"If the map outputs are compressed, how should they be      compressed?  ",org.apache.hadoop.io.compress.DefaultCodec
map.sort.class,The default sort class for sorting keys.  ,org.apache.hadoop.util.QuickSort
mapreduce.task.userlog.limit.kb,The maximum size of user-logs of each task in KB. 0 disables the cap.  ,0
yarn.app.mapreduce.am.container.log.limit.kb,The maximum size of the MRAppMaster attempt container logs in KB. 0 disables the cap.  ,0
yarn.app.mapreduce.task.container.log.backups,"Number of backup files for task logs when using ContainerRollingLogAppender (CRLA). See org.apache.log4j.RollingFileAppender.maxBackupIndex. By default, ContainerLogAppender (CLA) is used, and container logs are not rolled. CRLA is enabled for tasks when both mapreduce.task.userlog.limit.kb and yarn.app.mapreduce.task.container.log.backups are greater than zero.  ",0
yarn.app.mapreduce.am.container.log.backups,"Number of backup files for the ApplicationMaster logs when using ContainerRollingLogAppender (CRLA). See org.apache.log4j.RollingFileAppender.maxBackupIndex. By default, ContainerLogAppender (CLA) is used, and container logs are not rolled. CRLA is enabled for the ApplicationMaster when both yarn.app.mapreduce.am.container.log.limit.kb and yarn.app.mapreduce.am.container.log.backups are greater than zero.  ",0
yarn.app.mapreduce.shuffle.log.separate,If enabled ('true') logging generated by the client-side shuffle classes in a reducer will be written in a dedicated log file 'syslog.shuffle' instead of 'syslog'.  ,true
yarn.app.mapreduce.shuffle.log.limit.kb,Maximum size of the syslog.shuffle file in kilobytes (0 for no limit).  ,0
yarn.app.mapreduce.shuffle.log.backups,If yarn.app.mapreduce.shuffle.log.limit.kb and yarn.app.mapreduce.shuffle.log.backups are greater than zero then a ContainerRollngLogAppender is used instead of ContainerLogAppender for syslog.shuffle. See org.apache.log4j.RollingFileAppender.maxBackupIndex  ,0
mapreduce.job.maxtaskfailures.per.tracker,The number of task-failures on a node manager of a given job      after which new tasks of that job aren't assigned to it. It      MUST be less than mapreduce.map.maxattempts and      mapreduce.reduce.maxattempts otherwise the failed task will      never be tried on a different node.  ,3
mapreduce.client.output.filter,"The filter for controlling the output of the task's userlogs sent      to the console of the JobClient.      The permissible options are: NONE, KILLED, FAILED, SUCCEEDED and      ALL.  ",FAILED
mapreduce.client.completion.pollinterval,The interval (in milliseconds) between which the JobClient polls the MapReduce ApplicationMaster for updates about job status. You may want to set this to a lower value to make tests run faster on a single node system. Adjusting this value in production may lead to unwanted client-server traffic. ,5000
mapreduce.client.progressmonitor.pollinterval,The interval (in milliseconds) between which the JobClient reports status to the console and checks for job completion. You may want to set this to a lower value to make tests run faster on a single node system. Adjusting this value in production may lead to unwanted client-server traffic. ,1000
mapreduce.client.libjars.wildcard,"  Whether the libjars cache files should be localized using  a wildcarded directory instead of naming each archive independently.  Using wildcards reduces the space needed for storing the job  information in the case of a highly available resource manager  configuration.  This propery should only be set to false for specific  jobs which are highly sensitive to the details of the archive  localization.  Having this property set to true will cause the archives  to all be localized to the same local cache location.  If false, each  archive will be localized to its own local cache location.  In both  cases a symbolic link will be created to every archive from the job's  working directory. ",true
mapreduce.task.profile,"To set whether the system should collect profiler  information for some of the tasks in this job? The information is stored  in the user log directory. The value is ""true"" if task profiling  is enabled.",false
mapreduce.task.profile.maps, To set the ranges of map tasks to profile. mapreduce.task.profile has to be set to true for the value to be accounted. ,0-2
mapreduce.task.profile.reduces, To set the ranges of reduce tasks to profile. mapreduce.task.profile has to be set to true for the value to be accounted. ,0-2
mapreduce.task.profile.params,"JVM profiler parameters used to profile map and reduce task   attempts. This string may contain a single format specifier %s that will   be replaced by the path to profile.out in the task attempt log directory.   To specify different profiling options for map tasks and reduce tasks,   more specific parameters mapreduce.task.profile.map.params and   mapreduce.task.profile.reduce.params should be used.","-agentlib:hprof=cpu=samples,heap=sites,force=n,thread=y,verbose=n,file=%s"
mapreduce.task.profile.map.params,Map-task-specific JVM profiler parameters. See   mapreduce.task.profile.params,${mapreduce.task.profile.params}
mapreduce.task.profile.reduce.params,Reduce-task-specific JVM profiler parameters. See   mapreduce.task.profile.params,${mapreduce.task.profile.params}
mapreduce.task.skip.start.attempts," The number of Task attempts AFTER which skip mode  will be kicked off. When skip mode is kicked off, the tasks reports the range of records which it will process  next, to the MR ApplicationMaster. So that on failures, the MR AM knows which ones are possibly the bad records. On further executions, those are skipped. ",2
mapreduce.map.skip.proc-count.auto-incr," The flag which if set to true,  SkipBadRecords.COUNTER_MAP_PROCESSED_RECORDS is incremented  by MapRunner after invoking the map function. This value must be set to  false for applications which process the records asynchronously  or buffer the input records. For example streaming.  In such cases applications should increment this counter on their own. ",true
mapreduce.reduce.skip.proc-count.auto-incr," The flag which if set to true,  SkipBadRecords.COUNTER_REDUCE_PROCESSED_GROUPS is incremented  by framework after invoking the reduce function. This value must be set to  false for applications which process the records asynchronously  or buffer the input records. For example streaming.  In such cases applications should increment this counter on their own. ",true
mapreduce.job.skip.outdir," If no value is specified here, the skipped records are written to the output directory at _logs/skip. User can stop writing skipped records by giving the value ""none"". ",
mapreduce.map.skip.maxrecords," The number of acceptable skip records surrounding the bad record PER bad record in mapper. The number includes the bad record as well. To turn the feature of detection/skipping of bad records off, set the value to 0. The framework tries to narrow down the skipped range by retrying until this threshold is met OR all attempts get exhausted for this task. Set the value to Long.MAX_VALUE to indicate that framework need not try to narrow down. Whatever records(depends on application) get skipped are acceptable. ",0
mapreduce.reduce.skip.maxgroups," The number of acceptable skip groups surrounding the bad group PER bad group in reducer. The number includes the bad group as well. To turn the feature of detection/skipping of bad groups off, set the value to 0. The framework tries to narrow down the skipped range by retrying until this threshold is met OR all attempts get exhausted for this task. Set the value to Long.MAX_VALUE to indicate that framework need not try to narrow down. Whatever groups(depends on application) get skipped are acceptable. ",0
mapreduce.ifile.readahead,Configuration key to enable/disable IFile readahead. ,true
mapreduce.ifile.readahead.bytes,Configuration key to set the IFile readahead length in bytes. ,4194304
mapreduce.job.queuename," Queue to which a job is submitted. This must match one of the queues defined in mapred-queues.xml for the system. Also, the ACL setup for the queue must allow the current user to submit a job to the queue. Before specifying a queue, ensure that the system is configured with the queue, and access is allowed for submitting jobs to the queue.  ",default
mapreduce.job.tags, Tags for the job that will be passed to YARN at submission   time. Queries to YARN for applications can filter on these tags. ,
mapreduce.cluster.local.dir,   The local directory where MapReduce stores intermediate   data files.  May be a comma-separated list of   directories on different devices in order to spread disk i/o.   Directories that do not exist are ignored.  ,${hadoop.tmp.dir}/mapred/local
mapreduce.cluster.acls.enabled," Specifies whether ACLs should be checked for authorization of users for doing various queue and job level operations. ACLs are disabled by default. If enabled, access control checks are made by MapReduce ApplicationMaster when requests are made by users for queue operations like submit job to a queue and kill a job in the queue and job operations like viewing the job-details (See mapreduce.job.acl-view-job) or for modifying the job (See mapreduce.job.acl-modify-job) using Map/Reduce APIs, RPCs or via the console and web user interfaces. For enabling this flag, set to true in mapred-site.xml file of all MapReduce clients (MR job submitting nodes).  ",false
mapreduce.job.acl-modify-job," Job specific access-control list for 'modifying' the job. It is only used if authorization is enabled in Map/Reduce by setting the configuration property mapreduce.cluster.acls.enabled to true. This specifies the list of users and/or groups who can do modification operations on the job. For specifying a list of users and groups the format to use is ""user1,user2 group1,group"". If set to '*', it allows all users/groups to modify this job. If set to ' '(i.e. space), it allows none. This configuration is used to guard all the modifications with respect to this job and takes care of all the following operations:   o killing this job   o killing a task of this job, failing a task of this job   o setting the priority of this job Each of these operations are also protected by the per-queue level ACL ""acl-administer-jobs"" configured via mapred-queues.xml. So a caller should have the authorization to satisfy either the queue-level ACL or the job-level ACL. Irrespective of this ACL configuration, (a) job-owner, (b) the user who started the cluster, (c) members of an admin configured supergroup configured via mapreduce.cluster.permissions.supergroup and (d) queue administrators of the queue to which this job was submitted to configured via acl-administer-jobs for the specific queue in mapred-queues.xml can do all the modification operations on a job. By default, nobody else besides job-owner, the user who started the cluster, members of supergroup and queue administrators can perform modification operations on a job.  ", 
mapreduce.job.acl-view-job," Job specific access-control list for 'viewing' the job. It is only used if authorization is enabled in Map/Reduce by setting the configuration property mapreduce.cluster.acls.enabled to true. This specifies the list of users and/or groups who can view private details about the job. For specifying a list of users and groups the format to use is ""user1,user2 group1,group"". If set to '*', it allows all users/groups to modify this job. If set to ' '(i.e. space), it allows none. This configuration is used to guard some of the job-views and at present only protects APIs that can return possibly sensitive information of the job-owner like   o job-level counters   o task-level counters   o tasks' diagnostic information   o task-logs displayed on the HistoryServer's web-UI and   o job.xml showed by the HistoryServer's web-UI Every other piece of information of jobs is still accessible by any other user, for e.g., JobStatus, JobProfile, list of jobs in the queue, etc. Irrespective of this ACL configuration, (a) job-owner, (b) the user who started the cluster, (c) members of an admin configured supergroup configured via mapreduce.cluster.permissions.supergroup and (d) queue administrators of the queue to which this job was submitted to configured via acl-administer-jobs for the specific queue in mapred-queues.xml can do all the view operations on a job. By default, nobody else besides job-owner, the user who started the cluster, memebers of supergroup and queue administrators can perform view operations on a job.  ", 
mapreduce.job.finish-when-all-reducers-done,"Specifies whether the job should complete once all reducers  have finished, regardless of whether there are still running mappers.  ",false
mapreduce.job.token.tracking.ids.enabled,"Whether to write tracking ids of tokens to job-conf. When true, the configuration property ""mapreduce.job.token.tracking.ids"" is set to the token-tracking-ids of the job",false
mapreduce.job.token.tracking.ids,"When mapreduce.job.token.tracking.ids.enabled is set to true, this is set by the framework to the token-tracking-ids used by the job.",
mapreduce.task.merge.progress.records, The number of records to process during merge before   sending a progress notification to the MR ApplicationMaster.  ,10000
mapreduce.task.combine.progress.records, The number of records to process during combine output collection   before sending a progress notification.  ,10000
mapreduce.job.reduce.slowstart.completedmaps,Fraction of the number of maps in the job which should be  complete before reduces are scheduled for the job.  ,0.05
mapreduce.job.complete.cancel.delegation.tokens," if false - do not unregister/cancel delegation tokens from renewal, because same tokens may be used by spawned jobs  ",true
mapreduce.shuffle.port,Default port that the ShuffleHandler will run on. ShuffleHandler   is a service run at the NodeManager to facilitate transfers of intermediate   Map outputs to requesting Reducers.  ,13562
mapreduce.job.reduce.shuffle.consumer.plugin.class,  Name of the class whose instance will be used  to send shuffle requests by reducetasks of this job.  The class must be an instance of org.apache.hadoop.mapred.ShuffleConsumerPlugin.  ,org.apache.hadoop.mapreduce.task.reduce.Shuffle
mapreduce.job.node-label-expression,"All the containers of the Map Reduce job will be run with this  node label expression. If the node-label-expression for job is not set, then  it will use queue's default-node-label-expression for all job's containers.  ",
mapreduce.job.am.node-label-expression,This is node-label configuration for Map Reduce Application Master  container. If not configured it will make use of  mapreduce.job.node-label-expression and if job's node-label expression is not  configured then it will use queue's default-node-label-expression.  ,
mapreduce.map.node-label-expression,This is node-label configuration for Map task containers. If not  configured it will use mapreduce.job.node-label-expression and if job's  node-label expression is not configured then it will use queue's  default-node-label-expression.  ,
mapreduce.reduce.node-label-expression,This is node-label configuration for Reduce task containers. If  not configured it will use mapreduce.job.node-label-expression and if job's  node-label expression is not configured then it will use queue's  default-node-label-expression.  ,
mapreduce.job.counters.limit,Limit on the number of user counters allowed per job.  ,120
mapreduce.framework.name,"The runtime framework for executing MapReduce jobs.  Can be one of local, classic or yarn.  ",local
yarn.app.mapreduce.am.staging-dir,The staging dir used while submitting jobs.  ,/tmp/hadoop-yarn/staging
mapreduce.am.max-attempts,"The maximum number of application attempts. It is a  application-specific setting. It should not be larger than the global number  set by resourcemanager. Otherwise, it will be override. The default number is  set to 2, to allow at least one retry for AM.",2
mapreduce.job.end-notification.url,"Indicates url which will be called on completion of job to inform     end status of job.     User can give at most 2 variables with URI : $jobId and $jobStatus.     If they are present in URI, then they will be replaced by their     respective values.",
mapreduce.job.end-notification.retry.attempts,The number of times the submitter of the job wants to retry job end notification if it fails. This is capped by mapreduce.job.end-notification.max.attempts,0
mapreduce.job.end-notification.retry.interval,The number of milliseconds the submitter of the job wants to wait before job end notification is retried if it fails. This is capped by mapreduce.job.end-notification.max.retry.interval,1000
mapreduce.job.end-notification.max.attempts,"The maximum number of times a URL will be read for providing job end notification. Cluster administrators can set this to limit how long after end of a job, the Application Master waits before exiting. Must be marked as final to prevent users from overriding this.  ",5
mapreduce.job.log4j-properties-file,"Used to override the default settings of log4j in container-log4j.properties for NodeManager. Like container-log4j.properties, it requires certain framework appenders properly defined in this overriden file. The file on the path will be added to distributed cache and classpath. If no-scheme is given in the path, it defaults to point to a log4j file on the local FS. ",
mapreduce.job.end-notification.max.retry.interval,The maximum amount of time (in milliseconds) to wait before  retrying job end notification. Cluster administrators can set this to  limit how long the Application Master waits before exiting. Must be marked  as final to prevent users from overriding this.,5000
yarn.app.mapreduce.am.env,User added environment variables for the MR App Master  processes. Example :  1) A=foo  This will set the env variable A to foo  2) B=$B:c This is inherit tasktracker's B env variable.  ,
yarn.app.mapreduce.am.admin.user.env, Environment variables for the MR App Master  processes for admin purposes. These values are set first and can be  overridden by the user env (yarn.app.mapreduce.am.env) Example :  1) A=foo  This will set the env variable A to foo  2) B=$B:c This is inherit app master's B env variable.  ,
yarn.app.mapreduce.am.command-opts,"Java opts for the MR App Master processes.  The following symbol, if present, will be interpolated: @taskid@ is replaced  by current TaskID. Any other occurrences of '@' will go unchanged.  For example, to enable verbose gc logging to a file named for the taskid in  /tmp and to set the heap maximum to be a gigabyte, pass a 'value' of:  -Xmx1024m -verbose:gc -Xloggc:/tmp/@taskid@.gc  Usage of -Djava.library.path can cause programs to no longer function if  hadoop native libraries are used. These values should instead be set as part  of LD_LIBRARY_PATH in the map / reduce JVM env using the mapreduce.map.env and  mapreduce.reduce.env config settings.  ",-Xmx1024m
yarn.app.mapreduce.am.admin-command-opts,Java opts for the MR App Master processes for admin purposes.  It will appears before the opts set by yarn.app.mapreduce.am.command-opts and  thus its options can be overridden user.  Usage of -Djava.library.path can cause programs to no longer function if  hadoop native libraries are used. These values should instead be set as part  of LD_LIBRARY_PATH in the map / reduce JVM env using the mapreduce.map.env and  mapreduce.reduce.env config settings.  ,
yarn.app.mapreduce.am.job.task.listener.thread-count,The number of threads used to handle RPC calls in the MR AppMaster from remote tasks,30
yarn.app.mapreduce.am.job.client.port-range,"Range of ports that the MapReduce AM can use when binding. Leave blank if you want all possible ports. For example 50000-50050,50100-50200",
yarn.app.mapreduce.am.webapp.port-range,"Range of ports that the MapReduce AM can use for its webapp when binding. Leave blank if you want all possible ports. For example 50000-50050,50100-50200",
yarn.app.mapreduce.am.job.committer.cancel-timeout,The amount of time in milliseconds to wait for the output committer to cancel an operation if the job is killed,60000
yarn.app.mapreduce.am.job.committer.commit-window,"Defines a time window in milliseconds for output commit  operations.  If contact with the RM has occurred within this window then  commits are allowed, otherwise the AM will not allow output commits until  contact with the RM has been re-established.",10000
mapreduce.fileoutputcommitter.algorithm.version,"The file output committer algorithm version  valid algorithm version number: 1 or 2  default to 1, which is the original algorithm  In algorithm version 1,  1. commitTask will rename directory  $joboutput/_temporary/$appAttemptID/_temporary/$taskAttemptID/  to  $joboutput/_temporary/$appAttemptID/$taskID/  2. recoverTask will also do a rename  $joboutput/_temporary/$appAttemptID/$taskID/  to  $joboutput/_temporary/($appAttemptID + 1)/$taskID/  3. commitJob will merge every task output file in  $joboutput/_temporary/$appAttemptID/$taskID/  to  $joboutput/, then it will delete $joboutput/_temporary/  and write $joboutput/_SUCCESS  It has a performance regression, which is discussed in MAPREDUCE-4815.  If a job generates many files to commit then the commitJob  method call at the end of the job can take minutes.  the commit is single-threaded and waits until all  tasks have completed before commencing.  algorithm version 2 will change the behavior of commitTask,  recoverTask, and commitJob.  1. commitTask will rename all files in  $joboutput/_temporary/$appAttemptID/_temporary/$taskAttemptID/  to $joboutput/  2. recoverTask actually doesn't require to do anything, but for  upgrade from version 1 to version 2 case, it will check if there  are any files in  $joboutput/_temporary/($appAttemptID - 1)/$taskID/  and rename them to $joboutput/  3. commitJob can simply delete $joboutput/_temporary and write  $joboutput/_SUCCESS  This algorithm will reduce the output commit time for  large jobs by having the tasks commit directly to the final  output directory as they were completing and commitJob had  very little to do.  ",1
yarn.app.mapreduce.am.scheduler.heartbeat.interval-ms,The interval in ms at which the MR AppMaster should send heartbeats to the ResourceManager,1000
yarn.app.mapreduce.client-am.ipc.max-retries,The number of client retries to the AM - before reconnecting to the RM to fetch Application Status.,3
yarn.app.mapreduce.client-am.ipc.max-retries-on-timeouts,The number of client retries on socket timeouts to the AM - before reconnecting to the RM to fetch Application Status.,3
yarn.app.mapreduce.client.max-retries,The number of client retries to the RM/HS before throwing exception. This is a layer above the ipc.,3
yarn.app.mapreduce.am.resource.mb,The amount of memory the MR AppMaster needs.,1536
yarn.app.mapreduce.am.resource.cpu-vcores,   The number of virtual CPU cores the MR AppMaster needs.  ,1
yarn.app.mapreduce.am.hard-kill-timeout-ms,  Number of milliseconds to wait before the job client kills the application.  ,10000
yarn.app.mapreduce.client.job.max-retries,"The number of retries the client will make for getJob and dependent calls. This is needed for non-HDFS DFS where additional, high level retries are required to avoid spurious failures during the getJob call. 30 is a good value for WASB",3
yarn.app.mapreduce.client.job.retry-interval,The delay between getJob retries in ms for retries configured  with yarn.app.mapreduce.client.job.max-retries.,2000
mapreduce.application.classpath,"CLASSPATH for MR applications. A comma-separated list  of CLASSPATH entries. If mapreduce.application.framework is set then this  must specify the appropriate classpath for that archive, and the name of  the archive must be present in the classpath.  If mapreduce.app-submission.cross-platform is false, platform-specific  environment vairable expansion syntax would be used to construct the default  CLASSPATH entries.  For Linux:  $HADOOP_MAPRED_HOME/share/hadoop/mapreduce/*,  $HADOOP_MAPRED_HOME/share/hadoop/mapreduce/lib/*.  For Windows:  %HADOOP_MAPRED_HOME%/share/hadoop/mapreduce/*,  %HADOOP_MAPRED_HOME%/share/hadoop/mapreduce/lib/*.  If mapreduce.app-submission.cross-platform is true, platform-agnostic default  CLASSPATH for MR applications would be used:  {{HADOOP_MAPRED_HOME}}/share/hadoop/mapreduce/*,  {{HADOOP_MAPRED_HOME}}/share/hadoop/mapreduce/lib/*  Parameter expansion marker will be replaced by NodeManager on container  launch based on the underlying OS accordingly.  ",
mapreduce.app-submission.cross-platform,"If enabled, user can submit an application cross-platform  i.e. submit an application from a Windows client to a Linux/Unix server or  vice versa.  ",false
mapreduce.application.framework.path,"Path to the MapReduce framework archive. If set, the framework archive will automatically be distributed along with the job, and this path would normally reside in a public location in an HDFS filesystem. As with distributed cache files, this can be a URL with a fragment specifying the alias to use for the archive name. For example, hdfs:/mapred/framework/hadoop-mapreduce-2.1.1.tar.gz#mrframework would alias the localized archive as ""mrframework"". Note that mapreduce.application.classpath must include the appropriate classpath for the specified framework. The base name of the archive, or alias of the archive if an alias is used, must appear in the specified classpath.  ",
mapreduce.job.classloader,Whether to use a separate (isolated) classloader for user classes in the task JVM.,false
mapreduce.job.classloader.system.classes,"Used to override the default definition of the system classes for the job classloader. The system classes are a comma-separated list of patterns that indicate whether to load a class from the system classpath, instead from the user-supplied JARs, when mapreduce.job.classloader is enabled. A positive pattern is defined as:  1. A single class name 'C' that matches 'C' and transitively all nested   classes 'C$*' defined in C;  2. A package name ending with a '.' (e.g., ""com.example."") that matches   all classes from that package. A negative pattern is defined by a '-' in front of a positive pattern (e.g., ""-com.example.""). A class is considered a system class if and only if it matches one of the positive patterns and none of the negative ones. More formally: A class is a member of the inclusion set I if it matches one of the positive patterns. A class is a member of the exclusion set E if it matches one of the negative patterns. The set of system classes S = I \ E.  ",
mapreduce.jvm.system-properties-to-log,Comma-delimited list of system properties to log on mapreduce JVM start,"os.name,os.version,java.home,java.runtime.version,java.vendor,java.version,java.vm.name,java.class.path,java.io.tmpdir,user.dir,user.name"
mapreduce.jobhistory.address,MapReduce JobHistory Server IPC host:port,0.0.0.0:10020
mapreduce.jobhistory.webapp.address,MapReduce JobHistory Server Web UI host:port,0.0.0.0:19888
mapreduce.jobhistory.webapp.https.address, The https address the MapReduce JobHistory Server WebApp is on.  ,0.0.0.0:19890
mapreduce.jobhistory.keytab, Location of the kerberos keytab file for the MapReduce JobHistory Server.  ,/etc/security/keytab/jhs.service.keytab
mapreduce.jobhistory.principal, Kerberos principal name for the MapReduce JobHistory Server.  ,jhs/_HOST@REALM.TLD
mapreduce.jobhistory.intermediate-done-dir,,${yarn.app.mapreduce.am.staging-dir}/history/done_intermediate
mapreduce.jobhistory.done-dir,,${yarn.app.mapreduce.am.staging-dir}/history/done
mapreduce.jobhistory.cleaner.enable,,true
mapreduce.jobhistory.cleaner.interval-ms," How often the job history cleaner checks for files to delete,  in milliseconds. Defaults to 86400000 (one day). Files are only deleted if  they are older than mapreduce.jobhistory.max-age-ms.  ",86400000
mapreduce.jobhistory.max-age-ms, Job history files older than this many milliseconds will  be deleted when the history cleaner runs. Defaults to 604800000 (1 week).  ,604800000
mapreduce.jobhistory.client.thread-count,The number of threads to handle client API requests,10
mapreduce.jobhistory.datestring.cache.size,Size of the date string cache. Effects the number of directories  which will be scanned to find a job.,200000
mapreduce.jobhistory.joblist.cache.size,Size of the job list cache,20000
mapreduce.jobhistory.loadedjobs.cache.size,Size of the loaded job cache.  This property is ignored if  the property mapreduce.jobhistory.loadedtasks.cache.size is set to a  positive value.  ,5
mapreduce.jobhistory.loadedtasks.cache.size,"Change the job history cache limit to be set in terms  of total task count.  If the total number of tasks loaded exceeds  this value, then the job cache will be shrunk down until it is  under this limit (minimum 1 job in cache).  If this value is empty  or nonpositive then the cache reverts to using the property  mapreduce.jobhistory.loadedjobs.cache.size as a job cache size.  Two recommendations for the mapreduce.jobhistory.loadedtasks.cache.size  property:  1) For every 100k of cache size, set the heap size of the Job History  Server to 1.2GB. For example,  mapreduce.jobhistory.loadedtasks.cache.size=500000, heap size=6GB.  2) Make sure that the cache size is larger than the number of tasks  required for the largest job run on the cluster. It might be a good  idea to set the value slightly higher (say, 20%) in order to allow  for job size growth.  ",
mapreduce.jobhistory.move.interval-ms,Scan for history files to more from intermediate done dir to done  dir at this frequency.  ,180000
mapreduce.jobhistory.move.thread-count,The number of threads used to move files.,3
mapreduce.jobhistory.store.class,The HistoryStorage class to use to cache history data.,
mapreduce.jobhistory.minicluster.fixed.ports,Whether to use fixed ports with the minicluster,false
mapreduce.jobhistory.admin.address,The address of the History server admin interface.,0.0.0.0:10033
mapreduce.jobhistory.admin.acl,ACL of who can be admin of the History server.,*
mapreduce.jobhistory.recovery.enable,Enable the history server to store server state and recover  server state upon startup.  If enabled then  mapreduce.jobhistory.recovery.store.class must be specified.,false
mapreduce.jobhistory.recovery.store.class,The HistoryServerStateStoreService class to store history server  state for recovery.,org.apache.hadoop.mapreduce.v2.hs.HistoryServerFileSystemStateStoreService
mapreduce.jobhistory.recovery.store.fs.uri,The URI where history server state will be stored if  HistoryServerFileSystemStateStoreService is configured as the recovery  storage class.,${hadoop.tmp.dir}/mapred/history/recoverystore
mapreduce.jobhistory.recovery.store.leveldb.path,The URI where history server state will be stored if  HistoryServerLeveldbSystemStateStoreService is configured as the recovery  storage class.,${hadoop.tmp.dir}/mapred/history/recoverystore
mapreduce.jobhistory.http.policy, This configures the HTTP endpoint for JobHistoryServer web UI. The following values are supported: - HTTP_ONLY : Service is provided only on http - HTTPS_ONLY : Service is provided only on https  ,HTTP_ONLY
mapreduce.jobhistory.jobname.limit,  Number of characters allowed for job name in Job History Server web page.  ,50
mapreduce.jobhistory.jhist.format,"  File format the AM will use when generating the .jhist file.  Valid  values are ""json"" for text output and ""binary"" for faster parsing.  ",json
yarn.app.mapreduce.am.containerlauncher.threadpool-initial-size,The initial size of thread pool to launch containers in the app master.  ,10
mapreduce.task.exit.timeout,"The number of milliseconds before a task will be  terminated if it stays in finishing state for too long.  After a task attempt completes from TaskUmbilicalProtocol's point of view,  it will be transitioned to finishing state. That will give a chance for the  task to exit by itself.  ",60000
mapreduce.task.exit.timeout.check-interval-ms,The interval in milliseconds between which the MR framework  checks if task attempts stay in finishing state for too long.  ,20000
mapreduce.task.local-fs.write-limit.bytes,"Limit on the byte written to the local file system by each task.  This limit only applies to writes that go through the Hadoop filesystem APIs  within the task process (i.e.: writes that will update the local filesystem's  BYTES_WRITTEN counter). It does not cover other writes such as logging,  sideband writes from subprocesses (e.g.: streaming jobs), etc.  Negative values disable the limit.  default is -1",-1
mapreduce.jobhistory.webapp.rest-csrf.enabled, Enable the CSRF filter for the job history web app  ,false
mapreduce.jobhistory.webapp.rest-csrf.custom-header, Optional parameter that indicates the custom header name to use for CSRF protection.  ,X-XSRF-Header
mapreduce.jobhistory.webapp.rest-csrf.methods-to-ignore, Optional parameter that indicates the list of HTTP methods that do not require CSRF protection  ,"GET,OPTIONS,HEAD"
mapreduce.job.cache.limit.max-resources,"The maximum number of resources a map reduce job is allowed to submit for localization via files, libjars, archives, and jobjar command line arguments and through the distributed cache. If set to 0 the limit is ignored.  ",0
mapreduce.job.cache.limit.max-resources-mb,"The maximum size (in MB) a map reduce job is allowed to submit for localization via files, libjars, archives, and jobjar command line arguments and through the distributed cache. If set to 0 the limit is ignored.  ",0
mapreduce.job.cache.limit.max-single-resource-mb,"The maximum size (in MB) of a single resource a map reduce job is allow to submit for localization via files, libjars, archives, and jobjar command line arguments and through the distributed cache. If set to 0 the limit is ignored.  ",0
mapreduce.jobhistory.webapp.xfs-filter.xframe-options, Value of the xframe-options  ,SAMEORIGIN
mapreduce.jobhistory.loadedjob.tasks.max, The maximum number of tasks that a job can have so that the Job History Server will fully parse its associated job history file and load it into memory. A value of -1 (default) will allow all jobs to be loaded.  ,-1
mapreduce.job.redacted-properties, The list of job configuration properties whose value will be redacted.  ,
mapreduce.job.send-token-conf," This configuration is a regex expression. The list of configurations that match the regex expression will be sent to RM. RM will use these configurations for renewing tokens. This configuration is added for below scenario: User needs to run distcp jobs across two clusters, but the RM does not have necessary hdfs configurations to connect to the remote hdfs cluster. Hence, user relies on this config to send the configurations to RM and RM uses these configurations to renew tokens. For example the following regex expression indicates the minimum required configs for RM to connect to a remote hdfs cluster: dfs.nameservices|^dfs.namenode.rpc-address.*$|^dfs.ha.namenodes.*$|^dfs.client.failover.proxy.provider.*$|dfs.namenode.kerberos.principal  ",
yarn.ipc.client.factory.class,Factory to create client IPC classes.,
yarn.ipc.server.factory.class,Factory to create server IPC classes.,
yarn.ipc.record.factory.class,Factory to create serializeable records.,
yarn.ipc.rpc.class,RPC class implementation,org.apache.hadoop.yarn.ipc.HadoopYarnProtoRPC
yarn.resourcemanager.hostname,The hostname of the RM.,0.0.0.0
yarn.resourcemanager.address,The address of the applications manager interface in the RM.,${yarn.resourcemanager.hostname}:8032
yarn.resourcemanager.bind-host,"   The actual address the server will bind to. If this optional address is   set, the RPC and webapp servers will bind to this address and the port specified in   yarn.resourcemanager.address and yarn.resourcemanager.webapp.address, respectively. This   is most useful for making RM listen to all interfaces by setting to 0.0.0.0. ",
yarn.resourcemanager.auto-update.containers,"   If set to true, then ALL container updates will be automatically sent to   the NM in the next heartbeat",false
yarn.resourcemanager.client.thread-count,The number of threads used to handle applications manager requests.,50
yarn.resourcemanager.amlauncher.thread-count,Number of threads used to launch/cleanup AM.,50
yarn.resourcemanager.nodemanager-connect-retries,Retry times to connect with NM.,10
yarn.dispatcher.drain-events.timeout,"Timeout in milliseconds when YARN dispatcher tries to drain the   events. Typically, this happens when service is stopping. e.g. RM drains   the ATS events dispatcher when stopping. ",300000
yarn.am.liveness-monitor.expiry-interval-ms,The expiry interval for application master reporting.,600000
yarn.resourcemanager.principal,The Kerberos principal for the resource manager.,
yarn.resourcemanager.scheduler.address,The address of the scheduler interface.,${yarn.resourcemanager.hostname}:8030
yarn.resourcemanager.scheduler.client.thread-count,Number of threads to handle scheduler interface.,50
yarn.resourcemanager.application-master-service.processors,   Comma separated class names of ApplicationMasterServiceProcessor   implementations. The processors will be applied in the order   they are specified. ,
yarn.http.policy,  This configures the HTTP endpoint for YARN Daemons.The following  values are supported:  - HTTP_ONLY : Service is provided only on http  - HTTPS_ONLY : Service is provided only on https   ,HTTP_ONLY
yarn.resourcemanager.webapp.address,"   The http address of the RM web application.   If only a host is provided as the value,   the webapp will be served on a random port. ",${yarn.resourcemanager.hostname}:8088
yarn.resourcemanager.webapp.https.address,"   The https address of the RM web application.   If only a host is provided as the value,   the webapp will be served on a random port. ",${yarn.resourcemanager.hostname}:8090
yarn.resourcemanager.webapp.spnego-keytab-file, The Kerberos keytab file to be used for spnego filter for the RM web interface. ,
yarn.resourcemanager.webapp.spnego-principal, The Kerberos principal to be used for spnego filter for the RM web interface. ,
yarn.resourcemanager.webapp.ui-actions.enabled, Add button to kill application in the RM Application view. ,true
yarn.webapp.ui2.enable,To enable RM web ui2 application.,false
yarn.webapp.ui2.war-file-path,   Explicitly provide WAR file path for ui2 if needed. ,
yarn.resourcemanager.resource-tracker.address,,${yarn.resourcemanager.hostname}:8031
yarn.acl.enable,Are acls enabled.,false
yarn.acl.reservation-enable,Are reservation acls enabled.,false
yarn.admin.acl,ACL of who can be admin of the YARN cluster.,*
yarn.resourcemanager.admin.address,The address of the RM admin interface.,${yarn.resourcemanager.hostname}:8033
yarn.resourcemanager.admin.client.thread-count,Number of threads used to handle RM admin interface.,1
yarn.resourcemanager.connect.max-wait.ms,Maximum time to wait to establish connection to ResourceManager.,900000
yarn.resourcemanager.connect.retry-interval.ms,How often to try connecting to the ResourceManager.,30000
yarn.resourcemanager.am.max-attempts,"The maximum number of application attempts. It's a global setting for all application masters. Each application master can specify its individual maximum number of application attempts via the API, but the individual number cannot be more than the global upper bound. If it is, the resourcemanager will override it. The default number is set to 2, to allow at least one retry for AM.",2
yarn.resourcemanager.container.liveness-monitor.interval-ms,How often to check that containers are still alive. ,600000
yarn.resourcemanager.keytab,The keytab for the resource manager.,/etc/krb5.keytab
yarn.resourcemanager.webapp.delegation-token-auth-filter.enabled,Flag to enable override of the default kerberos authentication filter with the RM authentication filter to allow authentication using delegation tokens(fallback to kerberos if the tokens are missing). Only applicable when the http authentication type is kerberos.,true
yarn.resourcemanager.webapp.cross-origin.enabled,Flag to enable cross-origin (CORS) support in the RM. This flag requires the CORS filter initializer to be added to the filter initializers list in core-site.xml.,false
yarn.nm.liveness-monitor.expiry-interval-ms,How long to wait until a node manager is considered dead.,600000
yarn.resourcemanager.nodes.include-path,Path to file with nodes to include.,
yarn.resourcemanager.nodes.exclude-path,Path to file with nodes to exclude.,
yarn.resourcemanager.node-ip-cache.expiry-interval-secs,The expiry interval for node IP caching. -1 disables the caching,-1
yarn.resourcemanager.resource-tracker.client.thread-count,Number of threads to handle resource tracker calls.,50
yarn.resourcemanager.scheduler.class,The class to use as the resource scheduler.,org.apache.hadoop.yarn.server.resourcemanager.scheduler.capacity.CapacityScheduler
yarn.scheduler.minimum-allocation-mb,"The minimum allocation for every container request at the RM in MBs. Memory requests lower than this will be set to the value of this property. Additionally, a node manager that is configured to have less memory than this value will be shut down by the resource manager.",1024
yarn.scheduler.maximum-allocation-mb,The maximum allocation for every container request at the RM in MBs. Memory requests higher than this will throw an InvalidResourceRequestException.,8192
yarn.scheduler.minimum-allocation-vcores,"The minimum allocation for every container request at the RM in terms of virtual CPU cores. Requests lower than this will be set to the value of this property. Additionally, a node manager that is configured to have fewer virtual cores than this value will be shut down by the resource manager.",1
yarn.scheduler.maximum-allocation-vcores,The maximum allocation for every container request at the RM in terms of virtual CPU cores. Requests higher than this will throw an InvalidResourceRequestException.,4
yarn.scheduler.include-port-in-node-name," Used by node labels.  If set to true, the port should be included in the node name.  Only usable if your scheduler supports node labels. ",false
yarn.resourcemanager.recovery.enabled,"Enable RM to recover state after starting. If true, then   yarn.resourcemanager.store.class must be specified. ",false
yarn.resourcemanager.fail-fast,"Should RM fail fast if it encounters any errors. By defalt, it   points to ${yarn.fail-fast}. Errors include:   1) exceptions when state-store write/read operations fails. ",${yarn.fail-fast}
yarn.fail-fast,"Should YARN fail fast if it encounters any errors.   This is a global config for all other components including RM,NM etc.   If no value is set for component-specific config (e.g yarn.resourcemanager.fail-fast),   this value will be the default. ",false
yarn.resourcemanager.work-preserving-recovery.enabled,Enable RM work preserving recovery. This configuration is private to YARN for experimenting the feature. ,true
yarn.resourcemanager.work-preserving-recovery.scheduling-wait-ms,"Set the amount of time RM waits before allocating new containers on work-preserving-recovery. Such wait period gives RM a chance to settle down resyncing with NMs in the cluster on recovery, before assigning new containers to applications. ",10000
yarn.resourcemanager.store.class,"The class to use as the persistent store.   If org.apache.hadoop.yarn.server.resourcemanager.recovery.ZKRMStateStore   is used, the store is implicitly fenced; meaning a single ResourceManager   is able to use the store at any point in time. More details on this   implicit fencing, along with setting up appropriate ACLs is discussed   under yarn.resourcemanager.zk-state-store.root-node.acl. ",org.apache.hadoop.yarn.server.resourcemanager.recovery.FileSystemRMStateStore
yarn.resourcemanager.ha.failover-controller.active-standby-elector.zk.retries,"When automatic failover is enabled, number of zookeeper   operation retry times in ActiveStandbyElector",
yarn.resourcemanager.state-store.max-completed-applications,"The maximum number of completed applications RM state store keeps, less than or equals to ${yarn.resourcemanager.max-completed-applications}. By default, it equals to ${yarn.resourcemanager.max-completed-applications}. This ensures that the applications kept in the state store are consistent with the applications remembered in RM memory. Any values larger than ${yarn.resourcemanager.max-completed-applications} will be reset to ${yarn.resourcemanager.max-completed-applications}. Note that this value impacts the RM recovery performance.Typically, a smaller value indicates better performance on RM recovery. ",${yarn.resourcemanager.max-completed-applications}
yarn.resourcemanager.zk-state-store.parent-path,Full path of the ZooKeeper znode where RM state will be stored. This must be supplied when using org.apache.hadoop.yarn.server.resourcemanager.recovery.ZKRMStateStore as the value for yarn.resourcemanager.store.class,/rmstore
yarn.resourcemanager.zk-state-store.root-node.acl,"   ACLs to be used for the root znode when using ZKRMStateStore in an HA   scenario for fencing.   ZKRMStateStore supports implicit fencing to allow a single   ResourceManager write-access to the store. For fencing, the   ResourceManagers in the cluster share read-write-admin privileges on the   root node, but the Active ResourceManager claims exclusive create-delete   permissions.   By default, when this property is not set, we use the ACLs from   yarn.resourcemanager.zk-acl for shared admin access and   rm-address:random-number for username-based exclusive create-delete   access.   This property allows users to set ACLs of their choice instead of using   the default mechanism. For fencing to work, the ACLs should be   carefully set differently on each ResourceManger such that all the   ResourceManagers have shared admin access and the Active ResourceManger   takes over (exclusively) the create-delete access. ",
yarn.resourcemanager.fs.state-store.uri,URI pointing to the location of the FileSystem path where RM state will be stored. This must be supplied when using org.apache.hadoop.yarn.server.resourcemanager.recovery.FileSystemRMStateStore as the value for yarn.resourcemanager.store.class,${hadoop.tmp.dir}/yarn/system/rmstore
yarn.resourcemanager.fs.state-store.retry-policy-spec,"hdfs client retry policy specification. hdfs client retry is always enabled. Specified in pairs of sleep-time and number-of-retries and (t0, n0), (t1, n1), ..., the first n0 retries sleep t0 milliseconds on average, the following n1 retries sleep t1 milliseconds on average, and so on. ","2000, 500"
yarn.resourcemanager.fs.state-store.num-retries,the number of retries to recover from IOException in FileSystemRMStateStore. ,0
yarn.resourcemanager.fs.state-store.retry-interval-ms,Retry interval in milliseconds in FileSystemRMStateStore. ,1000
yarn.resourcemanager.leveldb-state-store.path,Local path where the RM state will be stored when using org.apache.hadoop.yarn.server.resourcemanager.recovery.LeveldbRMStateStore as the value for yarn.resourcemanager.store.class,${hadoop.tmp.dir}/yarn/system/rmstore
yarn.resourcemanager.leveldb-state-store.compaction-interval-secs,The time in seconds between full compactions of the leveldb database. Setting the interval to zero disables the full compaction cycles.,3600
yarn.resourcemanager.ha.enabled,"Enable RM high-availability. When enabled,   (1) The RM starts in the Standby mode by default, and transitions to   the Active mode when prompted to.   (2) The nodes in the RM ensemble are listed in   yarn.resourcemanager.ha.rm-ids   (3) The id of each RM either comes from yarn.resourcemanager.ha.id   if yarn.resourcemanager.ha.id is explicitly specified or can be   figured out by matching yarn.resourcemanager.address.{id} with local address   (4) The actual physical addresses come from the configs of the pattern   - {rpc-config}.{id}",false
yarn.resourcemanager.ha.automatic-failover.enabled,"Enable automatic failover.   By default, it is enabled only when HA is enabled",true
yarn.resourcemanager.ha.automatic-failover.embedded,"Enable embedded automatic failover.   By default, it is enabled only when HA is enabled.   The embedded elector relies on the RM state store to handle fencing,   and is primarily intended to be used in conjunction with ZKRMStateStore. ",true
yarn.resourcemanager.ha.automatic-failover.zk-base-path,"The base znode path to use for storing leader information,   when using ZooKeeper based leader election.",/yarn-leader-election
yarn.resourcemanager.zk-appid-node.split-index,"Index at which last section of application id (with each section   separated by _ in application id) will be split so that application znode   stored in zookeeper RM state store will be stored as two different znodes   (parent-child). Split is done from the end.   For instance, with no split, appid znode will be of the form   application_1352994193343_0001. If the value of this config is 1, the   appid znode will be broken into two parts application_1352994193343_000   and 1 respectively with former being the parent node.   application_1352994193343_0002 will then be stored as 2 under the parent   node application_1352994193343_000. This config can take values from 0 to 4.   0 means there will be no split. If configuration value is outside this   range, it will be treated as config value of 0(i.e. no split). A value   larger than 0 (up to 4) should be configured if you are storing a large number   of apps in ZK based RM state store and state store operations are failing due to   LenError in Zookeeper.",0
yarn.resourcemanager.zk-delegation-token-node.split-index,"Index at which the RM Delegation Token ids will be split so   that the delegation token znodes stored in the zookeeper RM state store   will be stored as two different znodes (parent-child). The split is done   from the end. For instance, with no split, a delegation token znode will   be of the form RMDelegationToken_123456789. If the value of this config is   1, the delegation token znode will be broken into two parts:   RMDelegationToken_12345678 and 9 respectively with former being the parent   node. This config can take values from 0 to 4. 0 means there will be no   split. If the value is outside this range, it will be treated as 0 (i.e.   no split). A value larger than 0 (up to 4) should be configured if you are   running a large number of applications, with long-lived delegation tokens   and state store operations (e.g. failover) are failing due to LenError in   Zookeeper.",0
yarn.resourcemanager.zk-max-znode-size.bytes,Specifies the maximum size of the data that can be stored   in a znode. Value should be same or less than jute.maxbuffer configured   in zookeeper. Default value configured is 1MB.,1048576
yarn.resourcemanager.cluster-id,"Name of the cluster. In a HA setting,   this is used to ensure the RM participates in leader   election for this cluster and ensures it does not affect   other clusters",
yarn.resourcemanager.ha.rm-ids,The list of RM nodes in the cluster when HA is   enabled. See description of yarn.resourcemanager.ha   .enabled for full details on how this is used.,
yarn.resourcemanager.ha.id,"The id (string) of the current RM. When HA is enabled, this   is an optional config. The id of current RM can be set by explicitly   specifying yarn.resourcemanager.ha.id or figured out by matching   yarn.resourcemanager.address.{id} with local address   See description of yarn.resourcemanager.ha.enabled   for full details on how this is used.",
yarn.client.failover-proxy-provider,"When HA is enabled, the class to be used by Clients, AMs and   NMs to failover to the Active RM. It should extend   org.apache.hadoop.yarn.client.RMFailoverProxyProvider",org.apache.hadoop.yarn.client.ConfiguredRMFailoverProxyProvider
yarn.client.failover-max-attempts,"When HA is enabled, the max number of times   FailoverProxyProvider should attempt failover. When set,   this overrides the yarn.resourcemanager.connect.max-wait.ms. When   not set, this is inferred from   yarn.resourcemanager.connect.max-wait.ms.",
yarn.client.failover-sleep-base-ms,"When HA is enabled, the sleep base (in milliseconds) to be   used for calculating the exponential delay between failovers. When set,   this overrides the yarn.resourcemanager.connect.* settings. When   not set, yarn.resourcemanager.connect.retry-interval.ms is used instead. ",
yarn.client.failover-sleep-max-ms,"When HA is enabled, the maximum sleep time (in milliseconds)   between failovers. When set, this overrides the   yarn.resourcemanager.connect.* settings. When not set,   yarn.resourcemanager.connect.retry-interval.ms is used instead.",
yarn.client.failover-retries,"When HA is enabled, the number of retries per   attempt to connect to a ResourceManager. In other words,   it is the ipc.client.connect.max.retries to be used during   failover attempts",0
yarn.client.failover-retries-on-socket-timeouts,"When HA is enabled, the number of retries per   attempt to connect to a ResourceManager on socket timeouts. In other   words, it is the ipc.client.connect.max.retries.on.timeouts to be used   during failover attempts",0
yarn.resourcemanager.max-completed-applications,The maximum number of completed applications RM keeps. ,10000
yarn.resourcemanager.delayed.delegation-token.removal-interval-ms,Interval at which the delayed token removal thread runs,30000
yarn.resourcemanager.delegation-token.max-conf-size-bytes,"Maximum size in bytes for configurations that can be provided   by application to RM for delegation token renewal.   By experiment, it's roughly 128 bytes per key-value pair.   The default value 12800 allows roughly 100 configs, may be less. ",12800
yarn.resourcemanager.proxy-user-privileges.enabled,"If true, ResourceManager will have proxy-user privileges. Use case: In a secure cluster, YARN requires the user hdfs delegation-tokens to do localization and log-aggregation on behalf of the user. If this is set to true, ResourceManager is able to request new hdfs delegation tokens on behalf of the user. This is needed by long-running-service, because the hdfs tokens will eventually expire and YARN requires new valid tokens to do localization and log-aggregation. Note that to enable this use case, the corresponding HDFS NameNode has to configure ResourceManager as the proxy-user so that ResourceManager can itself ask for new tokens on behalf of the user when tokens are past their max-life-time.",false
yarn.resourcemanager.am-rm-tokens.master-key-rolling-interval-secs,Interval for the roll over for the master key used to generate  application tokens ,86400
yarn.resourcemanager.container-tokens.master-key-rolling-interval-secs,Interval for the roll over for the master key used to generate  container tokens. It is expected to be much greater than  yarn.nm.liveness-monitor.expiry-interval-ms and  yarn.resourcemanager.rm.container-allocation.expiry-interval-ms. Otherwise the  behavior is undefined. ,86400
yarn.resourcemanager.nodemanagers.heartbeat-interval-ms,The heart-beat interval in milliseconds for every NodeManager in the cluster.,1000
yarn.resourcemanager.nodemanager.minimum.version,"The minimum allowed version of a connecting nodemanager.  The valid values are   NONE (no version checking), EqualToRM (the nodemanager's version is equal to   or greater than the RM version), or a Version String.",NONE
yarn.resourcemanager.scheduler.monitor.enable,Enable a set of periodic monitors (specified in  yarn.resourcemanager.scheduler.monitor.policies) that affect the  scheduler.,false
yarn.resourcemanager.scheduler.monitor.policies,"The list of SchedulingEditPolicy classes that interact with  the scheduler. A particular module may be incompatible with the  scheduler, other policies, or a configuration of either.",org.apache.hadoop.yarn.server.resourcemanager.monitor.capacity.ProportionalCapacityPreemptionPolicy
yarn.resourcemanager.configuration.provider-class,"The class to use as the configuration provider. If org.apache.hadoop.yarn.LocalConfigurationProvider is used, the local configuration will be loaded. If org.apache.hadoop.yarn.FileSystemBasedConfigurationProvider is used, the configuration which will be loaded should be uploaded to remote File system first. ",org.apache.hadoop.yarn.LocalConfigurationProvider
yarn.resourcemanager.configuration.file-system-based-store, The value specifies the file system (e.g. HDFS) path where ResourceManager loads configuration if yarn.resourcemanager.configuration.provider-class is set to org.apache.hadoop.yarn.FileSystemBasedConfigurationProvider. ,/yarn/conf
yarn.resourcemanager.system-metrics-publisher.enabled,"The setting that controls whether yarn system metrics is published to the Timeline server (version one) or not, by RM. This configuration is now deprecated in favor of yarn.system-metrics-publisher.enabled.",false
yarn.system-metrics-publisher.enabled,The setting that controls whether yarn system metrics is published on the Timeline service or not by RM And NM.,false
yarn.rm.system-metrics-publisher.emit-container-events,The setting that controls whether yarn container events are published to the timeline service or not by RM. This configuration setting is for ATS V2.,false
yarn.resourcemanager.system-metrics-publisher.dispatcher.pool-size,Number of worker threads that send the yarn system metrics data.,10
yarn.resourcemanager.max-log-aggregation-diagnostics-in-memory,Number of diagnostics/failure messages can be saved in RM for log aggregation. It also defines the number of diagnostics/failure messages can be shown in log aggregation web ui.,10
yarn.resourcemanager.delegation-token-renewer.thread-count, RM DelegationTokenRenewer thread count ,50
yarn.resourcemanager.delegation.key.update-interval, RM secret key update interval in ms ,86400000
yarn.resourcemanager.delegation.token.max-lifetime, RM delegation token maximum lifetime in ms ,604800000
yarn.resourcemanager.delegation.token.renew-interval, RM delegation token update interval in ms ,86400000
yarn.resourcemanager.history-writer.multi-threaded-dispatcher.pool-size, Thread pool size for RMApplicationHistoryWriter. ,10
yarn.resourcemanager.metrics.runtime.buckets, Comma-separated list of values (in minutes) for schedule queue related metrics. ,"60,300,1440"
yarn.resourcemanager.nm-tokens.master-key-rolling-interval-secs, Interval for the roll over for the master key used to generate NodeManager tokens.  It is expected to be set to a value much larger than yarn.nm.liveness-monitor.expiry-interval-ms. ,86400
yarn.resourcemanager.reservation-system.enable, Flag to enable the ResourceManager reservation system. ,false
yarn.resourcemanager.reservation-system.class," The Java class to use as the ResourceManager reservation system. By default, is set to org.apache.hadoop.yarn.server.resourcemanager.reservation.CapacityReservationSystem when using CapacityScheduler and is set to org.apache.hadoop.yarn.server.resourcemanager.reservation.FairReservationSystem when using FairScheduler. ",
yarn.resourcemanager.reservation-system.plan.follower," The plan follower policy class name to use for the ResourceManager reservation system. By default, is set to org.apache.hadoop.yarn.server.resourcemanager.reservation.CapacitySchedulerPlanFollower is used when using CapacityScheduler, and is set to org.apache.hadoop.yarn.server.resourcemanager.reservation.FairSchedulerPlanFollower when using FairScheduler. ",
yarn.resourcemanager.reservation-system.planfollower.time-step, Step size of the reservation system in ms ,1000
yarn.resourcemanager.rm.container-allocation.expiry-interval-ms, The expiry interval for a container ,600000
yarn.nodemanager.hostname,The hostname of the NM.,0.0.0.0
yarn.nodemanager.address,The address of the container manager in the NM.,${yarn.nodemanager.hostname}:0
yarn.nodemanager.bind-host,"   The actual address the server will bind to. If this optional address is   set, the RPC and webapp servers will bind to this address and the port specified in   yarn.nodemanager.address and yarn.nodemanager.webapp.address, respectively. This is   most useful for making NM listen to all interfaces by setting to 0.0.0.0. ",
yarn.nodemanager.admin-env,Environment variables that should be forwarded from the NodeManager's environment to the container's.,MALLOC_ARENA_MAX=$MALLOC_ARENA_MAX
yarn.nodemanager.env-whitelist,Environment variables that containers may override rather than use NodeManager's default.,"JAVA_HOME,HADOOP_COMMON_HOME,HADOOP_HDFS_HOME,HADOOP_CONF_DIR,CLASSPATH_PREPEND_DISTCACHE,HADOOP_YARN_HOME"
yarn.nodemanager.container-executor.class,who will execute(launch) the containers.,org.apache.hadoop.yarn.server.nodemanager.DefaultContainerExecutor
yarn.nodemanager.container-state-transition-listener.classes,Comma separated List of container state transition listeners.,
yarn.nodemanager.container-manager.thread-count,Number of threads container manager uses.,20
yarn.nodemanager.collector-service.thread-count,Number of threads collector service uses.,5
yarn.nodemanager.delete.thread-count,Number of threads used in cleanup.,4
yarn.nodemanager.opportunistic-containers-max-queue-length,Max number of OPPORTUNISTIC containers to queue at the   nodemanager.,0
yarn.nodemanager.delete.debug-delay-sec,"   Number of seconds after an application finishes before the nodemanager's    DeletionService will delete the application's localized file directory   and log directory.   To diagnose YARN application problems, set this property's value large   enough (for example, to 600 = 10 minutes) to permit examination of these   directories. After changing the property's value, you must restart the    nodemanager in order for it to have an effect.   The roots of YARN applications' work directories is configurable with   the yarn.nodemanager.local-dirs property (see below), and the roots   of the YARN applications' log directories is configurable with the   yarn.nodemanager.log-dirs property (see also below). ",0
yarn.nodemanager.keytab,Keytab for NM.,/etc/krb5.keytab
yarn.nodemanager.local-dirs,"List of directories to store localized files in. An    application's localized file directory will be found in:   ${yarn.nodemanager.local-dirs}/usercache/${user}/appcache/application_${appid}.   Individual containers' work directories, called container_${contid}, will   be subdirectories of this.   ",${hadoop.tmp.dir}/nm-local-dir
yarn.nodemanager.local-cache.max-files-per-directory,"It limits the maximum number of files which will be localized   in a single local directory. If the limit is reached then sub-directories   will be created and new files will be localized in them. If it is set to   a value less than or equal to 36 [which are sub-directories (0-9 and then   a-z)] then NodeManager will fail to start. For example; [for public   cache] if this is configured with a value of 40 ( 4 files +   36 sub-directories) and the local-dir is ""/tmp/local-dir1"" then it will   allow 4 files to be created directly inside ""/tmp/local-dir1/filecache"".   For files that are localized further it will create a sub-directory ""0""   inside ""/tmp/local-dir1/filecache"" and will localize files inside it   until it becomes full. If a file is removed from a sub-directory that   is marked full, then that sub-directory will be used back again to   localize files.   ",8192
yarn.nodemanager.localizer.address,Address where the localizer IPC is.,${yarn.nodemanager.hostname}:8040
yarn.nodemanager.collector-service.address,Address where the collector service IPC is.,${yarn.nodemanager.hostname}:8048
yarn.nodemanager.localizer.cache.cleanup.interval-ms,Interval in between cache cleanups.,600000
yarn.nodemanager.localizer.cache.target-size-mb,"Target size of localizer cache in MB, per nodemanager. It is   a target retention size that only includes resources with PUBLIC and    PRIVATE visibility and excludes resources with APPLICATION visibility ",10240
yarn.nodemanager.localizer.client.thread-count,Number of threads to handle localization requests.,5
yarn.nodemanager.localizer.fetch.thread-count,Number of threads to use for localization fetching.,4
yarn.nodemanager.container-localizer.java.opts, ,-Xmx256m
yarn.nodemanager.log-dirs,"   Where to store container logs. An application's localized log directory   will be found in ${yarn.nodemanager.log-dirs}/application_${appid}.   Individual containers' log directories will be below this, in directories    named container_{$contid}. Each container directory will contain the files   stderr, stdin, and syslog generated by that container. ",${yarn.log.dir}/userlogs
yarn.nodemanager.default-container-executor.log-dirs.permissions,   The permissions settings used for the creation of container   directories when using DefaultContainerExecutor.  This follows   standard user/group/all permissions format. ,710
yarn.log-aggregation-enable,"Whether to enable log aggregation. Log aggregation collects   each container's logs and moves these logs onto a file-system, for e.g.   HDFS, after the application completes. Users can configure the   ""yarn.nodemanager.remote-app-log-dir"" and   ""yarn.nodemanager.remote-app-log-dir-suffix"" properties to determine   where these logs are moved to. Users can access the logs via the   Application Timeline Server. ",false
yarn.log-aggregation.retain-seconds,How long to keep aggregation logs before deleting them.  -1 disables.  Be careful set this too small and you will spam the name node.,-1
yarn.log-aggregation.retain-check-interval-seconds,How long to wait between aggregated log retention checks. If set to 0 or a negative value then the value is computed as one-tenth of the aggregated log retention time. Be careful set this too small and you will spam the name node.,-1
yarn.log-aggregation.file-formats,"Specify which log file controllers we will support. The first file controller we add will be used to write the aggregated logs. This comma separated configuration will work with the configuration: yarn.log-aggregation.file-controller.%s.class which defines the supported file controller's class. By default, the TFile controller would be used. The user could override this configuration by adding more file controllers. To support back-ward compatibility, make sure that we always add TFile file controller.",TFile
yarn.log-aggregation.file-controller.TFile.class,Class that supports TFile read and write operations.,org.apache.hadoop.yarn.logaggregation.filecontroller.tfile.LogAggregationTFileController
yarn.log-aggregation-status.time-out.ms," How long for ResourceManager to wait for NodeManager to report its log aggregation status. If waiting time of which the log aggregation status is reported from NodeManager exceeds the configured value, RM will report log aggregation status for this NodeManager as TIME_OUT ",600000
yarn.nodemanager.log.retain-seconds,Time in seconds to retain user logs. Only applicable if log aggregation is disabled ,10800
yarn.nodemanager.remote-app-log-dir,Where to aggregate logs to.,/tmp/logs
yarn.nodemanager.remote-app-log-dir-suffix,The remote log dir will be created at    {yarn.nodemanager.remote-app-log-dir}/${user}/{thisParam} ,logs
yarn.nodemanager.log-container-debug-info.enabled,"Generate additional logs about container launches. Currently, this creates a copy of the launch script and lists the directory contents of the container work dir. When listing directory contents, we follow symlinks to a max-depth of 5(including symlinks which point to outside the container work dir) which may lead to a slowness in launching containers. ",false
yarn.nodemanager.resource.memory-mb,"Amount of physical memory, in MB, that can be allocated  for containers. If set to -1 and yarn.nodemanager.resource.detect-hardware-capabilities is true, it is automatically calculated(in case of Windows and Linux). In other cases, the default is 8192MB. ",-1
yarn.nodemanager.resource.system-reserved-memory-mb,"Amount of physical memory, in MB, that is reserved for non-YARN processes. This configuration is only used if yarn.nodemanager.resource.detect-hardware-capabilities is set to true and yarn.nodemanager.resource.memory-mb is -1. If set to -1, this amount is calculated as 20% of (system memory - 2*HADOOP_HEAPSIZE) ",-1
yarn.nodemanager.pmem-check-enabled,Whether physical memory limits will be enforced for containers.,true
yarn.nodemanager.vmem-check-enabled,Whether virtual memory limits will be enforced for containers.,true
yarn.nodemanager.vmem-pmem-ratio,"Ratio between virtual memory to physical memory when setting memory limits for containers. Container allocations are expressed in terms of physical memory, and virtual memory usage is allowed to exceed this allocation by this ratio. ",2.1
yarn.nodemanager.resource.cpu-vcores,"Number of vcores that can be allocated for containers. This is used by the RM scheduler when allocating resources for containers. This is not used to limit the number of CPUs used by YARN containers. If it is set to -1 and yarn.nodemanager.resource.detect-hardware-capabilities is true, it is automatically determined from the hardware in case of Windows and Linux. In other cases, number of vcores is 8 by default.",-1
yarn.nodemanager.resource.count-logical-processors-as-cores,Flag to determine if logical processors(such as hyperthreads) should be counted as cores. Only applicable on Linux when yarn.nodemanager.resource.cpu-vcores is set to -1 and yarn.nodemanager.resource.detect-hardware-capabilities is true. ,false
yarn.nodemanager.resource.pcores-vcores-multiplier,Multiplier to determine how to convert phyiscal cores to vcores. This value is used if yarn.nodemanager.resource.cpu-vcores is set to -1(which implies auto-calculate vcores) and yarn.nodemanager.resource.detect-hardware-capabilities is set to true. The number of vcores will be calculated as number of CPUs * multiplier. ,1.0
yarn.nodemanager.logaggregation.threadpool-size-max, Thread pool size for LogAggregationService in Node Manager. ,100
yarn.nodemanager.resource.percentage-physical-cpu-limit,Percentage of CPU that can be allocated for containers. This setting allows users to limit the amount of CPU that YARN containers use. Currently functional only on Linux using cgroups. The default is to use 100% of CPU. ,100
yarn.nodemanager.resource.detect-hardware-capabilities,Enable auto-detection of node capabilities such as memory and CPU. ,false
yarn.nodemanager.webapp.address,NM Webapp address.,${yarn.nodemanager.hostname}:8042
yarn.nodemanager.webapp.https.address, The https adddress of the NM web application. ,0.0.0.0:8044
yarn.nodemanager.webapp.spnego-keytab-file, The Kerberos keytab file to be used for spnego filter for the NM web interface. ,
yarn.nodemanager.webapp.spnego-principal, The Kerberos principal to be used for spnego filter for the NM web interface. ,
yarn.nodemanager.resource-monitor.interval-ms,"How often to monitor the node and the containers. If 0 or negative, monitoring is disabled.",3000
yarn.nodemanager.resource-calculator.class,Class that calculates current resource utilization.,
yarn.nodemanager.container-monitor.enabled,Enable container monitor,true
yarn.nodemanager.container-monitor.interval-ms,"How often to monitor containers. If not set, the value for yarn.nodemanager.resource-monitor.interval-ms will be used. If 0 or negative, container monitoring is disabled.",
yarn.nodemanager.container-monitor.resource-calculator.class,"Class that calculates containers current resource utilization. If not set, the value for yarn.nodemanager.resource-calculator.class will be used.",
yarn.nodemanager.health-checker.interval-ms,Frequency of running node health script.,600000
yarn.nodemanager.health-checker.script.timeout-ms,Script time out period.,1200000
yarn.nodemanager.health-checker.script.path,The health check script to run.,
yarn.nodemanager.health-checker.script.opts,The arguments to pass to the health check script.,
yarn.nodemanager.disk-health-checker.interval-ms,Frequency of running disk health checker code.,120000
yarn.nodemanager.disk-health-checker.min-healthy-disks,"The minimum fraction of number of disks to be healthy for the nodemanager to launch new containers. This correspond to both yarn.nodemanager.local-dirs and yarn.nodemanager.log-dirs. i.e. If there are less number of healthy local-dirs (or log-dirs) available, then new containers will not be launched on this node.",0.25
yarn.nodemanager.disk-health-checker.max-disk-utilization-per-disk-percentage,"The maximum percentage of disk space utilization allowed after  which a disk is marked as bad. Values can range from 0.0 to 100.0.  If the value is greater than or equal to 100, the nodemanager will check  for full disk. This applies to yarn.nodemanager.local-dirs and yarn.nodemanager.log-dirs.",90.0
yarn.nodemanager.disk-health-checker.disk-utilization-watermark-low-per-disk-percentage,"The low threshold percentage of disk space used when a bad disk is marked as good. Values can range from 0.0 to 100.0. This applies to yarn.nodemanager.local-dirs and yarn.nodemanager.log-dirs. Note that if its value is more than yarn.nodemanager.disk-health-checker. max-disk-utilization-per-disk-percentage or not set, it will be set to the same value as yarn.nodemanager.disk-health-checker.max-disk-utilization-per-disk-percentage.",
yarn.nodemanager.disk-health-checker.min-free-space-per-disk-mb,The minimum space that must be available on a disk for it to be used. This applies to yarn.nodemanager.local-dirs and yarn.nodemanager.log-dirs.,0
yarn.nodemanager.linux-container-executor.path,The path to the Linux container executor.,
yarn.nodemanager.linux-container-executor.resources-handler.class,The class which should help the LCE handle resources.,org.apache.hadoop.yarn.server.nodemanager.util.DefaultLCEResourcesHandler
yarn.nodemanager.linux-container-executor.cgroups.hierarchy,"The cgroups hierarchy under which to place YARN proccesses (cannot contain commas). If yarn.nodemanager.linux-container-executor.cgroups.mount is false (that is, if cgroups have been pre-configured) and the YARN user has write access to the parent directory, then the directory will be created. If the directory already exists, the administrator has to give YARN write permissions to it recursively. This property only applies when the LCE resources handler is set to CgroupsLCEResourcesHandler.",/hadoop-yarn
yarn.nodemanager.linux-container-executor.cgroups.mount,Whether the LCE should attempt to mount cgroups if not found. This property only applies when the LCE resources handler is set to CgroupsLCEResourcesHandler. ,false
yarn.nodemanager.linux-container-executor.cgroups.mount-path,"This property sets the path from which YARN will read the CGroups configuration. YARN has built-in functionality to discover the system CGroup mount paths, so use this property only if YARN's automatic mount path discovery does not work. The path specified by this property must exist before the NodeManager is launched. If yarn.nodemanager.linux-container-executor.cgroups.mount is set to true, YARN will first try to mount the CGroups at the specified path before reading them. If yarn.nodemanager.linux-container-executor.cgroups.mount is set to false, YARN will read the CGroups at the specified path. If this property is empty, YARN tries to detect the CGroups location. Please refer to NodeManagerCgroups.html in the documentation for further details. This property only applies when the LCE resources handler is set to CgroupsLCEResourcesHandler. ",
yarn.nodemanager.linux-container-executor.cgroups.delete-delay-ms,Delay in ms between attempts to remove linux cgroup,20
yarn.nodemanager.linux-container-executor.nonsecure-mode.limit-users,"This determines which of the two modes that LCE should use on   a non-secure cluster.  If this value is set to true, then all containers   will be launched as the user specified in   yarn.nodemanager.linux-container-executor.nonsecure-mode.local-user.  If   this value is set to false, then containers will run as the user who   submitted the application.",true
yarn.nodemanager.linux-container-executor.nonsecure-mode.local-user,The UNIX user that containers will run as when   Linux-container-executor is used in nonsecure mode (a use case for this   is using cgroups) if the   yarn.nodemanager.linux-container-executor.nonsecure-mode.limit-users is   set to true.,nobody
yarn.nodemanager.linux-container-executor.nonsecure-mode.user-pattern,The allowed pattern for UNIX user names enforced by Linux-container-executor when used in nonsecure mode (use case for this is using cgroups). The default value is taken from /usr/sbin/adduser,"^[_.A-Za-z0-9][-@_.A-Za-z0-9]{0,255}?[$]?$"
yarn.nodemanager.linux-container-executor.cgroups.strict-resource-usage,"This flag determines whether apps should run with strict resource limits or be allowed to consume spare resources if they need them. For example, turning the flag on will restrict apps to use only their share of CPU, even if the node has spare CPU cycles. The default value is false i.e. use available resources. Please note that turning this flag on may reduce job throughput on the cluster.",false
yarn.nodemanager.runtime.linux.allowed-runtimes,Comma separated list of runtimes that are allowed when using LinuxContainerExecutor. The allowed values are default and docker. ,default
yarn.nodemanager.runtime.linux.docker.capabilities,"This configuration setting determines the capabilities   assigned to docker containers when they are launched. While these may not   be case-sensitive from a docker perspective, it is best to keep these   uppercase. To run without any capabilites, set this value to   ""none"" or ""NONE""","CHOWN,DAC_OVERRIDE,FSETID,FOWNER,MKNOD,NET_RAW,SETGID,SETUID,SETFCAP,SETPCAP,NET_BIND_SERVICE,SYS_CHROOT,KILL,AUDIT_WRITE"
yarn.nodemanager.runtime.linux.docker.privileged-containers.allowed,This configuration setting determines if   privileged docker containers are allowed on this cluster.   Use with extreme care.,false
yarn.nodemanager.runtime.linux.docker.privileged-containers.acl,This configuration setting determines who is allowed to run   privileged docker containers on this cluster. Use with extreme care. ,
yarn.nodemanager.runtime.linux.docker.allowed-container-networks,The set of networks allowed when launching containers using the   DockerContainerRuntime.,"host,none,bridge"
yarn.nodemanager.runtime.linux.docker.default-container-network,The network used when launching containers using the   DockerContainerRuntime when no network is specified in the request   . This network must be one of the (configurable) set of allowed container   networks.,host
yarn.nodemanager.runtime.linux.docker.enable-userremapping.allowed,Property to enable docker user remapping,true
yarn.nodemanager.runtime.linux.docker.userremapping-uid-threshold,lower limit for acceptable uids of user remapped user,1
yarn.nodemanager.runtime.linux.docker.userremapping-gid-threshold,lower limit for acceptable gids of user remapped user,1
yarn.nodemanager.windows-container.memory-limit.enabled,This flag determines whether memory limit will be set for the Windows Job Object of the containers launched by the default container executor.,false
yarn.nodemanager.windows-container.cpu-limit.enabled,This flag determines whether CPU limit will be set for the Windows Job Object of the containers launched by the default container executor.,false
yarn.nodemanager.linux-container-executor.cgroups.delete-timeout-ms, Interval of time the linux container executor should try cleaning up cgroups entry when cleaning up a container. ,1000
yarn.nodemanager.linux-container-executor.group, The UNIX group that the linux-container-executor should run as. ,
yarn.nodemanager.log-aggregation.compression-type,T-file compression types used to compress aggregated logs.,none
yarn.nodemanager.principal,The kerberos principal for the node manager.,
yarn.nodemanager.aux-services,A comma separated list of services where service name should only   contain a-zA-Z0-9_ and can not start with numbers,
yarn.nodemanager.sleep-delay-before-sigkill.ms,No. of ms to wait between sending a SIGTERM and SIGKILL to a container,250
yarn.nodemanager.process-kill-wait.ms,Max time to wait for a process to come up when trying to cleanup a container,2000
yarn.nodemanager.resourcemanager.minimum.version,"The minimum allowed version of a resourcemanager that a nodemanager will connect to.  The valid values are NONE (no version checking), EqualToNM (the resourcemanager's version is    equal to or greater than the NM version), or a Version String.",NONE
yarn.nodemanager.container-diagnostics-maximum-size,Maximum size of contain's diagnostics to keep for relaunching   container case.,10000
yarn.nodemanager.container-retry-minimum-interval-ms,Minimum container restart interval in milliseconds.,1000
yarn.client.nodemanager-client-async.thread-pool-max-size,Max number of threads in NMClientAsync to process container management events,500
yarn.client.nodemanager-connect.max-wait-ms,Max time to wait to establish a connection to NM,180000
yarn.client.nodemanager-connect.retry-interval-ms,Time interval between each attempt to connect to NM,10000
yarn.nodemanager.resourcemanager.connect.max-wait.ms,"   Max time to wait for NM to connect to RM.   When not set, proxy will fall back to use value of   yarn.resourcemanager.connect.max-wait.ms. ",
yarn.nodemanager.resourcemanager.connect.retry-interval.ms,"   Time interval between each NM attempt to connect to RM.   When not set, proxy will fall back to use value of   yarn.resourcemanager.connect.retry-interval.ms. ",
yarn.client.max-cached-nodemanagers-proxies,   Maximum number of proxy connections to cache for node managers. If set   to a value greater than zero then the cache is enabled and the NMClient   and MRAppMaster will cache the specified number of node manager proxies.   There will be at max one proxy per node manager. Ex. configuring it to a   value of 5 will make sure that client will at max have 5 proxies cached   with 5 different node managers. These connections for these proxies will   be timed out if idle for more than the system wide idle timeout period.   Note that this could cause issues on large clusters as many connections   could linger simultaneously and lead to a large number of connection   threads. The token used for authentication will be used only at   connection creation time. If a new token is received then the earlier   connection should be closed in order to use the new token. This and   (yarn.client.nodemanager-client-async.thread-pool-max-size) are related   and should be in sync (no need for them to be equal).   If the value of this property is zero then the connection cache is   disabled and connections will use a zero idle timeout to prevent too   many connection threads on large clusters. ,0
yarn.nodemanager.recovery.enabled,Enable the node manager to recover after starting,false
yarn.nodemanager.recovery.dir,The local filesystem directory in which the node manager will store state when recovery is enabled.,${hadoop.tmp.dir}/yarn-nm-recovery
yarn.nodemanager.recovery.compaction-interval-secs,The time in seconds between full compactions of the NM state database. Setting the interval to zero disables the full compaction cycles.,3600
yarn.nodemanager.recovery.supervised,Whether the nodemanager is running under supervision. A   nodemanager that supports recovery and is running under supervision   will not try to cleanup containers as it exits with the assumption   it will be immediately be restarted and recover containers.,false
yarn.nodemanager.container-executor.os.sched.priority.adjustment," Adjustment to the container OS scheduling priority.  In Linux, passed directly to the nice command. If unspecified then containers are launched without any explicit OS priority. ",
yarn.nodemanager.container-metrics.enable, Flag to enable container metrics ,true
yarn.nodemanager.container-metrics.period-ms, Container metrics flush period in ms.  Set to -1 for flush on completion. ,-1
yarn.nodemanager.container-metrics.unregister-delay-ms, The delay time ms to unregister container metrics after completion. ,10000
yarn.nodemanager.container-monitor.process-tree.class, Class used to calculate current container resource utilization. ,
yarn.nodemanager.disk-health-checker.enable, Flag to enable NodeManager disk health checker ,true
yarn.nodemanager.log.deletion-threads-count, Number of threads to use in NM log cleanup.  Used when log aggregation is disabled. ,4
yarn.nodemanager.windows-secure-container-executor.group, The Windows group that the windows-container-executor should run as. ,
yarn.nodemanager.docker-container-executor.exec-name,   Name or path to the Docker client. ,/usr/bin/docker
yarn.nodemanager.docker-container-executor.image-name, The Docker image name to use for DockerContainerExecutor ,
yarn.nodemanager.aux-services.mapreduce_shuffle.class,,org.apache.hadoop.mapred.ShuffleHandler
yarn.web-proxy.principal,"The kerberos principal for the proxy, if the proxy is not running as part of the RM.",
yarn.web-proxy.keytab,"Keytab for WebAppProxy, if the proxy is not running as part of  the RM.",
yarn.web-proxy.address,"The address for the web proxy as HOST:PORT, if this is not  given then the proxy will run as part of the RM",
yarn.application.classpath,"   CLASSPATH for YARN applications. A comma-separated list   of CLASSPATH entries. When this value is empty, the following default   CLASSPATH for YARN applications would be used.    For Linux:   $HADOOP_CONF_DIR,   $HADOOP_COMMON_HOME/share/hadoop/common/*,   $HADOOP_COMMON_HOME/share/hadoop/common/lib/*,   $HADOOP_HDFS_HOME/share/hadoop/hdfs/*,   $HADOOP_HDFS_HOME/share/hadoop/hdfs/lib/*,   $HADOOP_YARN_HOME/share/hadoop/yarn/*,   $HADOOP_YARN_HOME/share/hadoop/yarn/lib/*   For Windows:   %HADOOP_CONF_DIR%,   %HADOOP_COMMON_HOME%/share/hadoop/common/*,   %HADOOP_COMMON_HOME%/share/hadoop/common/lib/*,   %HADOOP_HDFS_HOME%/share/hadoop/hdfs/*,   %HADOOP_HDFS_HOME%/share/hadoop/hdfs/lib/*,   %HADOOP_YARN_HOME%/share/hadoop/yarn/*,   %HADOOP_YARN_HOME%/share/hadoop/yarn/lib/* ",
yarn.timeline-service.version,"Indicate what is the current version of the running timeline service. For example, if ""yarn.timeline-service.version"" is 1.5, and ""yarn.timeline-service.enabled"" is true, it means the cluster will and should bring up the timeline service v.1.5 (and nothing else). On the client side, if the client uses the same version of timeline service, it should succeed. If the client chooses to use a smaller version in spite of this, then depending on how robust the compatibility story is between versions, the results may vary. ",1.0f
yarn.timeline-service.enabled," In the server side it indicates whether timeline service is enabled or not. And in the client side, users can enable it to indicate whether client wants to use timeline service. If it's enabled in the client side along with security, then yarn client tries to fetch the delegation tokens for the timeline server. ",false
yarn.timeline-service.hostname,The hostname of the timeline service web application.,0.0.0.0
yarn.timeline-service.address,This is default address for the timeline server to start the RPC server.,${yarn.timeline-service.hostname}:10200
yarn.timeline-service.webapp.address,The http address of the timeline service web application.,${yarn.timeline-service.hostname}:8188
yarn.timeline-service.webapp.https.address,The https address of the timeline service web application.,${yarn.timeline-service.hostname}:8190
yarn.timeline-service.bind-host,"   The actual address the server will bind to. If this optional address is   set, the RPC and webapp servers will bind to this address and the port specified in   yarn.timeline-service.address and yarn.timeline-service.webapp.address, respectively.   This is most useful for making the service listen to all interfaces by setting to   0.0.0.0. ",
yarn.timeline-service.generic-application-history.max-applications,   Defines the max number of applications could be fetched using REST API or   application history protocol and shown in timeline server web ui. ,10000
yarn.timeline-service.store-class,Store class name for timeline store.,org.apache.hadoop.yarn.server.timeline.LeveldbTimelineStore
yarn.timeline-service.ttl-enable,Enable age off of timeline store data.,true
yarn.timeline-service.ttl-ms,Time to live for timeline store data in milliseconds.,604800000
yarn.timeline-service.leveldb-timeline-store.path,Store file name for leveldb timeline store.,${hadoop.tmp.dir}/yarn/timeline
yarn.timeline-service.leveldb-timeline-store.ttl-interval-ms,Length of time to wait between deletion cycles of leveldb timeline store in milliseconds.,300000
yarn.timeline-service.leveldb-timeline-store.read-cache-size,Size of read cache for uncompressed blocks for leveldb timeline store in bytes.,104857600
yarn.timeline-service.leveldb-timeline-store.start-time-read-cache-size,Size of cache for recently read entity start times for leveldb timeline store in number of entities.,10000
yarn.timeline-service.leveldb-timeline-store.start-time-write-cache-size,Size of cache for recently written entity start times for leveldb timeline store in number of entities.,10000
yarn.timeline-service.handler-thread-count,Handler thread count to serve the client RPC requests.,10
yarn.timeline-service.http-authentication.type,   Defines authentication used for the timeline server HTTP endpoint.   Supported values are: simple | kerberos | #AUTHENTICATION_HANDLER_CLASSNAME# ,simple
yarn.timeline-service.http-authentication.simple.anonymous.allowed,   Indicates if anonymous requests are allowed by the timeline server when using   'simple' authentication. ,true
yarn.timeline-service.principal,The Kerberos principal for the timeline server.,
yarn.timeline-service.keytab,The Kerberos keytab for the timeline server.,/etc/krb5.keytab
yarn.timeline-service.ui-names,Comma separated list of UIs that will be hosted,
yarn.timeline-service.client.max-retries, Default maximum number of retries for timeline service client and value -1 means no limit. ,30
yarn.timeline-service.client.best-effort,"Client policy for whether timeline operations are non-fatal. Should the failure to obtain a delegation token be considered an application failure (option = false),  or should the client attempt to continue to publish information without it (option=true)",false
yarn.timeline-service.client.retry-interval-ms, Default retry time interval for timeline servive client. ,1000
yarn.timeline-service.client.drain-entities.timeout.ms, The time period for which timeline v2 client will wait for draining leftover entities after stop. ,2000
yarn.timeline-service.recovery.enabled,"Enable timeline server to recover state after starting. If true, then yarn.timeline-service.state-store-class must be specified. ",false
yarn.timeline-service.state-store-class,Store class name for timeline state store.,org.apache.hadoop.yarn.server.timeline.recovery.LeveldbTimelineStateStore
yarn.timeline-service.leveldb-state-store.path,Store file name for leveldb state store.,${hadoop.tmp.dir}/yarn/timeline
yarn.timeline-service.entity-group-fs-store.cache-store-class,Caching storage timeline server v1.5 is using. ,org.apache.hadoop.yarn.server.timeline.MemoryTimelineStore
yarn.timeline-service.entity-group-fs-store.active-dir,HDFS path to store active application’s timeline data,/tmp/entity-file-history/active
yarn.timeline-service.entity-group-fs-store.done-dir,HDFS path to store done application’s timeline data,/tmp/entity-file-history/done/
yarn.timeline-service.entity-group-fs-store.group-id-plugin-classes,"   Plugins that can translate a timeline entity read request into   a list of timeline entity group ids, separated by commas. ",
yarn.timeline-service.entity-group-fs-store.group-id-plugin-classpath,   Classpath for all plugins defined in   yarn.timeline-service.entity-group-fs-store.group-id-plugin-classes. ,
yarn.timeline-service.entity-group-fs-store.summary-store,Summary storage for ATS v1.5,org.apache.hadoop.yarn.server.timeline.LeveldbTimelineStore
yarn.timeline-service.entity-group-fs-store.scan-interval-seconds,   Scan interval for ATS v1.5 entity group file system storage reader.This   value controls how frequent the reader will scan the HDFS active directory   for application status. ,60
yarn.timeline-service.entity-group-fs-store.cleaner-interval-seconds,   Scan interval for ATS v1.5 entity group file system storage cleaner.This   value controls how frequent the reader will scan the HDFS done directory   for stale application data. ,3600
yarn.timeline-service.entity-group-fs-store.retain-seconds,   How long the ATS v1.5 entity group file system storage will keep an   application's data in the done directory. ,604800
yarn.timeline-service.entity-group-fs-store.leveldb-cache-read-cache-size,   Read cache size for the leveldb cache storage in ATS v1.5 plugin storage. ,10485760
yarn.timeline-service.entity-group-fs-store.app-cache-size,"   Size of the reader cache for ATS v1.5 reader. This value controls how many   entity groups the ATS v1.5 server should cache. If the number of active   read entity groups is greater than the number of caches items, some reads   may return empty data. This value must be greater than 0. ",10
yarn.timeline-service.client.fd-flush-interval-secs,   Flush interval for ATS v1.5 writer. This value controls how frequent   the writer will flush the HDFS FSStream for the entity/domain. ,10
yarn.timeline-service.client.fd-clean-interval-secs,"   Scan interval for ATS v1.5 writer. This value controls how frequent   the writer will scan the HDFS FSStream for the entity/domain.   If the FSStream is stale for a long time, this FSStream will be close. ",60
yarn.timeline-service.client.fd-retain-secs,"   How long the ATS v1.5 writer will keep an FSStream open.   If this fsstream does not write anything for this configured time,   it will be close. ",300
yarn.timeline-service.writer.class,   Storage implementation ATS v2 will use for the TimelineWriter service. ,org.apache.hadoop.yarn.server.timelineservice.storage.HBaseTimelineWriterImpl
yarn.timeline-service.reader.class,   Storage implementation ATS v2 will use for the TimelineReader service. ,org.apache.hadoop.yarn.server.timelineservice.storage.HBaseTimelineReaderImpl
yarn.timeline-service.client.internal-timers-ttl-secs,"   How long the internal Timer Tasks can be alive in writer. If there is no   write operation for this configured time, the internal timer tasks will   be close. ",420
yarn.timeline-service.writer.flush-interval-seconds,The setting that controls how often the timeline collector flushes the timeline writer.,60
yarn.timeline-service.app-collector.linger-period.ms,"Time period till which the application collector will be alive  in NM, after the  application master container finishes.",1000
yarn.timeline-service.timeline-client.number-of-async-entities-to-merge,Time line V2 client tries to merge these many number of async entities (if available) and then call the REST ATS V2 API to submit. ,10
"yarn.timeline-service.hbase.coprocessor.app-final-value-retention-milliseconds
    ", The setting that controls how long the final value of a metric of a completed app is retained before merging into the flow sum. Up to this time after an application is completed out-of-order values that arrive can be recognized and discarded at the cost of increased storage. ,259200000
"yarn.timeline-service.hbase.coprocessor.jar.hdfs.location
    ", The default hdfs location for flowrun coprocessor jar. ,/hbase/coprocessor/hadoop-yarn-server-timelineservice.jar
yarn.timeline-service.hbase-schema.prefix," The value of this parameter sets the prefix for all tables that are part of timeline service in the hbase storage schema. It can be set to ""dev."" or ""staging."" if it is to be used for development or staging instances. This way the data in production tables stays in a separate set of tables prefixed by ""prod."". ",prod.
"yarn.timeline-service.hbase.configuration.file
    "," Optional URL to an hbase-site.xml configuration file to be used to connect to the timeline-service hbase cluster. If empty or not specified, then the HBase configuration will be loaded from the classpath. When specified the values in the specified configuration file will override those from the ones that are present on the classpath. ",
yarn.sharedcache.enabled,Whether the shared cache is enabled,false
yarn.sharedcache.root-dir,The root directory for the shared cache,/sharedcache
yarn.sharedcache.nested-level,The level of nested directories before getting to the checksum directories. It must be non-negative.,3
yarn.sharedcache.store.class,The implementation to be used for the SCM store,org.apache.hadoop.yarn.server.sharedcachemanager.store.InMemorySCMStore
yarn.sharedcache.app-checker.class,The implementation to be used for the SCM app-checker,org.apache.hadoop.yarn.server.sharedcachemanager.RemoteAppChecker
yarn.sharedcache.store.in-memory.staleness-period-mins,A resource in the in-memory store is considered stale if the time since the last reference exceeds the staleness period. This value is specified in minutes.,10080
yarn.sharedcache.store.in-memory.initial-delay-mins,Initial delay before the in-memory store runs its first check to remove dead initial applications. Specified in minutes.,10
yarn.sharedcache.store.in-memory.check-period-mins,The frequency at which the in-memory store checks to remove dead initial applications. Specified in minutes.,720
yarn.sharedcache.admin.address,The address of the admin interface in the SCM (shared cache manager),0.0.0.0:8047
yarn.sharedcache.admin.thread-count,The number of threads used to handle SCM admin interface (1 by default),1
yarn.sharedcache.webapp.address,The address of the web application in the SCM (shared cache manager),0.0.0.0:8788
yarn.sharedcache.cleaner.period-mins,The frequency at which a cleaner task runs. Specified in minutes.,1440
yarn.sharedcache.cleaner.initial-delay-mins,Initial delay before the first cleaner task is scheduled. Specified in minutes.,10
yarn.sharedcache.cleaner.resource-sleep-ms,The time to sleep between processing each shared cache resource. Specified in milliseconds.,0
yarn.sharedcache.uploader.server.address,The address of the node manager interface in the SCM (shared cache manager),0.0.0.0:8046
yarn.sharedcache.uploader.server.thread-count,The number of threads used to handle shared cache manager requests from the node manager (50 by default),50
yarn.sharedcache.client-server.address,The address of the client interface in the SCM (shared cache manager),0.0.0.0:8045
yarn.sharedcache.client-server.thread-count,The number of threads used to handle shared cache manager requests from clients (50 by default),50
yarn.sharedcache.checksum.algo.impl,The algorithm used to compute checksums of files (SHA-256 by default),org.apache.hadoop.yarn.sharedcache.ChecksumSHA256Impl
yarn.sharedcache.nm.uploader.replication.factor,The replication factor for the node manager uploader for the shared cache (10 by default),10
yarn.sharedcache.nm.uploader.thread-count,The number of threads used to upload files from a node manager instance (20 by default),20
security.applicationhistory.protocol.acl, ACL protocol for use in the Timeline server. ,
yarn.is.minicluster, Set to true for MiniYARNCluster unit tests ,false
yarn.minicluster.control-resource-monitoring, Set for MiniYARNCluster unit tests to control resource monitoring ,false
yarn.minicluster.fixed.ports, Set to false in order to allow MiniYARNCluster to run tests without port conflicts. ,false
yarn.minicluster.use-rpc, Set to false in order to allow the NodeManager in MiniYARNCluster to use RPC to talk to the RM. ,false
yarn.minicluster.yarn.nodemanager.resource.memory-mb, As yarn.nodemanager.resource.memory-mb property but for the NodeManager in a MiniYARNCluster. ,4096
yarn.node-labels.enabled, Enable node labels feature ,false
yarn.node-labels.fs-store.retry-policy-spec," Retry policy used for FileSystem node label store. The policy is specified by N pairs of sleep-time in milliseconds and number-of-retries ""s1,n1,s2,n2,..."". ","2000, 500"
yarn.node-labels.fs-store.root-dir, URI for NodeLabelManager.  The default value is /tmp/hadoop-yarn-${user}/node-labels/ in the local filesystem. ,
yarn.node-labels.configuration-type," Set configuration type for node labels. Administrators can specify ""centralized"", ""delegated-centralized"" or ""distributed"". ",centralized
yarn.nodemanager.node-labels.provider," When ""yarn.node-labels.configuration-type"" is configured with ""distributed"" in RM, Administrators can configure in NM the provider for the node labels by configuring this parameter. Administrators can configure ""config"", ""script"" or the class name of the provider. Configured class needs to extend org.apache.hadoop.yarn.server.nodemanager.nodelabels.NodeLabelsProvider. If ""config"" is configured, then ""ConfigurationNodeLabelsProvider"" and if ""script"" is configured, then ""ScriptNodeLabelsProvider"" will be used. ",
yarn.nodemanager.node-labels.provider.fetch-interval-ms," When ""yarn.nodemanager.node-labels.provider"" is configured with ""config"", ""Script"" or the configured class extends AbstractNodeLabelsProvider, then periodically node labels are retrieved from the node labels provider. This configuration is to define the interval period. If -1 is configured then node labels are retrieved from provider only during initialization. Defaults to 10 mins. ",600000
yarn.nodemanager.node-labels.resync-interval-ms,"   Interval at which NM syncs its node labels with RM. NM will send its loaded   labels every x intervals configured, along with heartbeat to RM. ",120000
yarn.nodemanager.node-labels.provider.configured-node-partition," When ""yarn.nodemanager.node-labels.provider"" is configured with ""config"" then ConfigurationNodeLabelsProvider fetches the partition label from this parameter. ",
yarn.nodemanager.node-labels.provider.fetch-timeout-ms," When ""yarn.nodemanager.node-labels.provider"" is configured with ""Script"" then this configuration provides the timeout period after which it will interrupt the script which queries the Node labels. Defaults to 20 mins. ",1200000
yarn.resourcemanager.node-labels.provider," When node labels ""yarn.node-labels.configuration-type"" is of type ""delegated-centralized"", administrators should configure the class for fetching node labels by ResourceManager. Configured class needs to extend org.apache.hadoop.yarn.server.resourcemanager.nodelabels. RMNodeLabelsMappingProvider. ",
yarn.resourcemanager.node-labels.provider.fetch-interval-ms," When ""yarn.node-labels.configuration-type"" is configured with ""delegated-centralized"", then periodically node labels are retrieved from the node labels provider. This configuration is to define the interval. If -1 is configured then node labels are retrieved from provider only once for each node after it registers. Defaults to 30 mins. ",1800000
yarn.resourcemanager.nodemanager-graceful-decommission-timeout-secs, Timeout in seconds for YARN node graceful decommission. This is the maximal time to wait for running containers and applications to complete before transition a DECOMMISSIONING node into DECOMMISSIONED. ,3600
yarn.resourcemanager.decommissioning-nodes-watcher.poll-interval-secs, Timeout in seconds of DecommissioningNodesWatcher internal polling. ,20
yarn.nodemanager.node-labels.provider.script.path,"The Node Label script to run. Script output Line starting with  ""NODE_PARTITION:"" will be considered as Node Label Partition. In case of  multiple lines have this pattern, then last one will be considered ",
yarn.nodemanager.node-labels.provider.script.opts,The arguments to pass to the Node label script.,
yarn.federation.enabled,   Flag to indicate whether the RM is participating in Federation or not. ,false
yarn.federation.machine-list,   Machine list file to be loaded by the FederationSubCluster Resolver ,
yarn.federation.subcluster-resolver.class,   Class name for SubClusterResolver ,org.apache.hadoop.yarn.server.federation.resolver.DefaultSubClusterResolverImpl
yarn.federation.state-store.class,   Store class name for federation state store ,org.apache.hadoop.yarn.server.federation.store.impl.MemoryFederationStateStore
yarn.federation.cache-ttl.secs, The time in seconds after which the federation state store local cache will be refreshed periodically   ,300
yarn.federation.registry.base-dir,The registry base directory for federation.,yarnfederation/
yarn.registry.class,The registry implementation to use.,org.apache.hadoop.registry.client.impl.FSRegistryOperationsService
yarn.client.application-client-protocol.poll-interval-ms,The interval that the yarn client library uses to poll the completion status of the asynchronous API of application client protocol. ,200
yarn.client.application-client-protocol.poll-timeout-ms, The duration (in ms) the YARN client waits for an expected state change to occur.  -1 means unlimited wait time. ,-1
yarn.nodemanager.container-monitor.procfs-tree.smaps-based-rss.enabled,"RSS usage of a process computed via /proc/pid/stat is not very accurate as it includes shared pages of a process. /proc/pid/smaps provides useful information like Private_Dirty, Private_Clean, Shared_Dirty, Shared_Clean which can be used for computing more accurate RSS. When this flag is enabled, RSS is computed as Min(Shared_Dirty, Pss) + Private_Clean + Private_Dirty. It excludes read-only shared mappings in RSS computation.   ",false
yarn.log.server.url, URL for log aggregation server ,
yarn.log.server.web-service.url, URL for log aggregation server web service ,
yarn.tracking.url.generator, RM Application Tracking URL ,
yarn.authorization-provider, Class to be used for YarnAuthorizationProvider ,
yarn.nodemanager.log-aggregation.roll-monitoring-interval-seconds,"Defines how often NMs wake up to upload log files. The default value is -1. By default, the logs will be uploaded when the application is finished. By setting this configure, logs can be uploaded periodically when the application is running. The minimum rolling-interval-seconds can be set is 3600. ",-1
yarn.intermediate-data-encryption.enable," Enable/disable intermediate-data encryption at YARN level. For now, this only is used by the FileSystemRMStateStore to setup right file-system security attributes. ",false
yarn.nodemanager.webapp.cross-origin.enabled,Flag to enable cross-origin (CORS) support in the NM. This flag requires the CORS filter initializer to be added to the filter initializers list in core-site.xml.,false
yarn.cluster.max-application-priority," Defines maximum application priority in a cluster. If an application is submitted with a priority higher than this value, it will be reset to this maximum value. ",0
yarn.nodemanager.log-aggregation.policy.class, The default log aggregation policy class. Applications can override it via LogAggregationContext. This configuration can provide some cluster-side default behavior so that if the application doesn't specify any policy via LogAggregationContext administrators of the cluster can adjust the policy globally. ,org.apache.hadoop.yarn.server.nodemanager.containermanager.logaggregation.AllContainerLogAggregationPolicy
yarn.nodemanager.log-aggregation.policy.parameters, The default parameters for the log aggregation policy. Applications can override it via LogAggregationContext. This configuration can provide some cluster-side default behavior so that if the application doesn't specify any policy via LogAggregationContext administrators of the cluster can adjust the policy globally. ,
yarn.nodemanager.amrmproxy.enabled, Enable/Disable AMRMProxyService in the node manager. This service is used to intercept calls from the application masters to the resource manager. ,false
yarn.nodemanager.amrmproxy.address, The address of the AMRMProxyService listener. ,0.0.0.0:8049
yarn.nodemanager.amrmproxy.client.thread-count, The number of threads used to handle requests by the AMRMProxyService. ,25
yarn.nodemanager.amrmproxy.interceptor-class.pipeline, The comma separated list of class names that implement the RequestInterceptor interface. This is used by the AMRMProxyService to create the request processing pipeline for applications. ,org.apache.hadoop.yarn.server.nodemanager.amrmproxy.DefaultRequestInterceptor
yarn.nodemanager.amrmproxy.ha.enable, Whether AMRMProxy HA is enabled. ,false
yarn.nodemanager.distributed-scheduling.enabled, Setting that controls whether distributed scheduling is enabled. ,false
yarn.resourcemanager.opportunistic-container-allocation.enabled,   Setting that controls whether opportunistic container allocation   is enabled. ,false
yarn.resourcemanager.opportunistic-container-allocation.nodes-used, Number of nodes to be used by the Opportunistic Container Allocator for dispatching containers during container allocation. ,10
yarn.resourcemanager.nm-container-queuing.sorting-nodes-interval-ms, Frequency for computing least loaded NMs. ,1000
yarn.resourcemanager.nm-container-queuing.load-comparator, Comparator for determining node load for Distributed Scheduling. ,QUEUE_LENGTH
yarn.resourcemanager.nm-container-queuing.queue-limit-stdev, Value of standard deviation used for calculation of queue limit thresholds. ,1.0f
yarn.resourcemanager.nm-container-queuing.min-queue-length, Min length of container queue at NodeManager. ,5
yarn.resourcemanager.nm-container-queuing.max-queue-length, Max length of container queue at NodeManager. ,15
yarn.resourcemanager.nm-container-queuing.min-queue-wait-time-ms, Min queue wait time for a container at a NodeManager. ,10
yarn.resourcemanager.nm-container-queuing.max-queue-wait-time-ms, Max queue wait time for a container queue at a NodeManager. ,100
yarn.nodemanager.opportunistic-containers-use-pause-for-preemption, Use container pause as the preemption policy over kill in the container queue at a NodeManager. ,false
yarn.nodemanager.container.stderr.pattern," Error filename pattern, to identify the file in the container's Log directory which contain the container's error log. As error file redirection is done by client/AM and yarn will not be aware of the error file name. YARN uses this pattern to identify the error file and tail the error log as diagnostics when the container execution returns non zero value. Filename patterns are case sensitive and should match the specifications of FileSystem.globStatus(Path) api. If multiple filenames matches the pattern, first file matching the pattern will be picked. ","{*stderr*,*STDERR*}"
yarn.nodemanager.container.stderr.tail.bytes ," Size of the container error file which needs to be tailed, in bytes. ",4096
yarn.node-labels.fs-store.impl.class, Choose different implementation of node label's storage ,org.apache.hadoop.yarn.nodelabels.FileSystemNodeLabelsStore
yarn.resourcemanager.webapp.rest-csrf.enabled,   Enable the CSRF filter for the RM web app ,false
yarn.resourcemanager.webapp.rest-csrf.custom-header,   Optional parameter that indicates the custom header name to use for CSRF   protection. ,X-XSRF-Header
yarn.resourcemanager.webapp.rest-csrf.methods-to-ignore,   Optional parameter that indicates the list of HTTP methods that do not   require CSRF protection ,"GET,OPTIONS,HEAD"
yarn.nodemanager.webapp.rest-csrf.enabled,   Enable the CSRF filter for the NM web app ,false
yarn.nodemanager.webapp.rest-csrf.custom-header,   Optional parameter that indicates the custom header name to use for CSRF   protection. ,X-XSRF-Header
yarn.nodemanager.webapp.rest-csrf.methods-to-ignore,   Optional parameter that indicates the list of HTTP methods that do not   require CSRF protection ,"GET,OPTIONS,HEAD"
yarn.nodemanager.disk-validator,   The name of disk validator. ,basic
yarn.timeline-service.webapp.rest-csrf.enabled,   Enable the CSRF filter for the timeline service web app ,false
yarn.timeline-service.webapp.rest-csrf.custom-header,   Optional parameter that indicates the custom header name to use for CSRF   protection. ,X-XSRF-Header
yarn.timeline-service.webapp.rest-csrf.methods-to-ignore,   Optional parameter that indicates the list of HTTP methods that do not   require CSRF protection ,"GET,OPTIONS,HEAD"
yarn.webapp.xfs-filter.enabled,   Enable the XFS filter for YARN ,true
yarn.resourcemanager.webapp.xfs-filter.xframe-options,   Property specifying the xframe options value. ,SAMEORIGIN
yarn.nodemanager.webapp.xfs-filter.xframe-options,   Property specifying the xframe options value. ,SAMEORIGIN
yarn.timeline-service.webapp.xfs-filter.xframe-options,   Property specifying the xframe options value. ,SAMEORIGIN
yarn.resourcemanager.node-removal-untracked.timeout-ms," The least amount of time(msec.) an inactive (decommissioned or shutdown) node can stay in the nodes list of the resourcemanager after being declared untracked. A node is marked untracked if and only if it is absent from both include and exclude nodemanager lists on the RM. All inactive nodes are checked twice per timeout interval or every 10 minutes, whichever is lesser, and marked appropriately. The same is done when refreshNodes command (graceful or otherwise) is invoked. ",60000
yarn.resourcemanager.application-timeouts.monitor.interval-ms, The RMAppLifetimeMonitor Service uses this value as monitor interval ,3000
yarn.app.attempt.diagnostics.limit.kc,"   Defines the limit of the diagnostics message of an application   attempt, in kilo characters (character count * 1024).   When using ZooKeeper to store application state behavior, it's   important to limit the size of the diagnostic messages to   prevent YARN from overwhelming ZooKeeper. In cases where   yarn.resourcemanager.state-store.max-completed-applications is set to   a large number, it may be desirable to reduce the value of this property   to limit the total data stored. ",64
yarn.timeline-service.http-cross-origin.enabled,"   Flag to enable cross-origin (CORS) support for timeline service v1.x or   Timeline Reader in timeline service v2. For timeline service v2, also add   org.apache.hadoop.security.HttpCrossOriginFilterInitializer to the   configuration hadoop.http.filter.initializers in core-site.xml. ",false
yarn.scheduler.queue-placement-rules,"   Comma-separated list of PlacementRules to determine how applications   submitted by certain users get mapped to certain queues. Default is   user-group, which corresponds to UserGroupMappingPlacementRule. ",user-group
yarn.timeline-service.entity-group-fs-store.with-user-dir,    It is TimelineClient 1.5 configuration whether to store active    application’s timeline data with in user directory i.e    ${yarn.timeline-service.entity-group-fs-store.active-dir}/${user.name} ,false
yarn.router.clientrm.interceptor-class.pipeline,   The comma separated list of class names that implement the   RequestInterceptor interface. This is used by the RouterClientRMService   to create the request processing pipeline for users. ,org.apache.hadoop.yarn.server.router.clientrm.DefaultClientRequestInterceptor
yarn.router.pipeline.cache-max-size,   Size of LRU cache for Router ClientRM Service and RMAdmin Service. ,25
yarn.router.rmadmin.interceptor-class.pipeline,   The comma separated list of class names that implement the   RequestInterceptor interface. This is used by the RouterRMAdminService   to create the request processing pipeline for users. ,org.apache.hadoop.yarn.server.router.rmadmin.DefaultRMAdminRequestInterceptor
yarn.router.bind-host,"   The actual address the server will bind to. If this optional address is   set, the RPC and webapp servers will bind to this address and the port specified in   yarn.router.address and yarn.router.webapp.address, respectively. This is   most useful for making Router listen to all interfaces by setting to 0.0.0.0. ",
yarn.router.webapp.interceptor-class.pipeline,   The comma separated list of class names that implement the   RequestInterceptor interface. This is used by the RouterWebServices   to create the request processing pipeline for users. ,org.apache.hadoop.yarn.server.router.webapp.DefaultRequestInterceptorREST
yarn.router.webapp.address,"   The http address of the Router web application.   If only a host is provided as the value,   the webapp will be served on a random port. ",0.0.0.0:8089
yarn.router.webapp.https.address,"   The https address of the Router web application.   If only a host is provided as the value,   the webapp will be served on a random port. ",0.0.0.0:8091
yarn.resourcemanager.display.per-user-apps,  Flag to enable display of applications per user as an admin  configuration.   ,false
yarn.scheduler.configuration.store.class,"   The type of configuration store to use for scheduler configurations.   Default is ""file"", which uses file based capacity-scheduler.xml to   retrieve and change scheduler configuration. To enable API based   scheduler configuration, use either ""memory"" (in memory storage, no   persistence across restarts), ""leveldb"" (leveldb based storage), or   ""zk"" (zookeeper based storage). API based configuration is only useful   when using a scheduler which supports mutable configuration. Currently   only capacity scheduler supports this. ",file
yarn.scheduler.configuration.mutation.acl-policy.class,   The class to use for configuration mutation ACL policy if using a mutable   configuration provider. Controls whether a mutation request is allowed.   The DefaultConfigurationMutationACLPolicy checks if the requestor is a   YARN admin. ,org.apache.hadoop.yarn.server.resourcemanager.scheduler.DefaultConfigurationMutationACLPolicy
yarn.scheduler.configuration.leveldb-store.path,"   The storage path for LevelDB implementation of configuration store,   when yarn.scheduler.configuration.store.class is configured to be   ""leveldb"". ",${hadoop.tmp.dir}/yarn/system/confstore
yarn.scheduler.configuration.leveldb-store.compaction-interval-secs,"   The compaction interval for LevelDB configuration store in secs,   when yarn.scheduler.configuration.store.class is configured to be   ""leveldb"". Default is one day. ",86400
yarn.scheduler.configuration.store.max-logs,"   The max number of configuration change log entries kept in config   store, when yarn.scheduler.configuration.store.class is configured to be   ""leveldb"" or ""zk"". Default is 1000 for either. ",1000
yarn.scheduler.configuration.zk-store.parent-path,   ZK root node path for configuration store when using zookeeper-based   configuration store. ,/confstore

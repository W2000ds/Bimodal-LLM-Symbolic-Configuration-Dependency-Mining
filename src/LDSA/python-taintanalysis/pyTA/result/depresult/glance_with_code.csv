id,filepath,var1,localvar1,var2,localvar2,code_snippet
1,apps/glance/glance/api/common.py,user,CONF.user_storage_quota,user_storage_quota,CONF.user_storage_quota,":param context:
    :param db_api:  The db_api in use for this configuration
    :param image_id: The image that will be replaced with this new data size
    :returns: The number of bytes the user has remaining under their quota.
             None means infinity
    """"""

    # NOTE(jbresnah) in the future this value will come from a call to
    # keystone.
    users_quota = CONF.user_storage_quota

    # set quota must have a number optionally followed by B, KB, MB,
    # GB or TB without any spaces in between
    pattern = re.compile(r'^(\d+)((K|M|G|T)?B)?$')
    match = pattern.match(users_quota)

    if not match:
        LOG.error(_LE(""Invalid value for option user_storage_quota: ""
                      ""%(users_quota)s""),"
2,apps/glance/glance/api/common.py,user,CONF.user_storage_quota,user_storage_quota,get_remaining_quota.CONF.user_storage_quota,":param context:
    :param db_api:  The db_api in use for this configuration
    :param image_id: The image that will be replaced with this new data size
    :returns: The number of bytes the user has remaining under their quota.
             None means infinity
    """"""

    # NOTE(jbresnah) in the future this value will come from a call to
    # keystone.
    users_quota = CONF.user_storage_quota

    # set quota must have a number optionally followed by B, KB, MB,
    # GB or TB without any spaces in between
    pattern = re.compile(r'^(\d+)((K|M|G|T)?B)?$')
    match = pattern.match(users_quota)

    if not match:
        LOG.error(_LE(""Invalid value for option user_storage_quota: ""
                      ""%(users_quota)s""),"
3,apps/glance/glance/api/common.py,user,get_remaining_quota.CONF.user_storage_quota,user_storage_quota,CONF.user_storage_quota,":param context:
    :param db_api:  The db_api in use for this configuration
    :param image_id: The image that will be replaced with this new data size
    :returns: The number of bytes the user has remaining under their quota.
             None means infinity
    """"""

    # NOTE(jbresnah) in the future this value will come from a call to
    # keystone.
    users_quota = CONF.user_storage_quota

    # set quota must have a number optionally followed by B, KB, MB,
    # GB or TB without any spaces in between
    pattern = re.compile(r'^(\d+)((K|M|G|T)?B)?$')
    match = pattern.match(users_quota)

    if not match:
        LOG.error(_LE(""Invalid value for option user_storage_quota: ""
                      ""%(users_quota)s""),"
4,apps/glance/glance/api/common.py,user,get_remaining_quota.CONF.user_storage_quota,user_storage_quota,get_remaining_quota.CONF.user_storage_quota,":param context:
    :param db_api:  The db_api in use for this configuration
    :param image_id: The image that will be replaced with this new data size
    :returns: The number of bytes the user has remaining under their quota.
             None means infinity
    """"""

    # NOTE(jbresnah) in the future this value will come from a call to
    # keystone.
    users_quota = CONF.user_storage_quota

    # set quota must have a number optionally followed by B, KB, MB,
    # GB or TB without any spaces in between
    pattern = re.compile(r'^(\d+)((K|M|G|T)?B)?$')
    match = pattern.match(users_quota)

    if not match:
        LOG.error(_LE(""Invalid value for option user_storage_quota: ""
                      ""%(users_quota)s""),"
5,apps/glance/glance/api/common.py,user,get_remaining_quota.users_quota,user_storage_quota,get_remaining_quota.users_quota,"None means infinity
    """"""

    # NOTE(jbresnah) in the future this value will come from a call to
    # keystone.
    users_quota = CONF.user_storage_quota

    # set quota must have a number optionally followed by B, KB, MB,
    # GB or TB without any spaces in between
    pattern = re.compile(r'^(\d+)((K|M|G|T)?B)?$')
    match = pattern.match(users_quota)

    if not match:
        LOG.error(_LE(""Invalid value for option user_storage_quota: ""
                      ""%(users_quota)s""),
                  {'users_quota': users_quota})
        raise exception.InvalidOptionValue(option='user_storage_quota',
                                           value=users_quota)

    quota_value, quota_unit = (match.groups())[0:2]"
6,apps/glance/glance/api/common.py,user,get_remaining_quota.users_quota,user_storage_quota,get_remaining_quota.users_quota,"None means infinity
    """"""

    # NOTE(jbresnah) in the future this value will come from a call to
    # keystone.
    users_quota = CONF.user_storage_quota

    # set quota must have a number optionally followed by B, KB, MB,
    # GB or TB without any spaces in between
    pattern = re.compile(r'^(\d+)((K|M|G|T)?B)?$')
    match = pattern.match(users_quota)

    if not match:
        LOG.error(_LE(""Invalid value for option user_storage_quota: ""
                      ""%(users_quota)s""),
                  {'users_quota': users_quota})
        raise exception.InvalidOptionValue(option='user_storage_quota',
                                           value=users_quota)

    quota_value, quota_unit = (match.groups())[0:2]"
7,apps/glance/glance/api/middleware/version_negotiation.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"allowed_versions['v2.3'] = 2
        allowed_versions['v2.4'] = 2
        allowed_versions['v2.5'] = 2
        allowed_versions['v2.6'] = 2
        allowed_versions['v2.7'] = 2
        allowed_versions['v2.9'] = 2
        if CONF.image_cache_dir:
            allowed_versions['v2.14'] = 2
            allowed_versions['v2.16'] = 2
        allowed_versions['v2.15'] = 2
        if CONF.enabled_backends:
            allowed_versions['v2.8'] = 2
            allowed_versions['v2.10'] = 2
            allowed_versions['v2.11'] = 2
            allowed_versions['v2.12'] = 2
            allowed_versions['v2.13'] = 2
        allowed_versions['v2.17'] = 2
        return allowed_versions

    def _match_version_string(self, subject):"
8,apps/glance/glance/api/middleware/version_negotiation.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"if CONF.enabled_backends:
            allowed_versions['v2.8'] = 2
            allowed_versions['v2.10'] = 2
            allowed_versions['v2.11'] = 2
            allowed_versions['v2.12'] = 2
            allowed_versions['v2.13'] = 2"
9,apps/glance/glance/api/v2/cached_images.py,debug,LOG.debug,image_cache_dir,CONF.image_cache_dir,"if CONF.image_cache_dir and not WORKER:
            # If we're the first, start the thread
            WORKER = CacheWorker()
            WORKER.start()
            LOG.debug('Started cache worker thread')"
10,apps/glance/glance/api/v2/discovery.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"'value': CONF.get('enabled_import_methods')
        }

        return {
            'import-methods': import_methods
        }

    def get_stores(self, req):
        # TODO(abhishekk): This will be removed after config options
        # 'stores' and 'default_store' are removed.
        enabled_backends = CONF.enabled_backends
        if not enabled_backends:
            msg = _(""Multi backend is not supported at this site."")
            raise webob.exc.HTTPNotFound(explanation=msg)

        backends = []
        for backend in enabled_backends:
            if backend.startswith(""os_glance_""):
                continue"
11,apps/glance/glance/api/v2/discovery.py,enabled,CONF.enabled_backends,enabled_backends,get_stores.CONF.enabled_backends,"'value': CONF.get('enabled_import_methods')
        }

        return {
            'import-methods': import_methods
        }

    def get_stores(self, req):
        # TODO(abhishekk): This will be removed after config options
        # 'stores' and 'default_store' are removed.
        enabled_backends = CONF.enabled_backends
        if not enabled_backends:
            msg = _(""Multi backend is not supported at this site."")
            raise webob.exc.HTTPNotFound(explanation=msg)

        backends = []
        for backend in enabled_backends:
            if backend.startswith(""os_glance_""):
                continue"
12,apps/glance/glance/api/v2/discovery.py,enabled,get_stores.CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"'value': CONF.get('enabled_import_methods')
        }

        return {
            'import-methods': import_methods
        }

    def get_stores(self, req):
        # TODO(abhishekk): This will be removed after config options
        # 'stores' and 'default_store' are removed.
        enabled_backends = CONF.enabled_backends
        if not enabled_backends:
            msg = _(""Multi backend is not supported at this site."")
            raise webob.exc.HTTPNotFound(explanation=msg)

        backends = []
        for backend in enabled_backends:
            if backend.startswith(""os_glance_""):
                continue"
13,apps/glance/glance/api/v2/discovery.py,enabled,get_stores.CONF.enabled_backends,enabled_backends,get_stores.CONF.enabled_backends,"'value': CONF.get('enabled_import_methods')
        }

        return {
            'import-methods': import_methods
        }

    def get_stores(self, req):
        # TODO(abhishekk): This will be removed after config options
        # 'stores' and 'default_store' are removed.
        enabled_backends = CONF.enabled_backends
        if not enabled_backends:
            msg = _(""Multi backend is not supported at this site."")
            raise webob.exc.HTTPNotFound(explanation=msg)

        backends = []
        for backend in enabled_backends:
            if backend.startswith(""os_glance_""):
                continue"
14,apps/glance/glance/api/v2/discovery.py,enabled,get_stores.enabled_backends,enabled_backends,get_stores.enabled_backends,"backends = []
        for backend in enabled_backends:
            if backend.startswith(""os_glance_""):
                continue

            stores = {}
            if enabled_backends[backend] == 'swift':
                conf_file = getattr(CONF, backend).swift_store_config_file
                multitenant = getattr(CONF, backend).swift_store_multi_tenant
                if multitenant and conf_file:
                    msg = (""The config options 'swift_store_multi_tenant' ""
                           ""and 'swift_store_config_file' are mutually ""
                           ""exclusive. If you intend to use multi-tenant ""
                           ""swift store, please make sure that you have ""
                           ""not set a swift configuration file with the ""
                           ""'swift_store_config_file' option. ""
                           ""Excluding `%s:%s` store details from the ""
                           ""response as it's not configured correctly.""
                           % (backend, enabled_backends[backend]))
                    LOG.warning(_LW(msg))"
15,apps/glance/glance/api/v2/discovery.py,enabled,get_stores.enabled_backends,enabled_backends,get_stores.enabled_backends,"backends = []
        for backend in enabled_backends:
            if backend.startswith(""os_glance_""):
                continue

            stores = {}
            if enabled_backends[backend] == 'swift':
                conf_file = getattr(CONF, backend).swift_store_config_file
                multitenant = getattr(CONF, backend).swift_store_multi_tenant
                if multitenant and conf_file:
                    msg = (""The config options 'swift_store_multi_tenant' ""
                           ""and 'swift_store_config_file' are mutually ""
                           ""exclusive. If you intend to use multi-tenant ""
                           ""swift store, please make sure that you have ""
                           ""not set a swift configuration file with the ""
                           ""'swift_store_config_file' option. ""
                           ""Excluding `%s:%s` store details from the ""
                           ""response as it's not configured correctly.""
                           % (backend, enabled_backends[backend]))
                    LOG.warning(_LW(msg))"
16,apps/glance/glance/api/v2/discovery.py,enabled,get_stores.enabled_backends,enabled_backends,get_stores.enabled_backends,"backends = []
        for backend in enabled_backends:
            if backend.startswith(""os_glance_""):
                continue

            stores = {}
            if enabled_backends[backend] == 'swift':
                conf_file = getattr(CONF, backend).swift_store_config_file
                multitenant = getattr(CONF, backend).swift_store_multi_tenant
                if multitenant and conf_file:
                    msg = (""The config options 'swift_store_multi_tenant' ""
                           ""and 'swift_store_config_file' are mutually ""
                           ""exclusive. If you intend to use multi-tenant ""
                           ""swift store, please make sure that you have ""
                           ""not set a swift configuration file with the ""
                           ""'swift_store_config_file' option. ""
                           ""Excluding `%s:%s` store details from the ""
                           ""response as it's not configured correctly.""
                           % (backend, enabled_backends[backend]))
                    LOG.warning(_LW(msg))"
17,apps/glance/glance/api/v2/discovery.py,enabled,get_stores.enabled_backends,enabled_backends,get_stores.enabled_backends,"backends = []
        for backend in enabled_backends:
            if backend.startswith(""os_glance_""):
                continue

            stores = {}
            if enabled_backends[backend] == 'swift':
                conf_file = getattr(CONF, backend).swift_store_config_file
                multitenant = getattr(CONF, backend).swift_store_multi_tenant
                if multitenant and conf_file:
                    msg = (""The config options 'swift_store_multi_tenant' ""
                           ""and 'swift_store_config_file' are mutually ""
                           ""exclusive. If you intend to use multi-tenant ""
                           ""swift store, please make sure that you have ""
                           ""not set a swift configuration file with the ""
                           ""'swift_store_config_file' option. ""
                           ""Excluding `%s:%s` store details from the ""
                           ""response as it's not configured correctly.""
                           % (backend, enabled_backends[backend]))
                    LOG.warning(_LW(msg))"
18,apps/glance/glance/api/v2/discovery.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"store_detail.s3_store_thread_pools
        }

    @staticmethod
    def _get_http_properties(store_detail):
        # NOTE(mrjoshi): Thre are no useful properties
        # to be exposed.
        return {}

    def get_stores_detail(self, req):
        enabled_backends = CONF.enabled_backends
        stores = self.get_stores(req).get('stores')
        try:
            api_policy.DiscoveryAPIPolicy(
                req.context,
                enforcer=self.policy).stores_info_detail()

            store_mapper = {
                'rbd': self._get_rbd_properties,
                'file': self._get_file_properties,"
19,apps/glance/glance/api/v2/discovery.py,enabled,CONF.enabled_backends,enabled_backends,get_stores_detail.CONF.enabled_backends,"store_detail.s3_store_thread_pools
        }

    @staticmethod
    def _get_http_properties(store_detail):
        # NOTE(mrjoshi): Thre are no useful properties
        # to be exposed.
        return {}

    def get_stores_detail(self, req):
        enabled_backends = CONF.enabled_backends
        stores = self.get_stores(req).get('stores')
        try:
            api_policy.DiscoveryAPIPolicy(
                req.context,
                enforcer=self.policy).stores_info_detail()

            store_mapper = {
                'rbd': self._get_rbd_properties,
                'file': self._get_file_properties,"
20,apps/glance/glance/api/v2/discovery.py,enabled,get_stores_detail.CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"store_detail.s3_store_thread_pools
        }

    @staticmethod
    def _get_http_properties(store_detail):
        # NOTE(mrjoshi): Thre are no useful properties
        # to be exposed.
        return {}

    def get_stores_detail(self, req):
        enabled_backends = CONF.enabled_backends
        stores = self.get_stores(req).get('stores')
        try:
            api_policy.DiscoveryAPIPolicy(
                req.context,
                enforcer=self.policy).stores_info_detail()

            store_mapper = {
                'rbd': self._get_rbd_properties,
                'file': self._get_file_properties,"
21,apps/glance/glance/api/v2/discovery.py,enabled,get_stores_detail.CONF.enabled_backends,enabled_backends,get_stores_detail.CONF.enabled_backends,"store_detail.s3_store_thread_pools
        }

    @staticmethod
    def _get_http_properties(store_detail):
        # NOTE(mrjoshi): Thre are no useful properties
        # to be exposed.
        return {}

    def get_stores_detail(self, req):
        enabled_backends = CONF.enabled_backends
        stores = self.get_stores(req).get('stores')
        try:
            api_policy.DiscoveryAPIPolicy(
                req.context,
                enforcer=self.policy).stores_info_detail()

            store_mapper = {
                'rbd': self._get_rbd_properties,
                'file': self._get_file_properties,"
22,apps/glance/glance/api/v2/discovery.py,enabled,get_stores_detail.enabled_backends,enabled_backends,get_stores_detail.enabled_backends,"store_mapper = {
                'rbd': self._get_rbd_properties,
                'file': self._get_file_properties,
                'cinder': self._get_cinder_properties,
                'swift': self._get_swift_properties,
                's3': self._get_s3_properties,
                'http': self._get_http_properties
            }

            for store in stores:
                store_type = enabled_backends[store['id']]
                store['type'] = store_type
                store_detail = g_store.get_store_from_store_identifier(
                    store['id'])
                store['properties'] = store_mapper.get(store_type)(
                    store_detail)
                store['weight'] = getattr(CONF, store['id']).weight

        except exception.Forbidden as e:
            LOG.debug(""User not permitted to view details"")"
23,apps/glance/glance/api/v2/discovery.py,enabled,get_stores_detail.enabled_backends,enabled_backends,get_stores_detail.enabled_backends,"store_mapper = {
                'rbd': self._get_rbd_properties,
                'file': self._get_file_properties,
                'cinder': self._get_cinder_properties,
                'swift': self._get_swift_properties,
                's3': self._get_s3_properties,
                'http': self._get_http_properties
            }

            for store in stores:
                store_type = enabled_backends[store['id']]
                store['type'] = store_type
                store_detail = g_store.get_store_from_store_identifier(
                    store['id'])
                store['properties'] = store_mapper.get(store_type)(
                    store_detail)
                store['weight'] = getattr(CONF, store['id']).weight

        except exception.Forbidden as e:
            LOG.debug(""User not permitted to view details"")"
24,apps/glance/glance/api/v2/discovery.py,enabled,get_stores_detail.enabled_backends,enabled_backends,get_stores_detail.enabled_backends,"store_mapper = {
                'rbd': self._get_rbd_properties,
                'file': self._get_file_properties,
                'cinder': self._get_cinder_properties,
                'swift': self._get_swift_properties,
                's3': self._get_s3_properties,
                'http': self._get_http_properties
            }

            for store in stores:
                store_type = enabled_backends[store['id']]
                store['type'] = store_type
                store_detail = g_store.get_store_from_store_identifier(
                    store['id'])
                store['properties'] = store_mapper.get(store_type)(
                    store_detail)
                store['weight'] = getattr(CONF, store['id']).weight

        except exception.Forbidden as e:
            LOG.debug(""User not permitted to view details"")"
25,apps/glance/glance/api/v2/discovery.py,enabled,get_stores_detail.enabled_backends,enabled_backends,get_stores_detail.enabled_backends,"store_mapper = {
                'rbd': self._get_rbd_properties,
                'file': self._get_file_properties,
                'cinder': self._get_cinder_properties,
                'swift': self._get_swift_properties,
                's3': self._get_s3_properties,
                'http': self._get_http_properties
            }

            for store in stores:
                store_type = enabled_backends[store['id']]
                store['type'] = store_type
                store_detail = g_store.get_store_from_store_identifier(
                    store['id'])
                store['properties'] = store_mapper.get(store_type)(
                    store_detail)
                store['weight'] = getattr(CONF, store['id']).weight

        except exception.Forbidden as e:
            LOG.debug(""User not permitted to view details"")"
26,apps/glance/glance/api/v2/discovery.py,enabled,get_stores.enabled_backends,swift_store_config_file,get_stores.swift_store_config_file,"for backend in enabled_backends:
            if backend.startswith(""os_glance_""):
                continue

            stores = {}
            if enabled_backends[backend] == 'swift':
                conf_file = getattr(CONF, backend).swift_store_config_file
                multitenant = getattr(CONF, backend).swift_store_multi_tenant
                if multitenant and conf_file:
                    msg = (""The config options 'swift_store_multi_tenant' ""
                           ""and 'swift_store_config_file' are mutually ""
                           ""exclusive. If you intend to use multi-tenant ""
                           ""swift store, please make sure that you have ""
                           ""not set a swift configuration file with the ""
                           ""'swift_store_config_file' option. ""
                           ""Excluding `%s:%s` store details from the ""
                           ""response as it's not configured correctly.""
                           % (backend, enabled_backends[backend]))
                    LOG.warning(_LW(msg))
                    continue
            stores['id'] = backend
            description = getattr(CONF, backend).store_description
            if description:
                stores['description'] = description
            if backend == CONF.glance_store.default_backend:
                stores['default'] = ""true""
            # Check if http store is configured then mark it as read-only
            if enabled_backends[backend] == 'http':
                stores['read-only'] = ""true""
            backends.append(stores)"
27,apps/glance/glance/api/v2/discovery.py,enabled,get_stores.enabled_backends,swift_store_config_file,swift_store_config_file,"for backend in enabled_backends:
            if backend.startswith(""os_glance_""):
                continue

            stores = {}
            if enabled_backends[backend] == 'swift':
                conf_file = getattr(CONF, backend).swift_store_config_file
                multitenant = getattr(CONF, backend).swift_store_multi_tenant
                if multitenant and conf_file:
                    msg = (""The config options 'swift_store_multi_tenant' ""
                           ""and 'swift_store_config_file' are mutually ""
                           ""exclusive. If you intend to use multi-tenant ""
                           ""swift store, please make sure that you have ""
                           ""not set a swift configuration file with the ""
                           ""'swift_store_config_file' option. ""
                           ""Excluding `%s:%s` store details from the ""
                           ""response as it's not configured correctly.""
                           % (backend, enabled_backends[backend]))
                    LOG.warning(_LW(msg))
                    continue
            stores['id'] = backend
            description = getattr(CONF, backend).store_description
            if description:
                stores['description'] = description
            if backend == CONF.glance_store.default_backend:
                stores['default'] = ""true""
            # Check if http store is configured then mark it as read-only
            if enabled_backends[backend] == 'http':
                stores['read-only'] = ""true""
            backends.append(stores)"
28,apps/glance/glance/api/v2/discovery.py,swift_store_config_file,get_stores.swift_store_config_file,swift_store_multi_tenant,get_stores.swift_store_multi_tenant,"for backend in enabled_backends:
            if backend.startswith(""os_glance_""):
                continue

            stores = {}
            if enabled_backends[backend] == 'swift':
                conf_file = getattr(CONF, backend).swift_store_config_file
                multitenant = getattr(CONF, backend).swift_store_multi_tenant
                if multitenant and conf_file:
                    msg = (""The config options 'swift_store_multi_tenant' ""
                           ""and 'swift_store_config_file' are mutually ""
                           ""exclusive. If you intend to use multi-tenant ""
                           ""swift store, please make sure that you have ""
                           ""not set a swift configuration file with the ""
                           ""'swift_store_config_file' option. ""
                           ""Excluding `%s:%s` store details from the ""
                           ""response as it's not configured correctly.""
                           % (backend, enabled_backends[backend]))
                    LOG.warning(_LW(msg))
                    continue
            stores['id'] = backend
            description = getattr(CONF, backend).store_description
            if description:
                stores['description'] = description
            if backend == CONF.glance_store.default_backend:
                stores['default'] = ""true""
            # Check if http store is configured then mark it as read-only
            if enabled_backends[backend] == 'http':
                stores['read-only'] = ""true""
            backends.append(stores)"
29,apps/glance/glance/api/v2/discovery.py,swift_store_config_file,get_stores.swift_store_config_file,swift_store_multi_tenant,swift_store_multi_tenant,"for backend in enabled_backends:
            if backend.startswith(""os_glance_""):
                continue

            stores = {}
            if enabled_backends[backend] == 'swift':
                conf_file = getattr(CONF, backend).swift_store_config_file
                multitenant = getattr(CONF, backend).swift_store_multi_tenant
                if multitenant and conf_file:
                    msg = (""The config options 'swift_store_multi_tenant' ""
                           ""and 'swift_store_config_file' are mutually ""
                           ""exclusive. If you intend to use multi-tenant ""
                           ""swift store, please make sure that you have ""
                           ""not set a swift configuration file with the ""
                           ""'swift_store_config_file' option. ""
                           ""Excluding `%s:%s` store details from the ""
                           ""response as it's not configured correctly.""
                           % (backend, enabled_backends[backend]))
                    LOG.warning(_LW(msg))
                    continue
            stores['id'] = backend
            description = getattr(CONF, backend).store_description
            if description:
                stores['description'] = description
            if backend == CONF.glance_store.default_backend:
                stores['default'] = ""true""
            # Check if http store is configured then mark it as read-only
            if enabled_backends[backend] == 'http':
                stores['read-only'] = ""true""
            backends.append(stores)"
30,apps/glance/glance/api/v2/discovery.py,swift_store_config_file,swift_store_config_file,swift_store_multi_tenant,get_stores.swift_store_multi_tenant,"for backend in enabled_backends:
            if backend.startswith(""os_glance_""):
                continue

            stores = {}
            if enabled_backends[backend] == 'swift':
                conf_file = getattr(CONF, backend).swift_store_config_file
                multitenant = getattr(CONF, backend).swift_store_multi_tenant
                if multitenant and conf_file:
                    msg = (""The config options 'swift_store_multi_tenant' ""
                           ""and 'swift_store_config_file' are mutually ""
                           ""exclusive. If you intend to use multi-tenant ""
                           ""swift store, please make sure that you have ""
                           ""not set a swift configuration file with the ""
                           ""'swift_store_config_file' option. ""
                           ""Excluding `%s:%s` store details from the ""
                           ""response as it's not configured correctly.""
                           % (backend, enabled_backends[backend]))
                    LOG.warning(_LW(msg))
                    continue
            stores['id'] = backend
            description = getattr(CONF, backend).store_description
            if description:
                stores['description'] = description
            if backend == CONF.glance_store.default_backend:
                stores['default'] = ""true""
            # Check if http store is configured then mark it as read-only
            if enabled_backends[backend] == 'http':
                stores['read-only'] = ""true""
            backends.append(stores)"
31,apps/glance/glance/api/v2/discovery.py,swift_store_config_file,swift_store_config_file,swift_store_multi_tenant,swift_store_multi_tenant,"for backend in enabled_backends:
            if backend.startswith(""os_glance_""):
                continue

            stores = {}
            if enabled_backends[backend] == 'swift':
                conf_file = getattr(CONF, backend).swift_store_config_file
                multitenant = getattr(CONF, backend).swift_store_multi_tenant
                if multitenant and conf_file:
                    msg = (""The config options 'swift_store_multi_tenant' ""
                           ""and 'swift_store_config_file' are mutually ""
                           ""exclusive. If you intend to use multi-tenant ""
                           ""swift store, please make sure that you have ""
                           ""not set a swift configuration file with the ""
                           ""'swift_store_config_file' option. ""
                           ""Excluding `%s:%s` store details from the ""
                           ""response as it's not configured correctly.""
                           % (backend, enabled_backends[backend]))
                    LOG.warning(_LW(msg))
                    continue
            stores['id'] = backend
            description = getattr(CONF, backend).store_description
            if description:
                stores['description'] = description
            if backend == CONF.glance_store.default_backend:
                stores['default'] = ""true""
            # Check if http store is configured then mark it as read-only
            if enabled_backends[backend] == 'http':
                stores['read-only'] = ""true""
            backends.append(stores)"
32,apps/glance/glance/api/v2/discovery.py,enabled,get_stores.enabled_backends,swift_store_multi_tenant,get_stores.swift_store_multi_tenant,"for backend in enabled_backends:
            if backend.startswith(""os_glance_""):
                continue

            stores = {}
            if enabled_backends[backend] == 'swift':
                conf_file = getattr(CONF, backend).swift_store_config_file
                multitenant = getattr(CONF, backend).swift_store_multi_tenant
                if multitenant and conf_file:
                    msg = (""The config options 'swift_store_multi_tenant' ""
                           ""and 'swift_store_config_file' are mutually ""
                           ""exclusive. If you intend to use multi-tenant ""
                           ""swift store, please make sure that you have ""
                           ""not set a swift configuration file with the ""
                           ""'swift_store_config_file' option. ""
                           ""Excluding `%s:%s` store details from the ""
                           ""response as it's not configured correctly.""
                           % (backend, enabled_backends[backend]))
                    LOG.warning(_LW(msg))
                    continue
            stores['id'] = backend
            description = getattr(CONF, backend).store_description
            if description:
                stores['description'] = description
            if backend == CONF.glance_store.default_backend:
                stores['default'] = ""true""
            # Check if http store is configured then mark it as read-only
            if enabled_backends[backend] == 'http':
                stores['read-only'] = ""true""
            backends.append(stores)"
33,apps/glance/glance/api/v2/discovery.py,enabled,get_stores.enabled_backends,swift_store_multi_tenant,swift_store_multi_tenant,"for backend in enabled_backends:
            if backend.startswith(""os_glance_""):
                continue

            stores = {}
            if enabled_backends[backend] == 'swift':
                conf_file = getattr(CONF, backend).swift_store_config_file
                multitenant = getattr(CONF, backend).swift_store_multi_tenant
                if multitenant and conf_file:
                    msg = (""The config options 'swift_store_multi_tenant' ""
                           ""and 'swift_store_config_file' are mutually ""
                           ""exclusive. If you intend to use multi-tenant ""
                           ""swift store, please make sure that you have ""
                           ""not set a swift configuration file with the ""
                           ""'swift_store_config_file' option. ""
                           ""Excluding `%s:%s` store details from the ""
                           ""response as it's not configured correctly.""
                           % (backend, enabled_backends[backend]))
                    LOG.warning(_LW(msg))
                    continue
            stores['id'] = backend
            description = getattr(CONF, backend).store_description
            if description:
                stores['description'] = description
            if backend == CONF.glance_store.default_backend:
                stores['default'] = ""true""
            # Check if http store is configured then mark it as read-only
            if enabled_backends[backend] == 'http':
                stores['read-only'] = ""true""
            backends.append(stores)"
34,apps/glance/glance/api/v2/discovery.py,enabled_backends,get_stores.enabled_backends,swift_store_config_file,get_stores.swift_store_config_file,"for backend in enabled_backends:
            if backend.startswith(""os_glance_""):
                continue

            stores = {}
            if enabled_backends[backend] == 'swift':
                conf_file = getattr(CONF, backend).swift_store_config_file
                multitenant = getattr(CONF, backend).swift_store_multi_tenant
                if multitenant and conf_file:
                    msg = (""The config options 'swift_store_multi_tenant' ""
                           ""and 'swift_store_config_file' are mutually ""
                           ""exclusive. If you intend to use multi-tenant ""
                           ""swift store, please make sure that you have ""
                           ""not set a swift configuration file with the ""
                           ""'swift_store_config_file' option. ""
                           ""Excluding `%s:%s` store details from the ""
                           ""response as it's not configured correctly.""
                           % (backend, enabled_backends[backend]))
                    LOG.warning(_LW(msg))
                    continue
            stores['id'] = backend
            description = getattr(CONF, backend).store_description
            if description:
                stores['description'] = description
            if backend == CONF.glance_store.default_backend:
                stores['default'] = ""true""
            # Check if http store is configured then mark it as read-only
            if enabled_backends[backend] == 'http':
                stores['read-only'] = ""true""
            backends.append(stores)"
35,apps/glance/glance/api/v2/discovery.py,enabled_backends,get_stores.enabled_backends,swift_store_config_file,swift_store_config_file,"for backend in enabled_backends:
            if backend.startswith(""os_glance_""):
                continue

            stores = {}
            if enabled_backends[backend] == 'swift':
                conf_file = getattr(CONF, backend).swift_store_config_file
                multitenant = getattr(CONF, backend).swift_store_multi_tenant
                if multitenant and conf_file:
                    msg = (""The config options 'swift_store_multi_tenant' ""
                           ""and 'swift_store_config_file' are mutually ""
                           ""exclusive. If you intend to use multi-tenant ""
                           ""swift store, please make sure that you have ""
                           ""not set a swift configuration file with the ""
                           ""'swift_store_config_file' option. ""
                           ""Excluding `%s:%s` store details from the ""
                           ""response as it's not configured correctly.""
                           % (backend, enabled_backends[backend]))
                    LOG.warning(_LW(msg))
                    continue
            stores['id'] = backend
            description = getattr(CONF, backend).store_description
            if description:
                stores['description'] = description
            if backend == CONF.glance_store.default_backend:
                stores['default'] = ""true""
            # Check if http store is configured then mark it as read-only
            if enabled_backends[backend] == 'http':
                stores['read-only'] = ""true""
            backends.append(stores)"
36,apps/glance/glance/api/v2/discovery.py,enabled_backends,get_stores.enabled_backends,swift_store_multi_tenant,get_stores.swift_store_multi_tenant,"for backend in enabled_backends:
            if backend.startswith(""os_glance_""):
                continue

            stores = {}
            if enabled_backends[backend] == 'swift':
                conf_file = getattr(CONF, backend).swift_store_config_file
                multitenant = getattr(CONF, backend).swift_store_multi_tenant
                if multitenant and conf_file:
                    msg = (""The config options 'swift_store_multi_tenant' ""
                           ""and 'swift_store_config_file' are mutually ""
                           ""exclusive. If you intend to use multi-tenant ""
                           ""swift store, please make sure that you have ""
                           ""not set a swift configuration file with the ""
                           ""'swift_store_config_file' option. ""
                           ""Excluding `%s:%s` store details from the ""
                           ""response as it's not configured correctly.""
                           % (backend, enabled_backends[backend]))
                    LOG.warning(_LW(msg))
                    continue
            stores['id'] = backend
            description = getattr(CONF, backend).store_description
            if description:
                stores['description'] = description
            if backend == CONF.glance_store.default_backend:
                stores['default'] = ""true""
            # Check if http store is configured then mark it as read-only
            if enabled_backends[backend] == 'http':
                stores['read-only'] = ""true""
            backends.append(stores)"
37,apps/glance/glance/api/v2/discovery.py,enabled_backends,get_stores.enabled_backends,swift_store_multi_tenant,swift_store_multi_tenant,"for backend in enabled_backends:
            if backend.startswith(""os_glance_""):
                continue

            stores = {}
            if enabled_backends[backend] == 'swift':
                conf_file = getattr(CONF, backend).swift_store_config_file
                multitenant = getattr(CONF, backend).swift_store_multi_tenant
                if multitenant and conf_file:
                    msg = (""The config options 'swift_store_multi_tenant' ""
                           ""and 'swift_store_config_file' are mutually ""
                           ""exclusive. If you intend to use multi-tenant ""
                           ""swift store, please make sure that you have ""
                           ""not set a swift configuration file with the ""
                           ""'swift_store_config_file' option. ""
                           ""Excluding `%s:%s` store details from the ""
                           ""response as it's not configured correctly.""
                           % (backend, enabled_backends[backend]))
                    LOG.warning(_LW(msg))
                    continue
            stores['id'] = backend
            description = getattr(CONF, backend).store_description
            if description:
                stores['description'] = description
            if backend == CONF.glance_store.default_backend:
                stores['default'] = ""true""
            # Check if http store is configured then mark it as read-only
            if enabled_backends[backend] == 'http':
                stores['read-only'] = ""true""
            backends.append(stores)"
38,apps/glance/glance/api/v2/discovery.py,enabled,get_stores.enabled_backends,enabled_backends,get_stores.enabled_backends,"for backend in enabled_backends:
            if backend.startswith(""os_glance_""):
                continue

            stores = {}
            if enabled_backends[backend] == 'swift':
                conf_file = getattr(CONF, backend).swift_store_config_file
                multitenant = getattr(CONF, backend).swift_store_multi_tenant
                if multitenant and conf_file:
                    msg = (""The config options 'swift_store_multi_tenant' ""
                           ""and 'swift_store_config_file' are mutually ""
                           ""exclusive. If you intend to use multi-tenant ""
                           ""swift store, please make sure that you have ""
                           ""not set a swift configuration file with the ""
                           ""'swift_store_config_file' option. ""
                           ""Excluding `%s:%s` store details from the ""
                           ""response as it's not configured correctly.""
                           % (backend, enabled_backends[backend]))
                    LOG.warning(_LW(msg))
                    continue
            stores['id'] = backend
            description = getattr(CONF, backend).store_description
            if description:
                stores['description'] = description
            if backend == CONF.glance_store.default_backend:
                stores['default'] = ""true""
            # Check if http store is configured then mark it as read-only
            if enabled_backends[backend] == 'http':
                stores['read-only'] = ""true""
            backends.append(stores)"
39,apps/glance/glance/api/v2/discovery.py,enabled,get_stores_detail.enabled_backends,enabled_backends,get_stores_detail.enabled_backends,"for store in stores:
                store_type = enabled_backends[store['id']]
                store['type'] = store_type
                store_detail = g_store.get_store_from_store_identifier(
                    store['id'])
                store['properties'] = store_mapper.get(store_type)(
                    store_detail)
                store['weight'] = getattr(CONF, store['id']).weight"
40,apps/glance/glance/api/v2/discovery.py,enabled,get_stores.enabled_backends,swift_store_config_file,get_stores.swift_store_config_file,"if enabled_backends[backend] == 'swift':
                conf_file = getattr(CONF, backend).swift_store_config_file
                multitenant = getattr(CONF, backend).swift_store_multi_tenant
                if multitenant and conf_file:
                    msg = (""The config options 'swift_store_multi_tenant' ""
                           ""and 'swift_store_config_file' are mutually ""
                           ""exclusive. If you intend to use multi-tenant ""
                           ""swift store, please make sure that you have ""
                           ""not set a swift configuration file with the ""
                           ""'swift_store_config_file' option. ""
                           ""Excluding `%s:%s` store details from the ""
                           ""response as it's not configured correctly.""
                           % (backend, enabled_backends[backend]))
                    LOG.warning(_LW(msg))
                    continue"
41,apps/glance/glance/api/v2/discovery.py,enabled,get_stores.enabled_backends,swift_store_config_file,swift_store_config_file,"if enabled_backends[backend] == 'swift':
                conf_file = getattr(CONF, backend).swift_store_config_file
                multitenant = getattr(CONF, backend).swift_store_multi_tenant
                if multitenant and conf_file:
                    msg = (""The config options 'swift_store_multi_tenant' ""
                           ""and 'swift_store_config_file' are mutually ""
                           ""exclusive. If you intend to use multi-tenant ""
                           ""swift store, please make sure that you have ""
                           ""not set a swift configuration file with the ""
                           ""'swift_store_config_file' option. ""
                           ""Excluding `%s:%s` store details from the ""
                           ""response as it's not configured correctly.""
                           % (backend, enabled_backends[backend]))
                    LOG.warning(_LW(msg))
                    continue"
42,apps/glance/glance/api/v2/discovery.py,swift_store_config_file,get_stores.swift_store_config_file,swift_store_multi_tenant,get_stores.swift_store_multi_tenant,"if enabled_backends[backend] == 'swift':
                conf_file = getattr(CONF, backend).swift_store_config_file
                multitenant = getattr(CONF, backend).swift_store_multi_tenant
                if multitenant and conf_file:
                    msg = (""The config options 'swift_store_multi_tenant' ""
                           ""and 'swift_store_config_file' are mutually ""
                           ""exclusive. If you intend to use multi-tenant ""
                           ""swift store, please make sure that you have ""
                           ""not set a swift configuration file with the ""
                           ""'swift_store_config_file' option. ""
                           ""Excluding `%s:%s` store details from the ""
                           ""response as it's not configured correctly.""
                           % (backend, enabled_backends[backend]))
                    LOG.warning(_LW(msg))
                    continue"
43,apps/glance/glance/api/v2/discovery.py,swift_store_config_file,get_stores.swift_store_config_file,swift_store_multi_tenant,swift_store_multi_tenant,"if enabled_backends[backend] == 'swift':
                conf_file = getattr(CONF, backend).swift_store_config_file
                multitenant = getattr(CONF, backend).swift_store_multi_tenant
                if multitenant and conf_file:
                    msg = (""The config options 'swift_store_multi_tenant' ""
                           ""and 'swift_store_config_file' are mutually ""
                           ""exclusive. If you intend to use multi-tenant ""
                           ""swift store, please make sure that you have ""
                           ""not set a swift configuration file with the ""
                           ""'swift_store_config_file' option. ""
                           ""Excluding `%s:%s` store details from the ""
                           ""response as it's not configured correctly.""
                           % (backend, enabled_backends[backend]))
                    LOG.warning(_LW(msg))
                    continue"
44,apps/glance/glance/api/v2/discovery.py,swift_store_config_file,swift_store_config_file,swift_store_multi_tenant,get_stores.swift_store_multi_tenant,"if enabled_backends[backend] == 'swift':
                conf_file = getattr(CONF, backend).swift_store_config_file
                multitenant = getattr(CONF, backend).swift_store_multi_tenant
                if multitenant and conf_file:
                    msg = (""The config options 'swift_store_multi_tenant' ""
                           ""and 'swift_store_config_file' are mutually ""
                           ""exclusive. If you intend to use multi-tenant ""
                           ""swift store, please make sure that you have ""
                           ""not set a swift configuration file with the ""
                           ""'swift_store_config_file' option. ""
                           ""Excluding `%s:%s` store details from the ""
                           ""response as it's not configured correctly.""
                           % (backend, enabled_backends[backend]))
                    LOG.warning(_LW(msg))
                    continue"
45,apps/glance/glance/api/v2/discovery.py,swift_store_config_file,swift_store_config_file,swift_store_multi_tenant,swift_store_multi_tenant,"if enabled_backends[backend] == 'swift':
                conf_file = getattr(CONF, backend).swift_store_config_file
                multitenant = getattr(CONF, backend).swift_store_multi_tenant
                if multitenant and conf_file:
                    msg = (""The config options 'swift_store_multi_tenant' ""
                           ""and 'swift_store_config_file' are mutually ""
                           ""exclusive. If you intend to use multi-tenant ""
                           ""swift store, please make sure that you have ""
                           ""not set a swift configuration file with the ""
                           ""'swift_store_config_file' option. ""
                           ""Excluding `%s:%s` store details from the ""
                           ""response as it's not configured correctly.""
                           % (backend, enabled_backends[backend]))
                    LOG.warning(_LW(msg))
                    continue"
46,apps/glance/glance/api/v2/discovery.py,enabled,get_stores.enabled_backends,swift_store_multi_tenant,get_stores.swift_store_multi_tenant,"if enabled_backends[backend] == 'swift':
                conf_file = getattr(CONF, backend).swift_store_config_file
                multitenant = getattr(CONF, backend).swift_store_multi_tenant
                if multitenant and conf_file:
                    msg = (""The config options 'swift_store_multi_tenant' ""
                           ""and 'swift_store_config_file' are mutually ""
                           ""exclusive. If you intend to use multi-tenant ""
                           ""swift store, please make sure that you have ""
                           ""not set a swift configuration file with the ""
                           ""'swift_store_config_file' option. ""
                           ""Excluding `%s:%s` store details from the ""
                           ""response as it's not configured correctly.""
                           % (backend, enabled_backends[backend]))
                    LOG.warning(_LW(msg))
                    continue"
47,apps/glance/glance/api/v2/discovery.py,enabled,get_stores.enabled_backends,swift_store_multi_tenant,swift_store_multi_tenant,"if enabled_backends[backend] == 'swift':
                conf_file = getattr(CONF, backend).swift_store_config_file
                multitenant = getattr(CONF, backend).swift_store_multi_tenant
                if multitenant and conf_file:
                    msg = (""The config options 'swift_store_multi_tenant' ""
                           ""and 'swift_store_config_file' are mutually ""
                           ""exclusive. If you intend to use multi-tenant ""
                           ""swift store, please make sure that you have ""
                           ""not set a swift configuration file with the ""
                           ""'swift_store_config_file' option. ""
                           ""Excluding `%s:%s` store details from the ""
                           ""response as it's not configured correctly.""
                           % (backend, enabled_backends[backend]))
                    LOG.warning(_LW(msg))
                    continue"
48,apps/glance/glance/api/v2/discovery.py,enabled_backends,get_stores.enabled_backends,swift_store_config_file,get_stores.swift_store_config_file,"if enabled_backends[backend] == 'swift':
                conf_file = getattr(CONF, backend).swift_store_config_file
                multitenant = getattr(CONF, backend).swift_store_multi_tenant
                if multitenant and conf_file:
                    msg = (""The config options 'swift_store_multi_tenant' ""
                           ""and 'swift_store_config_file' are mutually ""
                           ""exclusive. If you intend to use multi-tenant ""
                           ""swift store, please make sure that you have ""
                           ""not set a swift configuration file with the ""
                           ""'swift_store_config_file' option. ""
                           ""Excluding `%s:%s` store details from the ""
                           ""response as it's not configured correctly.""
                           % (backend, enabled_backends[backend]))
                    LOG.warning(_LW(msg))
                    continue"
49,apps/glance/glance/api/v2/discovery.py,enabled_backends,get_stores.enabled_backends,swift_store_config_file,swift_store_config_file,"if enabled_backends[backend] == 'swift':
                conf_file = getattr(CONF, backend).swift_store_config_file
                multitenant = getattr(CONF, backend).swift_store_multi_tenant
                if multitenant and conf_file:
                    msg = (""The config options 'swift_store_multi_tenant' ""
                           ""and 'swift_store_config_file' are mutually ""
                           ""exclusive. If you intend to use multi-tenant ""
                           ""swift store, please make sure that you have ""
                           ""not set a swift configuration file with the ""
                           ""'swift_store_config_file' option. ""
                           ""Excluding `%s:%s` store details from the ""
                           ""response as it's not configured correctly.""
                           % (backend, enabled_backends[backend]))
                    LOG.warning(_LW(msg))
                    continue"
50,apps/glance/glance/api/v2/discovery.py,enabled_backends,get_stores.enabled_backends,swift_store_multi_tenant,get_stores.swift_store_multi_tenant,"if enabled_backends[backend] == 'swift':
                conf_file = getattr(CONF, backend).swift_store_config_file
                multitenant = getattr(CONF, backend).swift_store_multi_tenant
                if multitenant and conf_file:
                    msg = (""The config options 'swift_store_multi_tenant' ""
                           ""and 'swift_store_config_file' are mutually ""
                           ""exclusive. If you intend to use multi-tenant ""
                           ""swift store, please make sure that you have ""
                           ""not set a swift configuration file with the ""
                           ""'swift_store_config_file' option. ""
                           ""Excluding `%s:%s` store details from the ""
                           ""response as it's not configured correctly.""
                           % (backend, enabled_backends[backend]))
                    LOG.warning(_LW(msg))
                    continue"
51,apps/glance/glance/api/v2/discovery.py,enabled_backends,get_stores.enabled_backends,swift_store_multi_tenant,swift_store_multi_tenant,"if enabled_backends[backend] == 'swift':
                conf_file = getattr(CONF, backend).swift_store_config_file
                multitenant = getattr(CONF, backend).swift_store_multi_tenant
                if multitenant and conf_file:
                    msg = (""The config options 'swift_store_multi_tenant' ""
                           ""and 'swift_store_config_file' are mutually ""
                           ""exclusive. If you intend to use multi-tenant ""
                           ""swift store, please make sure that you have ""
                           ""not set a swift configuration file with the ""
                           ""'swift_store_config_file' option. ""
                           ""Excluding `%s:%s` store details from the ""
                           ""response as it's not configured correctly.""
                           % (backend, enabled_backends[backend]))
                    LOG.warning(_LW(msg))
                    continue"
52,apps/glance/glance/api/v2/discovery.py,enabled,get_stores.enabled_backends,enabled_backends,get_stores.enabled_backends,"if enabled_backends[backend] == 'swift':
                conf_file = getattr(CONF, backend).swift_store_config_file
                multitenant = getattr(CONF, backend).swift_store_multi_tenant
                if multitenant and conf_file:
                    msg = (""The config options 'swift_store_multi_tenant' ""
                           ""and 'swift_store_config_file' are mutually ""
                           ""exclusive. If you intend to use multi-tenant ""
                           ""swift store, please make sure that you have ""
                           ""not set a swift configuration file with the ""
                           ""'swift_store_config_file' option. ""
                           ""Excluding `%s:%s` store details from the ""
                           ""response as it's not configured correctly.""
                           % (backend, enabled_backends[backend]))
                    LOG.warning(_LW(msg))
                    continue"
53,apps/glance/glance/api/v2/discovery.py,enabled,get_stores.enabled_backends,enabled_backends,get_stores.enabled_backends,"if multitenant and conf_file:
                    msg = (""The config options 'swift_store_multi_tenant' ""
                           ""and 'swift_store_config_file' are mutually ""
                           ""exclusive. If you intend to use multi-tenant ""
                           ""swift store, please make sure that you have ""
                           ""not set a swift configuration file with the ""
                           ""'swift_store_config_file' option. ""
                           ""Excluding `%s:%s` store details from the ""
                           ""response as it's not configured correctly.""
                           % (backend, enabled_backends[backend]))
                    LOG.warning(_LW(msg))
                    continue"
54,apps/glance/glance/api/v2/discovery.py,enabled,get_stores_detail.enabled_backends,enabled_backends,get_stores_detail.enabled_backends,"try:
            api_policy.DiscoveryAPIPolicy(
                req.context,
                enforcer=self.policy).stores_info_detail()

            store_mapper = {
                'rbd': self._get_rbd_properties,
                'file': self._get_file_properties,
                'cinder': self._get_cinder_properties,
                'swift': self._get_swift_properties,
                's3': self._get_s3_properties,
                'http': self._get_http_properties
            }

            for store in stores:
                store_type = enabled_backends[store['id']]
                store['type'] = store_type
                store_detail = g_store.get_store_from_store_identifier(
                    store['id'])
                store['properties'] = store_mapper.get(store_type)(
                    store_detail)
                store['weight'] = getattr(CONF, store['id']).weight

        except exception.Forbidden as e:
            LOG.debug(""User not permitted to view details"")
            raise webob.exc.HTTPForbidden(explanation=e.msg)"
55,apps/glance/glance/api/v2/discovery.py,debug,LOG.debug,enabled,get_stores_detail.enabled_backends,"try:
            api_policy.DiscoveryAPIPolicy(
                req.context,
                enforcer=self.policy).stores_info_detail()

            store_mapper = {
                'rbd': self._get_rbd_properties,
                'file': self._get_file_properties,
                'cinder': self._get_cinder_properties,
                'swift': self._get_swift_properties,
                's3': self._get_s3_properties,
                'http': self._get_http_properties
            }

            for store in stores:
                store_type = enabled_backends[store['id']]
                store['type'] = store_type
                store_detail = g_store.get_store_from_store_identifier(
                    store['id'])
                store['properties'] = store_mapper.get(store_type)(
                    store_detail)
                store['weight'] = getattr(CONF, store['id']).weight

        except exception.Forbidden as e:
            LOG.debug(""User not permitted to view details"")
            raise webob.exc.HTTPForbidden(explanation=e.msg)"
56,apps/glance/glance/api/v2/discovery.py,debug,LOG.debug,enabled_backends,get_stores_detail.enabled_backends,"try:
            api_policy.DiscoveryAPIPolicy(
                req.context,
                enforcer=self.policy).stores_info_detail()

            store_mapper = {
                'rbd': self._get_rbd_properties,
                'file': self._get_file_properties,
                'cinder': self._get_cinder_properties,
                'swift': self._get_swift_properties,
                's3': self._get_s3_properties,
                'http': self._get_http_properties
            }

            for store in stores:
                store_type = enabled_backends[store['id']]
                store['type'] = store_type
                store_detail = g_store.get_store_from_store_identifier(
                    store['id'])
                store['properties'] = store_mapper.get(store_type)(
                    store_detail)
                store['weight'] = getattr(CONF, store['id']).weight

        except exception.Forbidden as e:
            LOG.debug(""User not permitted to view details"")
            raise webob.exc.HTTPForbidden(explanation=e.msg)"
57,apps/glance/glance/api/v2/image_data.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"LOG.exception(msg)

    def _unstage(self, image_repo, image, staging_store):
        """"""
        Restore the image to queued status and remove data from staging.

        :param image_repo: The instance of ImageRepo
        :param image: The image will be restored
        :param staging_store: The store used for staging
        """"""
        if CONF.enabled_backends:
            file_path = ""%s/%s"" % (getattr(
                CONF, 'os_glance_staging_store').filesystem_store_datadir,
                image.image_id)
            try:
                loc = location.get_location_from_uri_and_backend(
                    file_path, 'os_glance_staging_store')
                staging_store.delete(loc)
            except (glance_store.exceptions.NotFound,
                    glance_store.exceptions.UnknownScheme):"
58,apps/glance/glance/api/v2/image_data.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"@utils.mutating
    def upload(self, req, image_id, data, size):
        try:
            ks_quota.enforce_image_size_total(req.context, req.context.owner)
        except exception.LimitExceeded as e:
            raise webob.exc.HTTPRequestEntityTooLarge(explanation=str(e),
                                                      request=req)

        backend = None
        if CONF.enabled_backends:
            backend = req.headers.get('x-image-meta-store',
                                      CONF.glance_store.default_backend)

            try:
                glance_store.get_store_from_store_identifier(backend)
            except glance_store.UnknownScheme as exc:
                raise webob.exc.HTTPBadRequest(explanation=exc.msg,
                                               request=req,
                                               content_type='text/plain')"
59,apps/glance/glance/api/v2/image_data.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"staging_store.configure()
            except AttributeError:
                msg = _(""'node_staging_uri' is not set correctly. Could not ""
                        ""load staging store."")
                raise exception.BadStoreUri(message=msg)
            return staging_store

        # NOTE(abhishekk): Use reserved 'os_glance_staging_store' for staging
        # the data, the else part will be removed once multiple backend feature
        # is declared as stable.
        if CONF.enabled_backends:
            staging_store = glance_store.get_store_from_store_identifier(
                'os_glance_staging_store')
        else:
            staging_store = _build_staging_store()

        try:
            image.status = 'uploading'
            image_repo.save(image, from_state='queued')
            ks_quota.enforce_image_count_uploading(req.context,"
60,apps/glance/glance/api/v2/image_data.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"if CONF.enabled_backends:
            file_path = ""%s/%s"" % (getattr(
                CONF, 'os_glance_staging_store').filesystem_store_datadir,
                image.image_id)
            try:
                loc = location.get_location_from_uri_and_backend(
                    file_path, 'os_glance_staging_store')
                staging_store.delete(loc)
            except (glance_store.exceptions.NotFound,
                    glance_store.exceptions.UnknownScheme):
                pass
        else:
            file_path = str(CONF.node_staging_uri + '/' + image.image_id)[7:]
            if os.path.exists(file_path):
                try:
                    os.unlink(file_path)
                except OSError as e:
                    LOG.error(_(""Cannot delete staged image data %(fn)s ""
                                ""[Errno %(en)d]""), {'fn': file_path,
                                                    'en': e.errno})
            else:
                LOG.warning(_(""Staged image data not found ""
                              ""at %(fn)s""), {'fn': file_path})"
61,apps/glance/glance/api/v2/image_data.py,enabled_backends,CONF.enabled_backends,filesystem_store_datadir,_unstage.filesystem_store_datadir,"if CONF.enabled_backends:
            file_path = ""%s/%s"" % (getattr(
                CONF, 'os_glance_staging_store').filesystem_store_datadir,
                image.image_id)
            try:
                loc = location.get_location_from_uri_and_backend(
                    file_path, 'os_glance_staging_store')
                staging_store.delete(loc)
            except (glance_store.exceptions.NotFound,
                    glance_store.exceptions.UnknownScheme):
                pass
        else:
            file_path = str(CONF.node_staging_uri + '/' + image.image_id)[7:]
            if os.path.exists(file_path):
                try:
                    os.unlink(file_path)
                except OSError as e:
                    LOG.error(_(""Cannot delete staged image data %(fn)s ""
                                ""[Errno %(en)d]""), {'fn': file_path,
                                                    'en': e.errno})
            else:
                LOG.warning(_(""Staged image data not found ""
                              ""at %(fn)s""), {'fn': file_path})"
62,apps/glance/glance/api/v2/image_data.py,enabled_backends,CONF.enabled_backends,filesystem_store_datadir,filesystem_store_datadir,"if CONF.enabled_backends:
            file_path = ""%s/%s"" % (getattr(
                CONF, 'os_glance_staging_store').filesystem_store_datadir,
                image.image_id)
            try:
                loc = location.get_location_from_uri_and_backend(
                    file_path, 'os_glance_staging_store')
                staging_store.delete(loc)
            except (glance_store.exceptions.NotFound,
                    glance_store.exceptions.UnknownScheme):
                pass
        else:
            file_path = str(CONF.node_staging_uri + '/' + image.image_id)[7:]
            if os.path.exists(file_path):
                try:
                    os.unlink(file_path)
                except OSError as e:
                    LOG.error(_(""Cannot delete staged image data %(fn)s ""
                                ""[Errno %(en)d]""), {'fn': file_path,
                                                    'en': e.errno})
            else:
                LOG.warning(_(""Staged image data not found ""
                              ""at %(fn)s""), {'fn': file_path})"
63,apps/glance/glance/api/v2/image_data.py,enabled_backends,CONF.enabled_backends,filesystem_store_datadir,_unstage.file_path,"if CONF.enabled_backends:
            file_path = ""%s/%s"" % (getattr(
                CONF, 'os_glance_staging_store').filesystem_store_datadir,
                image.image_id)
            try:
                loc = location.get_location_from_uri_and_backend(
                    file_path, 'os_glance_staging_store')
                staging_store.delete(loc)
            except (glance_store.exceptions.NotFound,
                    glance_store.exceptions.UnknownScheme):
                pass
        else:
            file_path = str(CONF.node_staging_uri + '/' + image.image_id)[7:]
            if os.path.exists(file_path):
                try:
                    os.unlink(file_path)
                except OSError as e:
                    LOG.error(_(""Cannot delete staged image data %(fn)s ""
                                ""[Errno %(en)d]""), {'fn': file_path,
                                                    'en': e.errno})
            else:
                LOG.warning(_(""Staged image data not found ""
                              ""at %(fn)s""), {'fn': file_path})"
64,apps/glance/glance/api/v2/image_data.py,enabled,CONF.enabled_backends,filesystem_store_datadir,_unstage.filesystem_store_datadir,"if CONF.enabled_backends:
            file_path = ""%s/%s"" % (getattr(
                CONF, 'os_glance_staging_store').filesystem_store_datadir,
                image.image_id)
            try:
                loc = location.get_location_from_uri_and_backend(
                    file_path, 'os_glance_staging_store')
                staging_store.delete(loc)
            except (glance_store.exceptions.NotFound,
                    glance_store.exceptions.UnknownScheme):
                pass
        else:
            file_path = str(CONF.node_staging_uri + '/' + image.image_id)[7:]
            if os.path.exists(file_path):
                try:
                    os.unlink(file_path)
                except OSError as e:
                    LOG.error(_(""Cannot delete staged image data %(fn)s ""
                                ""[Errno %(en)d]""), {'fn': file_path,
                                                    'en': e.errno})
            else:
                LOG.warning(_(""Staged image data not found ""
                              ""at %(fn)s""), {'fn': file_path})"
65,apps/glance/glance/api/v2/image_data.py,enabled,CONF.enabled_backends,filesystem_store_datadir,filesystem_store_datadir,"if CONF.enabled_backends:
            file_path = ""%s/%s"" % (getattr(
                CONF, 'os_glance_staging_store').filesystem_store_datadir,
                image.image_id)
            try:
                loc = location.get_location_from_uri_and_backend(
                    file_path, 'os_glance_staging_store')
                staging_store.delete(loc)
            except (glance_store.exceptions.NotFound,
                    glance_store.exceptions.UnknownScheme):
                pass
        else:
            file_path = str(CONF.node_staging_uri + '/' + image.image_id)[7:]
            if os.path.exists(file_path):
                try:
                    os.unlink(file_path)
                except OSError as e:
                    LOG.error(_(""Cannot delete staged image data %(fn)s ""
                                ""[Errno %(en)d]""), {'fn': file_path,
                                                    'en': e.errno})
            else:
                LOG.warning(_(""Staged image data not found ""
                              ""at %(fn)s""), {'fn': file_path})"
66,apps/glance/glance/api/v2/image_data.py,enabled,CONF.enabled_backends,filesystem_store_datadir,_unstage.file_path,"if CONF.enabled_backends:
            file_path = ""%s/%s"" % (getattr(
                CONF, 'os_glance_staging_store').filesystem_store_datadir,
                image.image_id)
            try:
                loc = location.get_location_from_uri_and_backend(
                    file_path, 'os_glance_staging_store')
                staging_store.delete(loc)
            except (glance_store.exceptions.NotFound,
                    glance_store.exceptions.UnknownScheme):
                pass
        else:
            file_path = str(CONF.node_staging_uri + '/' + image.image_id)[7:]
            if os.path.exists(file_path):
                try:
                    os.unlink(file_path)
                except OSError as e:
                    LOG.error(_(""Cannot delete staged image data %(fn)s ""
                                ""[Errno %(en)d]""), {'fn': file_path,
                                                    'en': e.errno})
            else:
                LOG.warning(_(""Staged image data not found ""
                              ""at %(fn)s""), {'fn': file_path})"
67,apps/glance/glance/api/v2/image_data.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"if CONF.enabled_backends:
            backend = req.headers.get('x-image-meta-store',
                                      CONF.glance_store.default_backend)

            try:
                glance_store.get_store_from_store_identifier(backend)
            except glance_store.UnknownScheme as exc:
                raise webob.exc.HTTPBadRequest(explanation=exc.msg,
                                               request=req,
                                               content_type='text/plain')"
68,apps/glance/glance/api/v2/image_data.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"if CONF.enabled_backends:
            staging_store = glance_store.get_store_from_store_identifier(
                'os_glance_staging_store')
        else:
            staging_store = _build_staging_store()"
69,apps/glance/glance/api/v2/image_data.py,debug,LOG.debug,user,upload.user_plugin,"try:
            image = image_repo.get(image_id)
            # NOTE(abhishekk): This is the right place to check whether user
            # have permission to upload the image and remove the policy check
            # later from the policy layer.
            api_pol = api_policy.ImageAPIPolicy(req.context, image,
                                                self.policy)
            api_pol.upload_image()
            image.status = 'saving'
            try:
                # create a trust if backend is registry
                try:
                    # request user plugin for current token
                    user_plugin = req.environ.get('keystone.token_auth')
                    roles = []
                    # use roles from request environment because they
                    # are not transformed to lower-case unlike cxt.roles
                    for role_info in req.environ.get(
                            'keystone.token_info')['token']['roles']:
                        roles.append(role_info['name'])
                    refresher = trust_auth.TokenRefresher(user_plugin,
                                                          cxt.project_id,
                                                          roles)
                except Exception as e:
                    LOG.info(_LI(""Unable to create trust: %s ""
                                 ""Use the existing user token.""),
                             encodeutils.exception_to_unicode(e))

                image_repo.save(image, from_state='queued')
                ks_quota.enforce_image_count_uploading(req.context,
                                                       req.context.owner)
                image.set_data(data, size, backend=backend)

                try:
                    image_repo.save(image, from_state='saving')
                except exception.NotAuthenticated:
                    if refresher is not None:
                        # request a new token to update an image in database
                        cxt.auth_token = refresher.refresh_token()
                        image_repo.save(image, from_state='saving')
                    else:
                        raise

                try:
                    # release resources required for re-auth
                    if refresher is not None:
                        refresher.release_resources()
                except Exception as e:
                    LOG.info(_LI(""Unable to delete trust %(trust)s: %(msg)s""),
                             {""trust"": refresher.trust_id,
                              ""msg"": encodeutils.exception_to_unicode(e)})

            except (glance_store.NotFound,
                    exception.ImageNotFound,
                    exception.Conflict):
                msg = (_(""Image %s could not be found after upload. ""
                         ""The image may have been deleted during the ""
                         ""upload, cleaning up the chunks uploaded."") %
                       image_id)
                LOG.warning(msg)
                # NOTE(sridevi): Cleaning up the uploaded chunks.
                try:
                    image.delete()
                except exception.ImageNotFound:
                    # NOTE(sridevi): Ignore this exception
                    pass
                raise webob.exc.HTTPGone(explanation=msg,
                                         request=req,
                                         content_type='text/plain')
            except exception.NotAuthenticated:
                msg = (_(""Authentication error - the token may have ""
                         ""expired during file upload. Deleting image data for ""
                         ""%s."") % image_id)
                LOG.debug(msg)
                try:
                    image.delete()
                except exception.NotAuthenticated:
                    # NOTE: Ignore this exception
                    pass
                raise webob.exc.HTTPUnauthorized(explanation=msg,
                                                 request=req,
                                                 content_type='text/plain')
        except ValueError as e:
            LOG.debug(""Cannot save data for image %(id)s: %(e)s"",
                      {'id': image_id,
                       'e': encodeutils.exception_to_unicode(e)})
            self._restore(image_repo, image)
            raise webob.exc.HTTPBadRequest(
                explanation=encodeutils.exception_to_unicode(e))

        except glance_store.StoreAddDisabled:
            msg = _(""Error in store configuration. Adding images to store ""
                    ""is disabled."")
            LOG.exception(msg)
            self._restore(image_repo, image)
            raise webob.exc.HTTPGone(explanation=msg, request=req,
                                     content_type='text/plain')

        except exception.InvalidImageStatusTransition as e:
            msg = encodeutils.exception_to_unicode(e)
            LOG.exception(msg)
            raise webob.exc.HTTPConflict(explanation=e.msg, request=req)

        except exception.Forbidden:
            msg = (""Not allowed to upload image data for image %s"" %
                   image_id)
            LOG.debug(msg)
            raise webob.exc.HTTPForbidden(explanation=msg, request=req)

        except exception.NotFound as e:
            raise webob.exc.HTTPNotFound(explanation=e.msg)

        except glance_store.StorageFull as e:
            msg = _(""Image storage media ""
                    ""is full: %s"") % encodeutils.exception_to_unicode(e)
            LOG.error(msg)
            self._restore(image_repo, image)
            raise webob.exc.HTTPRequestEntityTooLarge(explanation=msg,
                                                      request=req)

        except exception.StorageQuotaFull as e:
            msg = _(""Image exceeds the storage ""
                    ""quota: %s"") % encodeutils.exception_to_unicode(e)
            LOG.error(msg)
            self._restore(image_repo, image)
            raise webob.exc.HTTPRequestEntityTooLarge(explanation=msg,
                                                      request=req)

        except exception.ImageSizeLimitExceeded as e:
            msg = _(""The incoming image is ""
                    ""too large: %s"") % encodeutils.exception_to_unicode(e)
            LOG.error(msg)
            self._restore(image_repo, image)
            raise webob.exc.HTTPRequestEntityTooLarge(explanation=msg,
                                                      request=req)

        except exception.LimitExceeded as e:
            LOG.error(str(e))
            self._restore(image_repo, image)
            raise webob.exc.HTTPRequestEntityTooLarge(explanation=str(e),
                                                      request=req)

        except exception.InvalidImageData as e:
            LOG.error(str(e))
            self._restore(image_repo, image)
            raise webob.exc.HTTPUnsupportedMediaType(explanation=str(e),
                                                     request=req)

        except glance_store.StorageWriteDenied as e:
            msg = _(""Insufficient permissions on image ""
                    ""storage media: %s"") % encodeutils.exception_to_unicode(e)
            LOG.error(msg)
            self._restore(image_repo, image)
            raise webob.exc.HTTPServiceUnavailable(explanation=msg,
                                                   request=req)

        except cursive_exception.SignatureVerificationError as e:
            msg = (_LE(""Signature verification failed for image %(id)s: %(e)s"")
                   % {'id': image_id,
                      'e': encodeutils.exception_to_unicode(e)})
            LOG.error(msg)
            self._restore(image_repo, image)
            raise webob.exc.HTTPBadRequest(explanation=msg)

        except webob.exc.HTTPGone:
            with excutils.save_and_reraise_exception():
                LOG.error(_LE(""Failed to upload image data due to HTTP error""))

        except webob.exc.HTTPError:
            with excutils.save_and_reraise_exception():
                LOG.error(_LE(""Failed to upload image data due to HTTP error""))
                self._restore(image_repo, image)

        except Exception:
            with excutils.save_and_reraise_exception():
                LOG.error(_LE(""Failed to upload image data due to ""
                              ""internal error""))
                self._restore(image_repo, image)"
70,apps/glance/glance/api/v2/image_data.py,debug,LOG.debug,user,upload.user_plugin,"try:
                # create a trust if backend is registry
                try:
                    # request user plugin for current token
                    user_plugin = req.environ.get('keystone.token_auth')
                    roles = []
                    # use roles from request environment because they
                    # are not transformed to lower-case unlike cxt.roles
                    for role_info in req.environ.get(
                            'keystone.token_info')['token']['roles']:
                        roles.append(role_info['name'])
                    refresher = trust_auth.TokenRefresher(user_plugin,
                                                          cxt.project_id,
                                                          roles)
                except Exception as e:
                    LOG.info(_LI(""Unable to create trust: %s ""
                                 ""Use the existing user token.""),
                             encodeutils.exception_to_unicode(e))

                image_repo.save(image, from_state='queued')
                ks_quota.enforce_image_count_uploading(req.context,
                                                       req.context.owner)
                image.set_data(data, size, backend=backend)

                try:
                    image_repo.save(image, from_state='saving')
                except exception.NotAuthenticated:
                    if refresher is not None:
                        # request a new token to update an image in database
                        cxt.auth_token = refresher.refresh_token()
                        image_repo.save(image, from_state='saving')
                    else:
                        raise

                try:
                    # release resources required for re-auth
                    if refresher is not None:
                        refresher.release_resources()
                except Exception as e:
                    LOG.info(_LI(""Unable to delete trust %(trust)s: %(msg)s""),
                             {""trust"": refresher.trust_id,
                              ""msg"": encodeutils.exception_to_unicode(e)})

            except (glance_store.NotFound,
                    exception.ImageNotFound,
                    exception.Conflict):
                msg = (_(""Image %s could not be found after upload. ""
                         ""The image may have been deleted during the ""
                         ""upload, cleaning up the chunks uploaded."") %
                       image_id)
                LOG.warning(msg)
                # NOTE(sridevi): Cleaning up the uploaded chunks.
                try:
                    image.delete()
                except exception.ImageNotFound:
                    # NOTE(sridevi): Ignore this exception
                    pass
                raise webob.exc.HTTPGone(explanation=msg,
                                         request=req,
                                         content_type='text/plain')
            except exception.NotAuthenticated:
                msg = (_(""Authentication error - the token may have ""
                         ""expired during file upload. Deleting image data for ""
                         ""%s."") % image_id)
                LOG.debug(msg)
                try:
                    image.delete()
                except exception.NotAuthenticated:
                    # NOTE: Ignore this exception
                    pass
                raise webob.exc.HTTPUnauthorized(explanation=msg,
                                                 request=req,
                                                 content_type='text/plain')"
71,apps/glance/glance/api/v2/image_data.py,image_size_cap,CONF.image_size_cap,public_endpoint,CONF.public_endpoint,"try:
            image.status = 'uploading'
            image_repo.save(image, from_state='queued')
            ks_quota.enforce_image_count_uploading(req.context,
                                                   req.context.owner)
            try:
                uri, size, id, store_info = staging_store.add(
                    image_id, utils.LimitingReader(
                        utils.CooperativeReader(data), CONF.image_size_cap), 0)
                image.size = size
            except glance_store.Duplicate:
                msg = _(""The image %s has data on staging"") % image_id
                raise webob.exc.HTTPConflict(explanation=msg)

            # NOTE(danms): Record this worker's
            # worker_self_reference_url in the image metadata so we
            # know who has the staging data.
            self_url = CONF.worker_self_reference_url or CONF.public_endpoint
            if self_url:
                image.extra_properties['os_glance_stage_host'] = self_url
            image_repo.save(image, from_state='uploading')

        except exception.NotFound as e:
            raise webob.exc.HTTPNotFound(explanation=e.msg)

        except glance_store.StorageFull as e:
            msg = _(""Image storage media ""
                    ""is full: %s"") % encodeutils.exception_to_unicode(e)
            LOG.error(msg)
            self._unstage(image_repo, image, staging_store)
            raise webob.exc.HTTPRequestEntityTooLarge(explanation=msg,
                                                      request=req)

        except exception.StorageQuotaFull as e:
            msg = _(""Image exceeds the storage ""
                    ""quota: %s"") % encodeutils.exception_to_unicode(e)
            LOG.debug(msg)
            self._unstage(image_repo, image, staging_store)
            raise webob.exc.HTTPRequestEntityTooLarge(explanation=msg,
                                                      request=req)

        except exception.ImageSizeLimitExceeded as e:
            msg = _(""The incoming image is ""
                    ""too large: %s"") % encodeutils.exception_to_unicode(e)
            LOG.debug(msg)
            self._unstage(image_repo, image, staging_store)
            raise webob.exc.HTTPRequestEntityTooLarge(explanation=msg,
                                                      request=req)

        except exception.LimitExceeded as e:
            LOG.debug(str(e))
            self._unstage(image_repo, image, staging_store)
            raise webob.exc.HTTPRequestEntityTooLarge(explanation=str(e),
                                                      request=req)

        except glance_store.StorageWriteDenied as e:
            msg = _(""Insufficient permissions on image ""
                    ""storage media: %s"") % encodeutils.exception_to_unicode(e)
            LOG.error(msg)
            self._unstage(image_repo, image, staging_store)
            raise webob.exc.HTTPServiceUnavailable(explanation=msg,
                                                   request=req)

        except exception.InvalidImageStatusTransition as e:
            msg = encodeutils.exception_to_unicode(e)
            LOG.debug(msg)
            raise webob.exc.HTTPConflict(explanation=e.msg, request=req)

        except Exception:
            with excutils.save_and_reraise_exception():
                LOG.exception(_LE(""Failed to stage image data due to ""
                                  ""internal error""))
                self._restore(image_repo, image)"
72,apps/glance/glance/api/v2/image_data.py,image_size_cap,CONF.image_size_cap,public_endpoint,stage.CONF.public_endpoint,"try:
            image.status = 'uploading'
            image_repo.save(image, from_state='queued')
            ks_quota.enforce_image_count_uploading(req.context,
                                                   req.context.owner)
            try:
                uri, size, id, store_info = staging_store.add(
                    image_id, utils.LimitingReader(
                        utils.CooperativeReader(data), CONF.image_size_cap), 0)
                image.size = size
            except glance_store.Duplicate:
                msg = _(""The image %s has data on staging"") % image_id
                raise webob.exc.HTTPConflict(explanation=msg)

            # NOTE(danms): Record this worker's
            # worker_self_reference_url in the image metadata so we
            # know who has the staging data.
            self_url = CONF.worker_self_reference_url or CONF.public_endpoint
            if self_url:
                image.extra_properties['os_glance_stage_host'] = self_url
            image_repo.save(image, from_state='uploading')

        except exception.NotFound as e:
            raise webob.exc.HTTPNotFound(explanation=e.msg)

        except glance_store.StorageFull as e:
            msg = _(""Image storage media ""
                    ""is full: %s"") % encodeutils.exception_to_unicode(e)
            LOG.error(msg)
            self._unstage(image_repo, image, staging_store)
            raise webob.exc.HTTPRequestEntityTooLarge(explanation=msg,
                                                      request=req)

        except exception.StorageQuotaFull as e:
            msg = _(""Image exceeds the storage ""
                    ""quota: %s"") % encodeutils.exception_to_unicode(e)
            LOG.debug(msg)
            self._unstage(image_repo, image, staging_store)
            raise webob.exc.HTTPRequestEntityTooLarge(explanation=msg,
                                                      request=req)

        except exception.ImageSizeLimitExceeded as e:
            msg = _(""The incoming image is ""
                    ""too large: %s"") % encodeutils.exception_to_unicode(e)
            LOG.debug(msg)
            self._unstage(image_repo, image, staging_store)
            raise webob.exc.HTTPRequestEntityTooLarge(explanation=msg,
                                                      request=req)

        except exception.LimitExceeded as e:
            LOG.debug(str(e))
            self._unstage(image_repo, image, staging_store)
            raise webob.exc.HTTPRequestEntityTooLarge(explanation=str(e),
                                                      request=req)

        except glance_store.StorageWriteDenied as e:
            msg = _(""Insufficient permissions on image ""
                    ""storage media: %s"") % encodeutils.exception_to_unicode(e)
            LOG.error(msg)
            self._unstage(image_repo, image, staging_store)
            raise webob.exc.HTTPServiceUnavailable(explanation=msg,
                                                   request=req)

        except exception.InvalidImageStatusTransition as e:
            msg = encodeutils.exception_to_unicode(e)
            LOG.debug(msg)
            raise webob.exc.HTTPConflict(explanation=e.msg, request=req)

        except Exception:
            with excutils.save_and_reraise_exception():
                LOG.exception(_LE(""Failed to stage image data due to ""
                                  ""internal error""))
                self._restore(image_repo, image)"
73,apps/glance/glance/api/v2/image_data.py,debug,LOG.debug,image_size_cap,CONF.image_size_cap,"try:
            image.status = 'uploading'
            image_repo.save(image, from_state='queued')
            ks_quota.enforce_image_count_uploading(req.context,
                                                   req.context.owner)
            try:
                uri, size, id, store_info = staging_store.add(
                    image_id, utils.LimitingReader(
                        utils.CooperativeReader(data), CONF.image_size_cap), 0)
                image.size = size
            except glance_store.Duplicate:
                msg = _(""The image %s has data on staging"") % image_id
                raise webob.exc.HTTPConflict(explanation=msg)

            # NOTE(danms): Record this worker's
            # worker_self_reference_url in the image metadata so we
            # know who has the staging data.
            self_url = CONF.worker_self_reference_url or CONF.public_endpoint
            if self_url:
                image.extra_properties['os_glance_stage_host'] = self_url
            image_repo.save(image, from_state='uploading')

        except exception.NotFound as e:
            raise webob.exc.HTTPNotFound(explanation=e.msg)

        except glance_store.StorageFull as e:
            msg = _(""Image storage media ""
                    ""is full: %s"") % encodeutils.exception_to_unicode(e)
            LOG.error(msg)
            self._unstage(image_repo, image, staging_store)
            raise webob.exc.HTTPRequestEntityTooLarge(explanation=msg,
                                                      request=req)

        except exception.StorageQuotaFull as e:
            msg = _(""Image exceeds the storage ""
                    ""quota: %s"") % encodeutils.exception_to_unicode(e)
            LOG.debug(msg)
            self._unstage(image_repo, image, staging_store)
            raise webob.exc.HTTPRequestEntityTooLarge(explanation=msg,
                                                      request=req)

        except exception.ImageSizeLimitExceeded as e:
            msg = _(""The incoming image is ""
                    ""too large: %s"") % encodeutils.exception_to_unicode(e)
            LOG.debug(msg)
            self._unstage(image_repo, image, staging_store)
            raise webob.exc.HTTPRequestEntityTooLarge(explanation=msg,
                                                      request=req)

        except exception.LimitExceeded as e:
            LOG.debug(str(e))
            self._unstage(image_repo, image, staging_store)
            raise webob.exc.HTTPRequestEntityTooLarge(explanation=str(e),
                                                      request=req)

        except glance_store.StorageWriteDenied as e:
            msg = _(""Insufficient permissions on image ""
                    ""storage media: %s"") % encodeutils.exception_to_unicode(e)
            LOG.error(msg)
            self._unstage(image_repo, image, staging_store)
            raise webob.exc.HTTPServiceUnavailable(explanation=msg,
                                                   request=req)

        except exception.InvalidImageStatusTransition as e:
            msg = encodeutils.exception_to_unicode(e)
            LOG.debug(msg)
            raise webob.exc.HTTPConflict(explanation=e.msg, request=req)

        except Exception:
            with excutils.save_and_reraise_exception():
                LOG.exception(_LE(""Failed to stage image data due to ""
                                  ""internal error""))
                self._restore(image_repo, image)"
74,apps/glance/glance/api/v2/image_data.py,debug,LOG.debug,public_endpoint,CONF.public_endpoint,"try:
            image.status = 'uploading'
            image_repo.save(image, from_state='queued')
            ks_quota.enforce_image_count_uploading(req.context,
                                                   req.context.owner)
            try:
                uri, size, id, store_info = staging_store.add(
                    image_id, utils.LimitingReader(
                        utils.CooperativeReader(data), CONF.image_size_cap), 0)
                image.size = size
            except glance_store.Duplicate:
                msg = _(""The image %s has data on staging"") % image_id
                raise webob.exc.HTTPConflict(explanation=msg)

            # NOTE(danms): Record this worker's
            # worker_self_reference_url in the image metadata so we
            # know who has the staging data.
            self_url = CONF.worker_self_reference_url or CONF.public_endpoint
            if self_url:
                image.extra_properties['os_glance_stage_host'] = self_url
            image_repo.save(image, from_state='uploading')

        except exception.NotFound as e:
            raise webob.exc.HTTPNotFound(explanation=e.msg)

        except glance_store.StorageFull as e:
            msg = _(""Image storage media ""
                    ""is full: %s"") % encodeutils.exception_to_unicode(e)
            LOG.error(msg)
            self._unstage(image_repo, image, staging_store)
            raise webob.exc.HTTPRequestEntityTooLarge(explanation=msg,
                                                      request=req)

        except exception.StorageQuotaFull as e:
            msg = _(""Image exceeds the storage ""
                    ""quota: %s"") % encodeutils.exception_to_unicode(e)
            LOG.debug(msg)
            self._unstage(image_repo, image, staging_store)
            raise webob.exc.HTTPRequestEntityTooLarge(explanation=msg,
                                                      request=req)

        except exception.ImageSizeLimitExceeded as e:
            msg = _(""The incoming image is ""
                    ""too large: %s"") % encodeutils.exception_to_unicode(e)
            LOG.debug(msg)
            self._unstage(image_repo, image, staging_store)
            raise webob.exc.HTTPRequestEntityTooLarge(explanation=msg,
                                                      request=req)

        except exception.LimitExceeded as e:
            LOG.debug(str(e))
            self._unstage(image_repo, image, staging_store)
            raise webob.exc.HTTPRequestEntityTooLarge(explanation=str(e),
                                                      request=req)

        except glance_store.StorageWriteDenied as e:
            msg = _(""Insufficient permissions on image ""
                    ""storage media: %s"") % encodeutils.exception_to_unicode(e)
            LOG.error(msg)
            self._unstage(image_repo, image, staging_store)
            raise webob.exc.HTTPServiceUnavailable(explanation=msg,
                                                   request=req)

        except exception.InvalidImageStatusTransition as e:
            msg = encodeutils.exception_to_unicode(e)
            LOG.debug(msg)
            raise webob.exc.HTTPConflict(explanation=e.msg, request=req)

        except Exception:
            with excutils.save_and_reraise_exception():
                LOG.exception(_LE(""Failed to stage image data due to ""
                                  ""internal error""))
                self._restore(image_repo, image)"
75,apps/glance/glance/api/v2/image_data.py,debug,LOG.debug,public_endpoint,stage.CONF.public_endpoint,"try:
            image.status = 'uploading'
            image_repo.save(image, from_state='queued')
            ks_quota.enforce_image_count_uploading(req.context,
                                                   req.context.owner)
            try:
                uri, size, id, store_info = staging_store.add(
                    image_id, utils.LimitingReader(
                        utils.CooperativeReader(data), CONF.image_size_cap), 0)
                image.size = size
            except glance_store.Duplicate:
                msg = _(""The image %s has data on staging"") % image_id
                raise webob.exc.HTTPConflict(explanation=msg)

            # NOTE(danms): Record this worker's
            # worker_self_reference_url in the image metadata so we
            # know who has the staging data.
            self_url = CONF.worker_self_reference_url or CONF.public_endpoint
            if self_url:
                image.extra_properties['os_glance_stage_host'] = self_url
            image_repo.save(image, from_state='uploading')

        except exception.NotFound as e:
            raise webob.exc.HTTPNotFound(explanation=e.msg)

        except glance_store.StorageFull as e:
            msg = _(""Image storage media ""
                    ""is full: %s"") % encodeutils.exception_to_unicode(e)
            LOG.error(msg)
            self._unstage(image_repo, image, staging_store)
            raise webob.exc.HTTPRequestEntityTooLarge(explanation=msg,
                                                      request=req)

        except exception.StorageQuotaFull as e:
            msg = _(""Image exceeds the storage ""
                    ""quota: %s"") % encodeutils.exception_to_unicode(e)
            LOG.debug(msg)
            self._unstage(image_repo, image, staging_store)
            raise webob.exc.HTTPRequestEntityTooLarge(explanation=msg,
                                                      request=req)

        except exception.ImageSizeLimitExceeded as e:
            msg = _(""The incoming image is ""
                    ""too large: %s"") % encodeutils.exception_to_unicode(e)
            LOG.debug(msg)
            self._unstage(image_repo, image, staging_store)
            raise webob.exc.HTTPRequestEntityTooLarge(explanation=msg,
                                                      request=req)

        except exception.LimitExceeded as e:
            LOG.debug(str(e))
            self._unstage(image_repo, image, staging_store)
            raise webob.exc.HTTPRequestEntityTooLarge(explanation=str(e),
                                                      request=req)

        except glance_store.StorageWriteDenied as e:
            msg = _(""Insufficient permissions on image ""
                    ""storage media: %s"") % encodeutils.exception_to_unicode(e)
            LOG.error(msg)
            self._unstage(image_repo, image, staging_store)
            raise webob.exc.HTTPServiceUnavailable(explanation=msg,
                                                   request=req)

        except exception.InvalidImageStatusTransition as e:
            msg = encodeutils.exception_to_unicode(e)
            LOG.debug(msg)
            raise webob.exc.HTTPConflict(explanation=e.msg, request=req)

        except Exception:
            with excutils.save_and_reraise_exception():
                LOG.exception(_LE(""Failed to stage image data due to ""
                                  ""internal error""))
                self._restore(image_repo, image)"
76,apps/glance/glance/api/v2/images.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"# NOTE(abhishekk): We need to perform ownership check on image
                # so that non-admin or non-owner can not import data to image
                api_pol.modify_image()

            if 'os_glance_import_task' in image.extra_properties:
                # NOTE(danms): This will raise exception.Conflict if the
                # lock is present and valid, or return if absent or invalid.
                stole_lock_from_task = self._enforce_import_lock(req, image)

            stores = [None]
            if CONF.enabled_backends:
                try:
                    stores = utils.get_stores_from_request(req, body)
                except glance_store.UnknownScheme as exc:
                    LOG.warning(exc.msg)
                    raise exception.Conflict(exc.msg)

            # NOTE(abhishekk): If all_stores is specified and import_method is
            # copy_image, then remove those stores where image is already
            # present."
77,apps/glance/glance/api/v2/images.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"msg = _(""Image is already present at store ""
                                ""'%s'"") % existing_store
                        raise webob.exc.HTTPBadRequest(explanation=msg)
        except exception.Conflict as e:
            raise webob.exc.HTTPConflict(explanation=e.msg)
        except exception.NotFound as e:
            raise webob.exc.HTTPNotFound(explanation=e.msg)
        except exception.Forbidden as e:
            raise webob.exc.HTTPForbidden(explanation=e.msg)

        if (not all_stores_must_succeed) and (not CONF.enabled_backends):
            msg = (_(""All_stores_must_succeed can only be set with ""
                     ""enabled_backends %s"") % uri)
            raise webob.exc.HTTPBadRequest(explanation=msg)

        if self.is_proxyable(image) and import_method == 'glance-direct':
            # NOTE(danms): Image is staged on another worker; proxy the
            # import request to that worker with the user's token, as if
            # they had called it themselves.
            return self._proxy_request_to_stage_host(image, req, body)"
78,apps/glance/glance/api/v2/images.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"except (castellan_exception.ManagedObjectNotFoundError, KeyError):
            msg = 'Could not find encryption key %s' % cinder_encryption_key_id
            LOG.warning(msg)
        except castellan_exception.KeyManagerError:
            msg = ('Failed to delete cinder encryption key %s' %
                   cinder_encryption_key_id)
            LOG.warning(msg)

    @utils.mutating
    def delete_from_store(self, req, store_id, image_id):
        if not CONF.enabled_backends:
            raise webob.exc.HTTPNotFound()
        if store_id not in CONF.enabled_backends:
            msg = (_(""The selected store %s is not available on this node."") %
                   store_id)
            raise webob.exc.HTTPConflict(explanation=msg)

        image_repo = self.gateway.get_repo(req.context)
        try:
            image = image_repo.get(image_id)"
79,apps/glance/glance/api/v2/images.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"LOG.warning(msg)
        except castellan_exception.KeyManagerError:
            msg = ('Failed to delete cinder encryption key %s' %
                   cinder_encryption_key_id)
            LOG.warning(msg)

    @utils.mutating
    def delete_from_store(self, req, store_id, image_id):
        if not CONF.enabled_backends:
            raise webob.exc.HTTPNotFound()
        if store_id not in CONF.enabled_backends:
            msg = (_(""The selected store %s is not available on this node."") %
                   store_id)
            raise webob.exc.HTTPConflict(explanation=msg)

        image_repo = self.gateway.get_repo(req.context)
        try:
            image = image_repo.get(image_id)
        except exception.NotAuthenticated as e:
            raise webob.exc.HTTPUnauthorized(explanation=e.msg)"
80,apps/glance/glance/api/v2/images.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"if self.is_proxyable(image):
                # NOTE(danms): Image is staged on another worker; proxy the
                # delete request to that worker with the user's token, as if
                # they had called it themselves.
                image = self._delete_image_on_remote(image, req)
                if image is None:
                    # Delete was proxied, so we are done here.
                    return

            # NOTE(abhishekk): Delete the data from staging area
            if CONF.enabled_backends:
                separator, staging_dir = store_utils.get_dir_separator()
                file_path = ""%s%s%s"" % (staging_dir,
                                        separator,
                                        image_id)
                try:
                    fn_call = glance_store.get_store_from_store_identifier
                    staging_store = fn_call('os_glance_staging_store')
                    loc = location.get_location_from_uri_and_backend(
                        file_path, 'os_glance_staging_store')"
81,apps/glance/glance/api/v2/images.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"raise webob.exc.HTTPForbidden(explanation=msg)

        if image.status not in ('active', 'queued'):
            msg = _(""It's not allowed to replace locations if image status is ""
                    ""%s."") % image.status
            raise webob.exc.HTTPConflict(explanation=msg)

        val_data = self._validate_validation_data(image, value)
        # NOTE(abhishekk): get glance store based on location uri
        updated_location = value
        if CONF.enabled_backends:
            updated_location = store_utils.get_updated_store_location(
                value)

        try:
            # NOTE(flwang): _locations_proxy's setattr method will check if
            # the update is acceptable.
            image.locations = updated_location
            if image.status == 'queued':
                for k, v in val_data.items():"
82,apps/glance/glance/api/v2/images.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"raise webob.exc.HTTPForbidden(explanation=msg)

        if image.status not in ('active', 'queued'):
            msg = _(""It's not allowed to add locations if image status is ""
                    ""%s."") % image.status
            raise webob.exc.HTTPConflict(explanation=msg)

        val_data = self._validate_validation_data(image, [value])
        # NOTE(abhishekk): get glance store based on location uri
        updated_location = value
        if CONF.enabled_backends:
            updated_location = store_utils.get_updated_store_location(
                [value], context=context)[0]

        pos = self._get_locations_op_pos(path_pos,
                                         len(image.locations), True)
        if pos is None:
            msg = _(""Invalid position for adding a location."")
            raise webob.exc.HTTPBadRequest(explanation=msg)
        try:"
83,apps/glance/glance/api/v2/images.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"""not including 'direct_url' in response"",
                              image.image_id)

            image_view['tags'] = list(image.tags)
            image_view['self'] = self._get_image_href(image)
            image_view['file'] = self._get_image_href(image, 'file')
            image_view['schema'] = '/v2/schemas/image'
            image_view = self.schema.filter(image_view)  # domain

            # add store information to image
            if CONF.enabled_backends:
                locations = _get_image_locations(image)
                if locations:
                    stores = []
                    for loc in locations:
                        backend = loc['metadata'].get('store')
                        if backend:
                            stores.append(backend)

                    if stores:"
84,apps/glance/glance/api/v2/images.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"response.status_int = http.CREATED
        self.show(response, image)
        response.location = self._get_image_href(image)
        # according to RFC7230, headers should not have empty fields
        # see http://httpwg.org/specs/rfc7230.html#field.components
        if CONF.enabled_import_methods:
            import_methods = (""OpenStack-image-import-methods"",
                              ','.join(CONF.enabled_import_methods))
            response.headerlist.append(import_methods)

        if CONF.enabled_backends:
            enabled_backends = (""OpenStack-image-store-ids"",
                                ','.join(CONF.enabled_backends.keys()))
            response.headerlist.append(enabled_backends)

    def show(self, response, image):
        image_view = self._format_image(image)
        response.unicode_body = json.dumps(image_view, ensure_ascii=False)
        response.content_type = 'application/json'"
85,apps/glance/glance/api/v2/images.py,enabled,create.CONF.enabled_backends,enabled_backends,create.CONF.enabled_backends,"self.show(response, image)
        response.location = self._get_image_href(image)
        # according to RFC7230, headers should not have empty fields
        # see http://httpwg.org/specs/rfc7230.html#field.components
        if CONF.enabled_import_methods:
            import_methods = (""OpenStack-image-import-methods"",
                              ','.join(CONF.enabled_import_methods))
            response.headerlist.append(import_methods)

        if CONF.enabled_backends:
            enabled_backends = (""OpenStack-image-store-ids"",
                                ','.join(CONF.enabled_backends.keys()))
            response.headerlist.append(enabled_backends)

    def show(self, response, image):
        image_view = self._format_image(image)
        response.unicode_body = json.dumps(image_view, ensure_ascii=False)
        response.content_type = 'application/json'

    def update(self, response, image):"
86,apps/glance/glance/api/v2/images.py,enabled,create.CONF.enabled_backends,enabled_backends,create.CONF.enabled_backends.keys,"self.show(response, image)
        response.location = self._get_image_href(image)
        # according to RFC7230, headers should not have empty fields
        # see http://httpwg.org/specs/rfc7230.html#field.components
        if CONF.enabled_import_methods:
            import_methods = (""OpenStack-image-import-methods"",
                              ','.join(CONF.enabled_import_methods))
            response.headerlist.append(import_methods)

        if CONF.enabled_backends:
            enabled_backends = (""OpenStack-image-store-ids"",
                                ','.join(CONF.enabled_backends.keys()))
            response.headerlist.append(enabled_backends)

    def show(self, response, image):
        image_view = self._format_image(image)
        response.unicode_body = json.dumps(image_view, ensure_ascii=False)
        response.content_type = 'application/json'

    def update(self, response, image):"
87,apps/glance/glance/api/v2/images.py,enabled,create.CONF.enabled_backends,key,create.CONF.enabled_backends.keys,"self.show(response, image)
        response.location = self._get_image_href(image)
        # according to RFC7230, headers should not have empty fields
        # see http://httpwg.org/specs/rfc7230.html#field.components
        if CONF.enabled_import_methods:
            import_methods = (""OpenStack-image-import-methods"",
                              ','.join(CONF.enabled_import_methods))
            response.headerlist.append(import_methods)

        if CONF.enabled_backends:
            enabled_backends = (""OpenStack-image-store-ids"",
                                ','.join(CONF.enabled_backends.keys()))
            response.headerlist.append(enabled_backends)

    def show(self, response, image):
        image_view = self._format_image(image)
        response.unicode_body = json.dumps(image_view, ensure_ascii=False)
        response.content_type = 'application/json'

    def update(self, response, image):"
88,apps/glance/glance/api/v2/images.py,enabled,create.CONF.enabled_backends.keys,enabled_backends,create.CONF.enabled_backends,"self.show(response, image)
        response.location = self._get_image_href(image)
        # according to RFC7230, headers should not have empty fields
        # see http://httpwg.org/specs/rfc7230.html#field.components
        if CONF.enabled_import_methods:
            import_methods = (""OpenStack-image-import-methods"",
                              ','.join(CONF.enabled_import_methods))
            response.headerlist.append(import_methods)

        if CONF.enabled_backends:
            enabled_backends = (""OpenStack-image-store-ids"",
                                ','.join(CONF.enabled_backends.keys()))
            response.headerlist.append(enabled_backends)

    def show(self, response, image):
        image_view = self._format_image(image)
        response.unicode_body = json.dumps(image_view, ensure_ascii=False)
        response.content_type = 'application/json'

    def update(self, response, image):"
89,apps/glance/glance/api/v2/images.py,enabled,create.CONF.enabled_backends.keys,enabled_backends,create.CONF.enabled_backends.keys,"self.show(response, image)
        response.location = self._get_image_href(image)
        # according to RFC7230, headers should not have empty fields
        # see http://httpwg.org/specs/rfc7230.html#field.components
        if CONF.enabled_import_methods:
            import_methods = (""OpenStack-image-import-methods"",
                              ','.join(CONF.enabled_import_methods))
            response.headerlist.append(import_methods)

        if CONF.enabled_backends:
            enabled_backends = (""OpenStack-image-store-ids"",
                                ','.join(CONF.enabled_backends.keys()))
            response.headerlist.append(enabled_backends)

    def show(self, response, image):
        image_view = self._format_image(image)
        response.unicode_body = json.dumps(image_view, ensure_ascii=False)
        response.content_type = 'application/json'

    def update(self, response, image):"
90,apps/glance/glance/api/v2/images.py,enabled,create.CONF.enabled_backends.keys,key,create.CONF.enabled_backends.keys,"self.show(response, image)
        response.location = self._get_image_href(image)
        # according to RFC7230, headers should not have empty fields
        # see http://httpwg.org/specs/rfc7230.html#field.components
        if CONF.enabled_import_methods:
            import_methods = (""OpenStack-image-import-methods"",
                              ','.join(CONF.enabled_import_methods))
            response.headerlist.append(import_methods)

        if CONF.enabled_backends:
            enabled_backends = (""OpenStack-image-store-ids"",
                                ','.join(CONF.enabled_backends.keys()))
            response.headerlist.append(enabled_backends)

    def show(self, response, image):
        image_view = self._format_image(image)
        response.unicode_body = json.dumps(image_view, ensure_ascii=False)
        response.content_type = 'application/json'

    def update(self, response, image):"
91,apps/glance/glance/api/v2/images.py,enabled_backends,create.CONF.enabled_backends,key,create.CONF.enabled_backends.keys,"self.show(response, image)
        response.location = self._get_image_href(image)
        # according to RFC7230, headers should not have empty fields
        # see http://httpwg.org/specs/rfc7230.html#field.components
        if CONF.enabled_import_methods:
            import_methods = (""OpenStack-image-import-methods"",
                              ','.join(CONF.enabled_import_methods))
            response.headerlist.append(import_methods)

        if CONF.enabled_backends:
            enabled_backends = (""OpenStack-image-store-ids"",
                                ','.join(CONF.enabled_backends.keys()))
            response.headerlist.append(enabled_backends)

    def show(self, response, image):
        image_view = self._format_image(image)
        response.unicode_body = json.dumps(image_view, ensure_ascii=False)
        response.content_type = 'application/json'

    def update(self, response, image):"
92,apps/glance/glance/api/v2/images.py,enabled_backends,create.CONF.enabled_backends.keys,key,create.CONF.enabled_backends.keys,"self.show(response, image)
        response.location = self._get_image_href(image)
        # according to RFC7230, headers should not have empty fields
        # see http://httpwg.org/specs/rfc7230.html#field.components
        if CONF.enabled_import_methods:
            import_methods = (""OpenStack-image-import-methods"",
                              ','.join(CONF.enabled_import_methods))
            response.headerlist.append(import_methods)

        if CONF.enabled_backends:
            enabled_backends = (""OpenStack-image-store-ids"",
                                ','.join(CONF.enabled_backends.keys()))
            response.headerlist.append(enabled_backends)

    def show(self, response, image):
        image_view = self._format_image(image)
        response.unicode_body = json.dumps(image_view, ensure_ascii=False)
        response.content_type = 'application/json'

    def update(self, response, image):"
93,apps/glance/glance/api/v2/images.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"response.location = self._get_image_href(image)
        # according to RFC7230, headers should not have empty fields
        # see http://httpwg.org/specs/rfc7230.html#field.components
        if CONF.enabled_import_methods:
            import_methods = (""OpenStack-image-import-methods"",
                              ','.join(CONF.enabled_import_methods))
            response.headerlist.append(import_methods)

        if CONF.enabled_backends:
            enabled_backends = (""OpenStack-image-store-ids"",
                                ','.join(CONF.enabled_backends.keys()))
            response.headerlist.append(enabled_backends)

    def show(self, response, image):
        image_view = self._format_image(image)
        response.unicode_body = json.dumps(image_view, ensure_ascii=False)
        response.content_type = 'application/json'

    def update(self, response, image):
        image_view = self._format_image(image)"
94,apps/glance/glance/api/v2/images.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends.keys,"response.location = self._get_image_href(image)
        # according to RFC7230, headers should not have empty fields
        # see http://httpwg.org/specs/rfc7230.html#field.components
        if CONF.enabled_import_methods:
            import_methods = (""OpenStack-image-import-methods"",
                              ','.join(CONF.enabled_import_methods))
            response.headerlist.append(import_methods)

        if CONF.enabled_backends:
            enabled_backends = (""OpenStack-image-store-ids"",
                                ','.join(CONF.enabled_backends.keys()))
            response.headerlist.append(enabled_backends)

    def show(self, response, image):
        image_view = self._format_image(image)
        response.unicode_body = json.dumps(image_view, ensure_ascii=False)
        response.content_type = 'application/json'

    def update(self, response, image):
        image_view = self._format_image(image)"
95,apps/glance/glance/api/v2/images.py,enabled,CONF.enabled_backends,key,CONF.enabled_backends.keys,"response.location = self._get_image_href(image)
        # according to RFC7230, headers should not have empty fields
        # see http://httpwg.org/specs/rfc7230.html#field.components
        if CONF.enabled_import_methods:
            import_methods = (""OpenStack-image-import-methods"",
                              ','.join(CONF.enabled_import_methods))
            response.headerlist.append(import_methods)

        if CONF.enabled_backends:
            enabled_backends = (""OpenStack-image-store-ids"",
                                ','.join(CONF.enabled_backends.keys()))
            response.headerlist.append(enabled_backends)

    def show(self, response, image):
        image_view = self._format_image(image)
        response.unicode_body = json.dumps(image_view, ensure_ascii=False)
        response.content_type = 'application/json'

    def update(self, response, image):
        image_view = self._format_image(image)"
96,apps/glance/glance/api/v2/images.py,enabled,CONF.enabled_backends.keys,enabled_backends,CONF.enabled_backends,"response.location = self._get_image_href(image)
        # according to RFC7230, headers should not have empty fields
        # see http://httpwg.org/specs/rfc7230.html#field.components
        if CONF.enabled_import_methods:
            import_methods = (""OpenStack-image-import-methods"",
                              ','.join(CONF.enabled_import_methods))
            response.headerlist.append(import_methods)

        if CONF.enabled_backends:
            enabled_backends = (""OpenStack-image-store-ids"",
                                ','.join(CONF.enabled_backends.keys()))
            response.headerlist.append(enabled_backends)

    def show(self, response, image):
        image_view = self._format_image(image)
        response.unicode_body = json.dumps(image_view, ensure_ascii=False)
        response.content_type = 'application/json'

    def update(self, response, image):
        image_view = self._format_image(image)"
97,apps/glance/glance/api/v2/images.py,enabled,CONF.enabled_backends.keys,enabled_backends,CONF.enabled_backends.keys,"response.location = self._get_image_href(image)
        # according to RFC7230, headers should not have empty fields
        # see http://httpwg.org/specs/rfc7230.html#field.components
        if CONF.enabled_import_methods:
            import_methods = (""OpenStack-image-import-methods"",
                              ','.join(CONF.enabled_import_methods))
            response.headerlist.append(import_methods)

        if CONF.enabled_backends:
            enabled_backends = (""OpenStack-image-store-ids"",
                                ','.join(CONF.enabled_backends.keys()))
            response.headerlist.append(enabled_backends)

    def show(self, response, image):
        image_view = self._format_image(image)
        response.unicode_body = json.dumps(image_view, ensure_ascii=False)
        response.content_type = 'application/json'

    def update(self, response, image):
        image_view = self._format_image(image)"
98,apps/glance/glance/api/v2/images.py,enabled,CONF.enabled_backends.keys,key,CONF.enabled_backends.keys,"response.location = self._get_image_href(image)
        # according to RFC7230, headers should not have empty fields
        # see http://httpwg.org/specs/rfc7230.html#field.components
        if CONF.enabled_import_methods:
            import_methods = (""OpenStack-image-import-methods"",
                              ','.join(CONF.enabled_import_methods))
            response.headerlist.append(import_methods)

        if CONF.enabled_backends:
            enabled_backends = (""OpenStack-image-store-ids"",
                                ','.join(CONF.enabled_backends.keys()))
            response.headerlist.append(enabled_backends)

    def show(self, response, image):
        image_view = self._format_image(image)
        response.unicode_body = json.dumps(image_view, ensure_ascii=False)
        response.content_type = 'application/json'

    def update(self, response, image):
        image_view = self._format_image(image)"
99,apps/glance/glance/api/v2/images.py,enabled_backends,CONF.enabled_backends,key,CONF.enabled_backends.keys,"response.location = self._get_image_href(image)
        # according to RFC7230, headers should not have empty fields
        # see http://httpwg.org/specs/rfc7230.html#field.components
        if CONF.enabled_import_methods:
            import_methods = (""OpenStack-image-import-methods"",
                              ','.join(CONF.enabled_import_methods))
            response.headerlist.append(import_methods)

        if CONF.enabled_backends:
            enabled_backends = (""OpenStack-image-store-ids"",
                                ','.join(CONF.enabled_backends.keys()))
            response.headerlist.append(enabled_backends)

    def show(self, response, image):
        image_view = self._format_image(image)
        response.unicode_body = json.dumps(image_view, ensure_ascii=False)
        response.content_type = 'application/json'

    def update(self, response, image):
        image_view = self._format_image(image)"
100,apps/glance/glance/api/v2/images.py,enabled_backends,CONF.enabled_backends.keys,key,CONF.enabled_backends.keys,"response.location = self._get_image_href(image)
        # according to RFC7230, headers should not have empty fields
        # see http://httpwg.org/specs/rfc7230.html#field.components
        if CONF.enabled_import_methods:
            import_methods = (""OpenStack-image-import-methods"",
                              ','.join(CONF.enabled_import_methods))
            response.headerlist.append(import_methods)

        if CONF.enabled_backends:
            enabled_backends = (""OpenStack-image-store-ids"",
                                ','.join(CONF.enabled_backends.keys()))
            response.headerlist.append(enabled_backends)

    def show(self, response, image):
        image_view = self._format_image(image)
        response.unicode_body = json.dumps(image_view, ensure_ascii=False)
        response.content_type = 'application/json'

    def update(self, response, image):
        image_view = self._format_image(image)"
101,apps/glance/glance/api/v2/images.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"if CONF.enabled_backends:
                try:
                    stores = utils.get_stores_from_request(req, body)
                except glance_store.UnknownScheme as exc:
                    LOG.warning(exc.msg)
                    raise exception.Conflict(exc.msg)"
102,apps/glance/glance/api/v2/images.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"if (not all_stores_must_succeed) and (not CONF.enabled_backends):
            msg = (_(""All_stores_must_succeed can only be set with ""
                     ""enabled_backends %s"") % uri)
            raise webob.exc.HTTPBadRequest(explanation=msg)"
103,apps/glance/glance/api/v2/images.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"if not CONF.enabled_backends:
            raise webob.exc.HTTPNotFound()"
104,apps/glance/glance/api/v2/images.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"if store_id not in CONF.enabled_backends:
            msg = (_(""The selected store %s is not available on this node."") %
                   store_id)
            raise webob.exc.HTTPConflict(explanation=msg)"
105,apps/glance/glance/api/v2/images.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"if CONF.enabled_backends:
                separator, staging_dir = store_utils.get_dir_separator()
                file_path = ""%s%s%s"" % (staging_dir,
                                        separator,
                                        image_id)
                try:
                    fn_call = glance_store.get_store_from_store_identifier
                    staging_store = fn_call('os_glance_staging_store')
                    loc = location.get_location_from_uri_and_backend(
                        file_path, 'os_glance_staging_store')
                    staging_store.delete(loc)
                except (glance_store.exceptions.NotFound,
                        glance_store.exceptions.UnknownScheme):
                    pass
            else:
                file_path = str(
                    CONF.node_staging_uri + '/' + image_id)[7:]
                if os.path.exists(file_path):
                    try:
                        LOG.debug(
                            ""After upload to the backend, deleting staged ""
                            ""image data from %(fn)s"", {'fn': file_path})
                        os.unlink(file_path)
                    except OSError as e:
                        LOG.error(
                            ""After upload to backend, deletion of staged ""
                            ""image data from %(fn)s has failed because ""
                            ""[Errno %(en)d]"", {'fn': file_path,
                                               'en': e.errno})
                else:
                    LOG.warning(_(
                        ""After upload to backend, deletion of staged ""
                        ""image data has failed because ""
                        ""it cannot be found at %(fn)s""), {'fn': file_path})"
106,apps/glance/glance/api/v2/images.py,debug,LOG.debug,enabled,CONF.enabled_backends,"if CONF.enabled_backends:
                separator, staging_dir = store_utils.get_dir_separator()
                file_path = ""%s%s%s"" % (staging_dir,
                                        separator,
                                        image_id)
                try:
                    fn_call = glance_store.get_store_from_store_identifier
                    staging_store = fn_call('os_glance_staging_store')
                    loc = location.get_location_from_uri_and_backend(
                        file_path, 'os_glance_staging_store')
                    staging_store.delete(loc)
                except (glance_store.exceptions.NotFound,
                        glance_store.exceptions.UnknownScheme):
                    pass
            else:
                file_path = str(
                    CONF.node_staging_uri + '/' + image_id)[7:]
                if os.path.exists(file_path):
                    try:
                        LOG.debug(
                            ""After upload to the backend, deleting staged ""
                            ""image data from %(fn)s"", {'fn': file_path})
                        os.unlink(file_path)
                    except OSError as e:
                        LOG.error(
                            ""After upload to backend, deletion of staged ""
                            ""image data from %(fn)s has failed because ""
                            ""[Errno %(en)d]"", {'fn': file_path,
                                               'en': e.errno})
                else:
                    LOG.warning(_(
                        ""After upload to backend, deletion of staged ""
                        ""image data has failed because ""
                        ""it cannot be found at %(fn)s""), {'fn': file_path})"
107,apps/glance/glance/api/v2/images.py,debug,LOG.debug,enabled_backends,CONF.enabled_backends,"if CONF.enabled_backends:
                separator, staging_dir = store_utils.get_dir_separator()
                file_path = ""%s%s%s"" % (staging_dir,
                                        separator,
                                        image_id)
                try:
                    fn_call = glance_store.get_store_from_store_identifier
                    staging_store = fn_call('os_glance_staging_store')
                    loc = location.get_location_from_uri_and_backend(
                        file_path, 'os_glance_staging_store')
                    staging_store.delete(loc)
                except (glance_store.exceptions.NotFound,
                        glance_store.exceptions.UnknownScheme):
                    pass
            else:
                file_path = str(
                    CONF.node_staging_uri + '/' + image_id)[7:]
                if os.path.exists(file_path):
                    try:
                        LOG.debug(
                            ""After upload to the backend, deleting staged ""
                            ""image data from %(fn)s"", {'fn': file_path})
                        os.unlink(file_path)
                    except OSError as e:
                        LOG.error(
                            ""After upload to backend, deletion of staged ""
                            ""image data from %(fn)s has failed because ""
                            ""[Errno %(en)d]"", {'fn': file_path,
                                               'en': e.errno})
                else:
                    LOG.warning(_(
                        ""After upload to backend, deletion of staged ""
                        ""image data has failed because ""
                        ""it cannot be found at %(fn)s""), {'fn': file_path})"
108,apps/glance/glance/api/v2/images.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"if CONF.enabled_backends:
            updated_location = store_utils.get_updated_store_location(
                value)"
109,apps/glance/glance/api/v2/images.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"if CONF.enabled_backends:
            updated_location = store_utils.get_updated_store_location(
                [value], context=context)[0]"
110,apps/glance/glance/api/v2/images.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"if CONF.enabled_backends:
                locations = _get_image_locations(image)
                if locations:
                    stores = []
                    for loc in locations:
                        backend = loc['metadata'].get('store')
                        if backend:
                            stores.append(backend)

                    if stores:
                        image_view['stores'] = "","".join(stores)"
111,apps/glance/glance/api/v2/images.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"if CONF.enabled_backends:
            enabled_backends = (""OpenStack-image-store-ids"",
                                ','.join(CONF.enabled_backends.keys()))
            response.headerlist.append(enabled_backends)"
112,apps/glance/glance/api/v2/images.py,enabled,create.CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"if CONF.enabled_backends:
            enabled_backends = (""OpenStack-image-store-ids"",
                                ','.join(CONF.enabled_backends.keys()))
            response.headerlist.append(enabled_backends)"
113,apps/glance/glance/api/v2/images.py,enabled,create.CONF.enabled_backends.keys,enabled_backends,CONF.enabled_backends,"if CONF.enabled_backends:
            enabled_backends = (""OpenStack-image-store-ids"",
                                ','.join(CONF.enabled_backends.keys()))
            response.headerlist.append(enabled_backends)"
114,apps/glance/glance/api/v2/images.py,enabled_backends,CONF.enabled_backends,key,create.CONF.enabled_backends.keys,"if CONF.enabled_backends:
            enabled_backends = (""OpenStack-image-store-ids"",
                                ','.join(CONF.enabled_backends.keys()))
            response.headerlist.append(enabled_backends)"
115,apps/glance/glance/api/v2/images.py,enabled,CONF.enabled_backends.keys,enabled_backends,CONF.enabled_backends,"if CONF.enabled_backends:
            enabled_backends = (""OpenStack-image-store-ids"",
                                ','.join(CONF.enabled_backends.keys()))
            response.headerlist.append(enabled_backends)"
116,apps/glance/glance/api/v2/images.py,enabled_backends,CONF.enabled_backends,key,CONF.enabled_backends.keys,"if CONF.enabled_backends:
            enabled_backends = (""OpenStack-image-store-ids"",
                                ','.join(CONF.enabled_backends.keys()))
            response.headerlist.append(enabled_backends)"
117,apps/glance/glance/api/v2/images.py,enabled,CONF.enabled_backends,enabled_backends,create.CONF.enabled_backends,"if CONF.enabled_backends:
            enabled_backends = (""OpenStack-image-store-ids"",
                                ','.join(CONF.enabled_backends.keys()))
            response.headerlist.append(enabled_backends)"
118,apps/glance/glance/api/v2/images.py,enabled,CONF.enabled_backends,enabled_backends,create.CONF.enabled_backends.keys,"if CONF.enabled_backends:
            enabled_backends = (""OpenStack-image-store-ids"",
                                ','.join(CONF.enabled_backends.keys()))
            response.headerlist.append(enabled_backends)"
119,apps/glance/glance/api/v2/images.py,enabled,CONF.enabled_backends,key,create.CONF.enabled_backends.keys,"if CONF.enabled_backends:
            enabled_backends = (""OpenStack-image-store-ids"",
                                ','.join(CONF.enabled_backends.keys()))
            response.headerlist.append(enabled_backends)"
120,apps/glance/glance/api/v2/images.py,enabled,create.CONF.enabled_backends,enabled_backends,create.CONF.enabled_backends,"if CONF.enabled_backends:
            enabled_backends = (""OpenStack-image-store-ids"",
                                ','.join(CONF.enabled_backends.keys()))
            response.headerlist.append(enabled_backends)"
121,apps/glance/glance/api/v2/images.py,enabled,create.CONF.enabled_backends,enabled_backends,create.CONF.enabled_backends.keys,"if CONF.enabled_backends:
            enabled_backends = (""OpenStack-image-store-ids"",
                                ','.join(CONF.enabled_backends.keys()))
            response.headerlist.append(enabled_backends)"
122,apps/glance/glance/api/v2/images.py,enabled,create.CONF.enabled_backends,key,create.CONF.enabled_backends.keys,"if CONF.enabled_backends:
            enabled_backends = (""OpenStack-image-store-ids"",
                                ','.join(CONF.enabled_backends.keys()))
            response.headerlist.append(enabled_backends)"
123,apps/glance/glance/api/v2/images.py,enabled,create.CONF.enabled_backends.keys,enabled_backends,create.CONF.enabled_backends,"if CONF.enabled_backends:
            enabled_backends = (""OpenStack-image-store-ids"",
                                ','.join(CONF.enabled_backends.keys()))
            response.headerlist.append(enabled_backends)"
124,apps/glance/glance/api/v2/images.py,enabled,create.CONF.enabled_backends.keys,enabled_backends,create.CONF.enabled_backends.keys,"if CONF.enabled_backends:
            enabled_backends = (""OpenStack-image-store-ids"",
                                ','.join(CONF.enabled_backends.keys()))
            response.headerlist.append(enabled_backends)"
125,apps/glance/glance/api/v2/images.py,enabled,create.CONF.enabled_backends.keys,key,create.CONF.enabled_backends.keys,"if CONF.enabled_backends:
            enabled_backends = (""OpenStack-image-store-ids"",
                                ','.join(CONF.enabled_backends.keys()))
            response.headerlist.append(enabled_backends)"
126,apps/glance/glance/api/v2/images.py,enabled_backends,create.CONF.enabled_backends,key,create.CONF.enabled_backends.keys,"if CONF.enabled_backends:
            enabled_backends = (""OpenStack-image-store-ids"",
                                ','.join(CONF.enabled_backends.keys()))
            response.headerlist.append(enabled_backends)"
127,apps/glance/glance/api/v2/images.py,enabled_backends,create.CONF.enabled_backends.keys,key,create.CONF.enabled_backends.keys,"if CONF.enabled_backends:
            enabled_backends = (""OpenStack-image-store-ids"",
                                ','.join(CONF.enabled_backends.keys()))
            response.headerlist.append(enabled_backends)"
128,apps/glance/glance/api/v2/images.py,enabled,CONF.enabled_backends.keys,enabled_backends,create.CONF.enabled_backends,"if CONF.enabled_backends:
            enabled_backends = (""OpenStack-image-store-ids"",
                                ','.join(CONF.enabled_backends.keys()))
            response.headerlist.append(enabled_backends)"
129,apps/glance/glance/api/v2/images.py,enabled,CONF.enabled_backends.keys,enabled_backends,create.CONF.enabled_backends.keys,"if CONF.enabled_backends:
            enabled_backends = (""OpenStack-image-store-ids"",
                                ','.join(CONF.enabled_backends.keys()))
            response.headerlist.append(enabled_backends)"
130,apps/glance/glance/api/v2/images.py,enabled,CONF.enabled_backends.keys,key,create.CONF.enabled_backends.keys,"if CONF.enabled_backends:
            enabled_backends = (""OpenStack-image-store-ids"",
                                ','.join(CONF.enabled_backends.keys()))
            response.headerlist.append(enabled_backends)"
131,apps/glance/glance/api/v2/images.py,enabled_backends,create.CONF.enabled_backends,key,CONF.enabled_backends.keys,"if CONF.enabled_backends:
            enabled_backends = (""OpenStack-image-store-ids"",
                                ','.join(CONF.enabled_backends.keys()))
            response.headerlist.append(enabled_backends)"
132,apps/glance/glance/api/v2/images.py,enabled_backends,create.CONF.enabled_backends.keys,key,CONF.enabled_backends.keys,"if CONF.enabled_backends:
            enabled_backends = (""OpenStack-image-store-ids"",
                                ','.join(CONF.enabled_backends.keys()))
            response.headerlist.append(enabled_backends)"
133,apps/glance/glance/api/v2/images.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends.keys,"if CONF.enabled_backends:
            enabled_backends = (""OpenStack-image-store-ids"",
                                ','.join(CONF.enabled_backends.keys()))
            response.headerlist.append(enabled_backends)"
134,apps/glance/glance/api/v2/images.py,enabled,CONF.enabled_backends,key,CONF.enabled_backends.keys,"if CONF.enabled_backends:
            enabled_backends = (""OpenStack-image-store-ids"",
                                ','.join(CONF.enabled_backends.keys()))
            response.headerlist.append(enabled_backends)"
135,apps/glance/glance/api/v2/images.py,enabled,create.CONF.enabled_backends,enabled_backends,CONF.enabled_backends.keys,"if CONF.enabled_backends:
            enabled_backends = (""OpenStack-image-store-ids"",
                                ','.join(CONF.enabled_backends.keys()))
            response.headerlist.append(enabled_backends)"
136,apps/glance/glance/api/v2/images.py,enabled,create.CONF.enabled_backends,key,CONF.enabled_backends.keys,"if CONF.enabled_backends:
            enabled_backends = (""OpenStack-image-store-ids"",
                                ','.join(CONF.enabled_backends.keys()))
            response.headerlist.append(enabled_backends)"
137,apps/glance/glance/api/v2/images.py,enabled,create.CONF.enabled_backends.keys,enabled_backends,CONF.enabled_backends.keys,"if CONF.enabled_backends:
            enabled_backends = (""OpenStack-image-store-ids"",
                                ','.join(CONF.enabled_backends.keys()))
            response.headerlist.append(enabled_backends)"
138,apps/glance/glance/api/v2/images.py,enabled,create.CONF.enabled_backends.keys,key,CONF.enabled_backends.keys,"if CONF.enabled_backends:
            enabled_backends = (""OpenStack-image-store-ids"",
                                ','.join(CONF.enabled_backends.keys()))
            response.headerlist.append(enabled_backends)"
139,apps/glance/glance/api/v2/images.py,enabled_backends,CONF.enabled_backends.keys,key,create.CONF.enabled_backends.keys,"if CONF.enabled_backends:
            enabled_backends = (""OpenStack-image-store-ids"",
                                ','.join(CONF.enabled_backends.keys()))
            response.headerlist.append(enabled_backends)"
140,apps/glance/glance/api/v2/images.py,enabled,CONF.enabled_backends.keys,enabled_backends,CONF.enabled_backends.keys,"if CONF.enabled_backends:
            enabled_backends = (""OpenStack-image-store-ids"",
                                ','.join(CONF.enabled_backends.keys()))
            response.headerlist.append(enabled_backends)"
141,apps/glance/glance/api/v2/images.py,enabled,CONF.enabled_backends.keys,key,CONF.enabled_backends.keys,"if CONF.enabled_backends:
            enabled_backends = (""OpenStack-image-store-ids"",
                                ','.join(CONF.enabled_backends.keys()))
            response.headerlist.append(enabled_backends)"
142,apps/glance/glance/api/v2/images.py,enabled_backends,CONF.enabled_backends.keys,key,CONF.enabled_backends.keys,"if CONF.enabled_backends:
            enabled_backends = (""OpenStack-image-store-ids"",
                                ','.join(CONF.enabled_backends.keys()))
            response.headerlist.append(enabled_backends)"
143,apps/glance/glance/api/v2/images.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"try:
            image = image_repo.get(image_id)
            if image.status == 'active' and import_method != ""copy-image"":
                msg = _(""Image with status active cannot be target for import"")
                raise exception.Conflict(msg)
            if image.status != 'active' and import_method == ""copy-image"":
                msg = _(""Only images with status active can be targeted for ""
                        ""copying"")
                raise exception.Conflict(msg)
            if (image.status != 'queued' and
                    import_method in ['web-download', 'glance-download']):
                msg = _(""Image needs to be in 'queued' state to use ""
                        ""'%s' method"") % import_method
                raise exception.Conflict(msg)
            if (image.status != 'uploading' and
                    import_method == 'glance-direct'):
                msg = _(""Image needs to be staged before 'glance-direct' ""
                        ""method can be used"")
                raise exception.Conflict(msg)
            if not getattr(image, 'container_format', None):
                msg = _(""'container_format' needs to be set before import"")
                raise exception.Conflict(msg)
            if not getattr(image, 'disk_format', None):
                msg = _(""'disk_format' needs to be set before import"")
                raise exception.Conflict(msg)
            if import_method == 'glance-download':
                if 'glance_region' not in body.get('method'):
                    msg = _(""'glance_region' needs to be set for ""
                            ""glance-download import method"")
                    raise webob.exc.HTTPBadRequest(explanation=msg)
                if 'glance_image_id' not in body.get('method'):
                    msg = _(""'glance_image_id' needs to be set for ""
                            ""glance-download import method"")
                    raise webob.exc.HTTPBadRequest(explanation=msg)
                try:
                    uuid.UUID(body['method']['glance_image_id'])
                except ValueError:
                    msg = (_(""Remote image id does not look like a UUID: %s"")
                           % body['method']['glance_image_id'])
                    raise webob.exc.HTTPBadRequest(explanation=msg)
                if 'glance_service_interface' not in body.get('method'):
                    body.get('method')['glance_service_interface'] = 'public'

            # NOTE(danms): For copy-image only, we check policy to decide
            # if the user should be able to do this. Otherwise, we forbid
            # the import if the user is not the owner.

            api_pol = api_policy.ImageAPIPolicy(req.context, image,
                                                enforcer=self.policy)
            if import_method == 'copy-image':
                api_pol.copy_image()
            else:
                # NOTE(abhishekk): We need to perform ownership check on image
                # so that non-admin or non-owner can not import data to image
                api_pol.modify_image()

            if 'os_glance_import_task' in image.extra_properties:
                # NOTE(danms): This will raise exception.Conflict if the
                # lock is present and valid, or return if absent or invalid.
                stole_lock_from_task = self._enforce_import_lock(req, image)

            stores = [None]
            if CONF.enabled_backends:
                try:
                    stores = utils.get_stores_from_request(req, body)
                except glance_store.UnknownScheme as exc:
                    LOG.warning(exc.msg)
                    raise exception.Conflict(exc.msg)

            # NOTE(abhishekk): If all_stores is specified and import_method is
            # copy_image, then remove those stores where image is already
            # present.
            all_stores = body.get('all_stores', False)
            if import_method == 'copy-image' and all_stores:
                for loc in image.locations:
                    existing_store = loc['metadata']['store']
                    if existing_store in stores:
                        LOG.debug(""Removing store '%s' from all stores as ""
                                  ""image is already available in that ""
                                  ""store."", existing_store)
                        stores.remove(existing_store)

                if len(stores) == 0:
                    LOG.info(_LI(""Exiting copying workflow as image is ""
                                 ""available in all configured stores.""))
                    return image_id

            # validate if image is already existing in given stores when
            # all_stores is False
            if import_method == 'copy-image' and not all_stores:
                for loc in image.locations:
                    existing_store = loc['metadata']['store']
                    if existing_store in stores:
                        msg = _(""Image is already present at store ""
                                ""'%s'"") % existing_store
                        raise webob.exc.HTTPBadRequest(explanation=msg)
        except exception.Conflict as e:
            raise webob.exc.HTTPConflict(explanation=e.msg)
        except exception.NotFound as e:
            raise webob.exc.HTTPNotFound(explanation=e.msg)
        except exception.Forbidden as e:
            raise webob.exc.HTTPForbidden(explanation=e.msg)"
144,apps/glance/glance/api/v2/images.py,debug,LOG.debug,enabled,CONF.enabled_backends,"try:
            image = image_repo.get(image_id)
            if image.status == 'active' and import_method != ""copy-image"":
                msg = _(""Image with status active cannot be target for import"")
                raise exception.Conflict(msg)
            if image.status != 'active' and import_method == ""copy-image"":
                msg = _(""Only images with status active can be targeted for ""
                        ""copying"")
                raise exception.Conflict(msg)
            if (image.status != 'queued' and
                    import_method in ['web-download', 'glance-download']):
                msg = _(""Image needs to be in 'queued' state to use ""
                        ""'%s' method"") % import_method
                raise exception.Conflict(msg)
            if (image.status != 'uploading' and
                    import_method == 'glance-direct'):
                msg = _(""Image needs to be staged before 'glance-direct' ""
                        ""method can be used"")
                raise exception.Conflict(msg)
            if not getattr(image, 'container_format', None):
                msg = _(""'container_format' needs to be set before import"")
                raise exception.Conflict(msg)
            if not getattr(image, 'disk_format', None):
                msg = _(""'disk_format' needs to be set before import"")
                raise exception.Conflict(msg)
            if import_method == 'glance-download':
                if 'glance_region' not in body.get('method'):
                    msg = _(""'glance_region' needs to be set for ""
                            ""glance-download import method"")
                    raise webob.exc.HTTPBadRequest(explanation=msg)
                if 'glance_image_id' not in body.get('method'):
                    msg = _(""'glance_image_id' needs to be set for ""
                            ""glance-download import method"")
                    raise webob.exc.HTTPBadRequest(explanation=msg)
                try:
                    uuid.UUID(body['method']['glance_image_id'])
                except ValueError:
                    msg = (_(""Remote image id does not look like a UUID: %s"")
                           % body['method']['glance_image_id'])
                    raise webob.exc.HTTPBadRequest(explanation=msg)
                if 'glance_service_interface' not in body.get('method'):
                    body.get('method')['glance_service_interface'] = 'public'

            # NOTE(danms): For copy-image only, we check policy to decide
            # if the user should be able to do this. Otherwise, we forbid
            # the import if the user is not the owner.

            api_pol = api_policy.ImageAPIPolicy(req.context, image,
                                                enforcer=self.policy)
            if import_method == 'copy-image':
                api_pol.copy_image()
            else:
                # NOTE(abhishekk): We need to perform ownership check on image
                # so that non-admin or non-owner can not import data to image
                api_pol.modify_image()

            if 'os_glance_import_task' in image.extra_properties:
                # NOTE(danms): This will raise exception.Conflict if the
                # lock is present and valid, or return if absent or invalid.
                stole_lock_from_task = self._enforce_import_lock(req, image)

            stores = [None]
            if CONF.enabled_backends:
                try:
                    stores = utils.get_stores_from_request(req, body)
                except glance_store.UnknownScheme as exc:
                    LOG.warning(exc.msg)
                    raise exception.Conflict(exc.msg)

            # NOTE(abhishekk): If all_stores is specified and import_method is
            # copy_image, then remove those stores where image is already
            # present.
            all_stores = body.get('all_stores', False)
            if import_method == 'copy-image' and all_stores:
                for loc in image.locations:
                    existing_store = loc['metadata']['store']
                    if existing_store in stores:
                        LOG.debug(""Removing store '%s' from all stores as ""
                                  ""image is already available in that ""
                                  ""store."", existing_store)
                        stores.remove(existing_store)

                if len(stores) == 0:
                    LOG.info(_LI(""Exiting copying workflow as image is ""
                                 ""available in all configured stores.""))
                    return image_id

            # validate if image is already existing in given stores when
            # all_stores is False
            if import_method == 'copy-image' and not all_stores:
                for loc in image.locations:
                    existing_store = loc['metadata']['store']
                    if existing_store in stores:
                        msg = _(""Image is already present at store ""
                                ""'%s'"") % existing_store
                        raise webob.exc.HTTPBadRequest(explanation=msg)
        except exception.Conflict as e:
            raise webob.exc.HTTPConflict(explanation=e.msg)
        except exception.NotFound as e:
            raise webob.exc.HTTPNotFound(explanation=e.msg)
        except exception.Forbidden as e:
            raise webob.exc.HTTPForbidden(explanation=e.msg)"
145,apps/glance/glance/api/v2/images.py,debug,LOG.debug,enabled_backends,CONF.enabled_backends,"try:
            image = image_repo.get(image_id)
            if image.status == 'active' and import_method != ""copy-image"":
                msg = _(""Image with status active cannot be target for import"")
                raise exception.Conflict(msg)
            if image.status != 'active' and import_method == ""copy-image"":
                msg = _(""Only images with status active can be targeted for ""
                        ""copying"")
                raise exception.Conflict(msg)
            if (image.status != 'queued' and
                    import_method in ['web-download', 'glance-download']):
                msg = _(""Image needs to be in 'queued' state to use ""
                        ""'%s' method"") % import_method
                raise exception.Conflict(msg)
            if (image.status != 'uploading' and
                    import_method == 'glance-direct'):
                msg = _(""Image needs to be staged before 'glance-direct' ""
                        ""method can be used"")
                raise exception.Conflict(msg)
            if not getattr(image, 'container_format', None):
                msg = _(""'container_format' needs to be set before import"")
                raise exception.Conflict(msg)
            if not getattr(image, 'disk_format', None):
                msg = _(""'disk_format' needs to be set before import"")
                raise exception.Conflict(msg)
            if import_method == 'glance-download':
                if 'glance_region' not in body.get('method'):
                    msg = _(""'glance_region' needs to be set for ""
                            ""glance-download import method"")
                    raise webob.exc.HTTPBadRequest(explanation=msg)
                if 'glance_image_id' not in body.get('method'):
                    msg = _(""'glance_image_id' needs to be set for ""
                            ""glance-download import method"")
                    raise webob.exc.HTTPBadRequest(explanation=msg)
                try:
                    uuid.UUID(body['method']['glance_image_id'])
                except ValueError:
                    msg = (_(""Remote image id does not look like a UUID: %s"")
                           % body['method']['glance_image_id'])
                    raise webob.exc.HTTPBadRequest(explanation=msg)
                if 'glance_service_interface' not in body.get('method'):
                    body.get('method')['glance_service_interface'] = 'public'

            # NOTE(danms): For copy-image only, we check policy to decide
            # if the user should be able to do this. Otherwise, we forbid
            # the import if the user is not the owner.

            api_pol = api_policy.ImageAPIPolicy(req.context, image,
                                                enforcer=self.policy)
            if import_method == 'copy-image':
                api_pol.copy_image()
            else:
                # NOTE(abhishekk): We need to perform ownership check on image
                # so that non-admin or non-owner can not import data to image
                api_pol.modify_image()

            if 'os_glance_import_task' in image.extra_properties:
                # NOTE(danms): This will raise exception.Conflict if the
                # lock is present and valid, or return if absent or invalid.
                stole_lock_from_task = self._enforce_import_lock(req, image)

            stores = [None]
            if CONF.enabled_backends:
                try:
                    stores = utils.get_stores_from_request(req, body)
                except glance_store.UnknownScheme as exc:
                    LOG.warning(exc.msg)
                    raise exception.Conflict(exc.msg)

            # NOTE(abhishekk): If all_stores is specified and import_method is
            # copy_image, then remove those stores where image is already
            # present.
            all_stores = body.get('all_stores', False)
            if import_method == 'copy-image' and all_stores:
                for loc in image.locations:
                    existing_store = loc['metadata']['store']
                    if existing_store in stores:
                        LOG.debug(""Removing store '%s' from all stores as ""
                                  ""image is already available in that ""
                                  ""store."", existing_store)
                        stores.remove(existing_store)

                if len(stores) == 0:
                    LOG.info(_LI(""Exiting copying workflow as image is ""
                                 ""available in all configured stores.""))
                    return image_id

            # validate if image is already existing in given stores when
            # all_stores is False
            if import_method == 'copy-image' and not all_stores:
                for loc in image.locations:
                    existing_store = loc['metadata']['store']
                    if existing_store in stores:
                        msg = _(""Image is already present at store ""
                                ""'%s'"") % existing_store
                        raise webob.exc.HTTPBadRequest(explanation=msg)
        except exception.Conflict as e:
            raise webob.exc.HTTPConflict(explanation=e.msg)
        except exception.NotFound as e:
            raise webob.exc.HTTPNotFound(explanation=e.msg)
        except exception.Forbidden as e:
            raise webob.exc.HTTPForbidden(explanation=e.msg)"
146,apps/glance/glance/api/v2/images.py,task_executor,executor_factory.new_task_executor,user,import_image.ctxt.user_id,"try:
            import_task = task_factory.new_task(task_type='api_image_import',
                                                owner=ctxt.owner,
                                                task_input=task_input,
                                                image_id=image_id,
                                                user_id=ctxt.user_id,
                                                request_id=ctxt.request_id)

            # NOTE(danms): Try to grab the lock for this task
            try:
                image_repo.set_property_atomic(image,
                                               'os_glance_import_task',
                                               import_task.task_id)
            except exception.Duplicate:
                msg = (_(""New operation on image '%s' is not permitted as ""
                         ""prior operation is still in progress"") % image_id)
                raise exception.Conflict(msg)

            # NOTE(danms): We now have the import lock on this image. If we
            # busted the lock above and have a reference to that task, try
            # to clean up the import status information left over from that
            # execution.
            if stole_lock_from_task:
                self._cleanup_stale_task_progress(image_repo, image,
                                                  stole_lock_from_task)

            task_repo.add(import_task)
            task_executor = executor_factory.new_task_executor(ctxt)
            pool = common.get_thread_pool(""tasks_pool"")
            pool.spawn(import_task.run, task_executor)
        except exception.Forbidden as e:
            LOG.debug(""User not permitted to create image import task."")
            raise webob.exc.HTTPForbidden(explanation=e.msg)
        except exception.Conflict as e:
            raise webob.exc.HTTPConflict(explanation=e.msg)
        except exception.InvalidImageStatusTransition as e:
            raise webob.exc.HTTPConflict(explanation=e.msg)
        except exception.LimitExceeded as e:
            raise webob.exc.HTTPRequestEntityTooLarge(explanation=str(e),
                                                      request=req)
        except ValueError as e:
            LOG.debug(""Cannot import data for image %(id)s: %(e)s"",
                      {'id': image_id,
                       'e': encodeutils.exception_to_unicode(e)})
            raise webob.exc.HTTPBadRequest(
                explanation=encodeutils.exception_to_unicode(e))"
147,apps/glance/glance/api/v2/images.py,task_executor,import_image.executor_factory,user,import_image.ctxt.user_id,"try:
            import_task = task_factory.new_task(task_type='api_image_import',
                                                owner=ctxt.owner,
                                                task_input=task_input,
                                                image_id=image_id,
                                                user_id=ctxt.user_id,
                                                request_id=ctxt.request_id)

            # NOTE(danms): Try to grab the lock for this task
            try:
                image_repo.set_property_atomic(image,
                                               'os_glance_import_task',
                                               import_task.task_id)
            except exception.Duplicate:
                msg = (_(""New operation on image '%s' is not permitted as ""
                         ""prior operation is still in progress"") % image_id)
                raise exception.Conflict(msg)

            # NOTE(danms): We now have the import lock on this image. If we
            # busted the lock above and have a reference to that task, try
            # to clean up the import status information left over from that
            # execution.
            if stole_lock_from_task:
                self._cleanup_stale_task_progress(image_repo, image,
                                                  stole_lock_from_task)

            task_repo.add(import_task)
            task_executor = executor_factory.new_task_executor(ctxt)
            pool = common.get_thread_pool(""tasks_pool"")
            pool.spawn(import_task.run, task_executor)
        except exception.Forbidden as e:
            LOG.debug(""User not permitted to create image import task."")
            raise webob.exc.HTTPForbidden(explanation=e.msg)
        except exception.Conflict as e:
            raise webob.exc.HTTPConflict(explanation=e.msg)
        except exception.InvalidImageStatusTransition as e:
            raise webob.exc.HTTPConflict(explanation=e.msg)
        except exception.LimitExceeded as e:
            raise webob.exc.HTTPRequestEntityTooLarge(explanation=str(e),
                                                      request=req)
        except ValueError as e:
            LOG.debug(""Cannot import data for image %(id)s: %(e)s"",
                      {'id': image_id,
                       'e': encodeutils.exception_to_unicode(e)})
            raise webob.exc.HTTPBadRequest(
                explanation=encodeutils.exception_to_unicode(e))"
148,apps/glance/glance/api/v2/images.py,task_executor,import_image.executor_factory.new_task_executor,user,import_image.ctxt.user_id,"try:
            import_task = task_factory.new_task(task_type='api_image_import',
                                                owner=ctxt.owner,
                                                task_input=task_input,
                                                image_id=image_id,
                                                user_id=ctxt.user_id,
                                                request_id=ctxt.request_id)

            # NOTE(danms): Try to grab the lock for this task
            try:
                image_repo.set_property_atomic(image,
                                               'os_glance_import_task',
                                               import_task.task_id)
            except exception.Duplicate:
                msg = (_(""New operation on image '%s' is not permitted as ""
                         ""prior operation is still in progress"") % image_id)
                raise exception.Conflict(msg)

            # NOTE(danms): We now have the import lock on this image. If we
            # busted the lock above and have a reference to that task, try
            # to clean up the import status information left over from that
            # execution.
            if stole_lock_from_task:
                self._cleanup_stale_task_progress(image_repo, image,
                                                  stole_lock_from_task)

            task_repo.add(import_task)
            task_executor = executor_factory.new_task_executor(ctxt)
            pool = common.get_thread_pool(""tasks_pool"")
            pool.spawn(import_task.run, task_executor)
        except exception.Forbidden as e:
            LOG.debug(""User not permitted to create image import task."")
            raise webob.exc.HTTPForbidden(explanation=e.msg)
        except exception.Conflict as e:
            raise webob.exc.HTTPConflict(explanation=e.msg)
        except exception.InvalidImageStatusTransition as e:
            raise webob.exc.HTTPConflict(explanation=e.msg)
        except exception.LimitExceeded as e:
            raise webob.exc.HTTPRequestEntityTooLarge(explanation=str(e),
                                                      request=req)
        except ValueError as e:
            LOG.debug(""Cannot import data for image %(id)s: %(e)s"",
                      {'id': image_id,
                       'e': encodeutils.exception_to_unicode(e)})
            raise webob.exc.HTTPBadRequest(
                explanation=encodeutils.exception_to_unicode(e))"
149,apps/glance/glance/api/v2/images.py,task_executor,executor_factory.new_task_executor,user,ctxt.user_id,"try:
            import_task = task_factory.new_task(task_type='api_image_import',
                                                owner=ctxt.owner,
                                                task_input=task_input,
                                                image_id=image_id,
                                                user_id=ctxt.user_id,
                                                request_id=ctxt.request_id)

            # NOTE(danms): Try to grab the lock for this task
            try:
                image_repo.set_property_atomic(image,
                                               'os_glance_import_task',
                                               import_task.task_id)
            except exception.Duplicate:
                msg = (_(""New operation on image '%s' is not permitted as ""
                         ""prior operation is still in progress"") % image_id)
                raise exception.Conflict(msg)

            # NOTE(danms): We now have the import lock on this image. If we
            # busted the lock above and have a reference to that task, try
            # to clean up the import status information left over from that
            # execution.
            if stole_lock_from_task:
                self._cleanup_stale_task_progress(image_repo, image,
                                                  stole_lock_from_task)

            task_repo.add(import_task)
            task_executor = executor_factory.new_task_executor(ctxt)
            pool = common.get_thread_pool(""tasks_pool"")
            pool.spawn(import_task.run, task_executor)
        except exception.Forbidden as e:
            LOG.debug(""User not permitted to create image import task."")
            raise webob.exc.HTTPForbidden(explanation=e.msg)
        except exception.Conflict as e:
            raise webob.exc.HTTPConflict(explanation=e.msg)
        except exception.InvalidImageStatusTransition as e:
            raise webob.exc.HTTPConflict(explanation=e.msg)
        except exception.LimitExceeded as e:
            raise webob.exc.HTTPRequestEntityTooLarge(explanation=str(e),
                                                      request=req)
        except ValueError as e:
            LOG.debug(""Cannot import data for image %(id)s: %(e)s"",
                      {'id': image_id,
                       'e': encodeutils.exception_to_unicode(e)})
            raise webob.exc.HTTPBadRequest(
                explanation=encodeutils.exception_to_unicode(e))"
150,apps/glance/glance/api/v2/images.py,task_executor,import_image.executor_factory,user,ctxt.user_id,"try:
            import_task = task_factory.new_task(task_type='api_image_import',
                                                owner=ctxt.owner,
                                                task_input=task_input,
                                                image_id=image_id,
                                                user_id=ctxt.user_id,
                                                request_id=ctxt.request_id)

            # NOTE(danms): Try to grab the lock for this task
            try:
                image_repo.set_property_atomic(image,
                                               'os_glance_import_task',
                                               import_task.task_id)
            except exception.Duplicate:
                msg = (_(""New operation on image '%s' is not permitted as ""
                         ""prior operation is still in progress"") % image_id)
                raise exception.Conflict(msg)

            # NOTE(danms): We now have the import lock on this image. If we
            # busted the lock above and have a reference to that task, try
            # to clean up the import status information left over from that
            # execution.
            if stole_lock_from_task:
                self._cleanup_stale_task_progress(image_repo, image,
                                                  stole_lock_from_task)

            task_repo.add(import_task)
            task_executor = executor_factory.new_task_executor(ctxt)
            pool = common.get_thread_pool(""tasks_pool"")
            pool.spawn(import_task.run, task_executor)
        except exception.Forbidden as e:
            LOG.debug(""User not permitted to create image import task."")
            raise webob.exc.HTTPForbidden(explanation=e.msg)
        except exception.Conflict as e:
            raise webob.exc.HTTPConflict(explanation=e.msg)
        except exception.InvalidImageStatusTransition as e:
            raise webob.exc.HTTPConflict(explanation=e.msg)
        except exception.LimitExceeded as e:
            raise webob.exc.HTTPRequestEntityTooLarge(explanation=str(e),
                                                      request=req)
        except ValueError as e:
            LOG.debug(""Cannot import data for image %(id)s: %(e)s"",
                      {'id': image_id,
                       'e': encodeutils.exception_to_unicode(e)})
            raise webob.exc.HTTPBadRequest(
                explanation=encodeutils.exception_to_unicode(e))"
151,apps/glance/glance/api/v2/images.py,task_executor,import_image.executor_factory.new_task_executor,user,ctxt.user_id,"try:
            import_task = task_factory.new_task(task_type='api_image_import',
                                                owner=ctxt.owner,
                                                task_input=task_input,
                                                image_id=image_id,
                                                user_id=ctxt.user_id,
                                                request_id=ctxt.request_id)

            # NOTE(danms): Try to grab the lock for this task
            try:
                image_repo.set_property_atomic(image,
                                               'os_glance_import_task',
                                               import_task.task_id)
            except exception.Duplicate:
                msg = (_(""New operation on image '%s' is not permitted as ""
                         ""prior operation is still in progress"") % image_id)
                raise exception.Conflict(msg)

            # NOTE(danms): We now have the import lock on this image. If we
            # busted the lock above and have a reference to that task, try
            # to clean up the import status information left over from that
            # execution.
            if stole_lock_from_task:
                self._cleanup_stale_task_progress(image_repo, image,
                                                  stole_lock_from_task)

            task_repo.add(import_task)
            task_executor = executor_factory.new_task_executor(ctxt)
            pool = common.get_thread_pool(""tasks_pool"")
            pool.spawn(import_task.run, task_executor)
        except exception.Forbidden as e:
            LOG.debug(""User not permitted to create image import task."")
            raise webob.exc.HTTPForbidden(explanation=e.msg)
        except exception.Conflict as e:
            raise webob.exc.HTTPConflict(explanation=e.msg)
        except exception.InvalidImageStatusTransition as e:
            raise webob.exc.HTTPConflict(explanation=e.msg)
        except exception.LimitExceeded as e:
            raise webob.exc.HTTPRequestEntityTooLarge(explanation=str(e),
                                                      request=req)
        except ValueError as e:
            LOG.debug(""Cannot import data for image %(id)s: %(e)s"",
                      {'id': image_id,
                       'e': encodeutils.exception_to_unicode(e)})
            raise webob.exc.HTTPBadRequest(
                explanation=encodeutils.exception_to_unicode(e))"
152,apps/glance/glance/api/v2/images.py,debug,LOG.debug,user,import_image.ctxt.user_id,"try:
            import_task = task_factory.new_task(task_type='api_image_import',
                                                owner=ctxt.owner,
                                                task_input=task_input,
                                                image_id=image_id,
                                                user_id=ctxt.user_id,
                                                request_id=ctxt.request_id)

            # NOTE(danms): Try to grab the lock for this task
            try:
                image_repo.set_property_atomic(image,
                                               'os_glance_import_task',
                                               import_task.task_id)
            except exception.Duplicate:
                msg = (_(""New operation on image '%s' is not permitted as ""
                         ""prior operation is still in progress"") % image_id)
                raise exception.Conflict(msg)

            # NOTE(danms): We now have the import lock on this image. If we
            # busted the lock above and have a reference to that task, try
            # to clean up the import status information left over from that
            # execution.
            if stole_lock_from_task:
                self._cleanup_stale_task_progress(image_repo, image,
                                                  stole_lock_from_task)

            task_repo.add(import_task)
            task_executor = executor_factory.new_task_executor(ctxt)
            pool = common.get_thread_pool(""tasks_pool"")
            pool.spawn(import_task.run, task_executor)
        except exception.Forbidden as e:
            LOG.debug(""User not permitted to create image import task."")
            raise webob.exc.HTTPForbidden(explanation=e.msg)
        except exception.Conflict as e:
            raise webob.exc.HTTPConflict(explanation=e.msg)
        except exception.InvalidImageStatusTransition as e:
            raise webob.exc.HTTPConflict(explanation=e.msg)
        except exception.LimitExceeded as e:
            raise webob.exc.HTTPRequestEntityTooLarge(explanation=str(e),
                                                      request=req)
        except ValueError as e:
            LOG.debug(""Cannot import data for image %(id)s: %(e)s"",
                      {'id': image_id,
                       'e': encodeutils.exception_to_unicode(e)})
            raise webob.exc.HTTPBadRequest(
                explanation=encodeutils.exception_to_unicode(e))"
153,apps/glance/glance/api/v2/images.py,debug,LOG.debug,user,ctxt.user_id,"try:
            import_task = task_factory.new_task(task_type='api_image_import',
                                                owner=ctxt.owner,
                                                task_input=task_input,
                                                image_id=image_id,
                                                user_id=ctxt.user_id,
                                                request_id=ctxt.request_id)

            # NOTE(danms): Try to grab the lock for this task
            try:
                image_repo.set_property_atomic(image,
                                               'os_glance_import_task',
                                               import_task.task_id)
            except exception.Duplicate:
                msg = (_(""New operation on image '%s' is not permitted as ""
                         ""prior operation is still in progress"") % image_id)
                raise exception.Conflict(msg)

            # NOTE(danms): We now have the import lock on this image. If we
            # busted the lock above and have a reference to that task, try
            # to clean up the import status information left over from that
            # execution.
            if stole_lock_from_task:
                self._cleanup_stale_task_progress(image_repo, image,
                                                  stole_lock_from_task)

            task_repo.add(import_task)
            task_executor = executor_factory.new_task_executor(ctxt)
            pool = common.get_thread_pool(""tasks_pool"")
            pool.spawn(import_task.run, task_executor)
        except exception.Forbidden as e:
            LOG.debug(""User not permitted to create image import task."")
            raise webob.exc.HTTPForbidden(explanation=e.msg)
        except exception.Conflict as e:
            raise webob.exc.HTTPConflict(explanation=e.msg)
        except exception.InvalidImageStatusTransition as e:
            raise webob.exc.HTTPConflict(explanation=e.msg)
        except exception.LimitExceeded as e:
            raise webob.exc.HTTPRequestEntityTooLarge(explanation=str(e),
                                                      request=req)
        except ValueError as e:
            LOG.debug(""Cannot import data for image %(id)s: %(e)s"",
                      {'id': image_id,
                       'e': encodeutils.exception_to_unicode(e)})
            raise webob.exc.HTTPBadRequest(
                explanation=encodeutils.exception_to_unicode(e))"
154,apps/glance/glance/api/v2/images.py,debug,LOG.debug,task_executor,executor_factory.new_task_executor,"try:
            import_task = task_factory.new_task(task_type='api_image_import',
                                                owner=ctxt.owner,
                                                task_input=task_input,
                                                image_id=image_id,
                                                user_id=ctxt.user_id,
                                                request_id=ctxt.request_id)

            # NOTE(danms): Try to grab the lock for this task
            try:
                image_repo.set_property_atomic(image,
                                               'os_glance_import_task',
                                               import_task.task_id)
            except exception.Duplicate:
                msg = (_(""New operation on image '%s' is not permitted as ""
                         ""prior operation is still in progress"") % image_id)
                raise exception.Conflict(msg)

            # NOTE(danms): We now have the import lock on this image. If we
            # busted the lock above and have a reference to that task, try
            # to clean up the import status information left over from that
            # execution.
            if stole_lock_from_task:
                self._cleanup_stale_task_progress(image_repo, image,
                                                  stole_lock_from_task)

            task_repo.add(import_task)
            task_executor = executor_factory.new_task_executor(ctxt)
            pool = common.get_thread_pool(""tasks_pool"")
            pool.spawn(import_task.run, task_executor)
        except exception.Forbidden as e:
            LOG.debug(""User not permitted to create image import task."")
            raise webob.exc.HTTPForbidden(explanation=e.msg)
        except exception.Conflict as e:
            raise webob.exc.HTTPConflict(explanation=e.msg)
        except exception.InvalidImageStatusTransition as e:
            raise webob.exc.HTTPConflict(explanation=e.msg)
        except exception.LimitExceeded as e:
            raise webob.exc.HTTPRequestEntityTooLarge(explanation=str(e),
                                                      request=req)
        except ValueError as e:
            LOG.debug(""Cannot import data for image %(id)s: %(e)s"",
                      {'id': image_id,
                       'e': encodeutils.exception_to_unicode(e)})
            raise webob.exc.HTTPBadRequest(
                explanation=encodeutils.exception_to_unicode(e))"
155,apps/glance/glance/api/v2/images.py,debug,LOG.debug,task_executor,import_image.executor_factory,"try:
            import_task = task_factory.new_task(task_type='api_image_import',
                                                owner=ctxt.owner,
                                                task_input=task_input,
                                                image_id=image_id,
                                                user_id=ctxt.user_id,
                                                request_id=ctxt.request_id)

            # NOTE(danms): Try to grab the lock for this task
            try:
                image_repo.set_property_atomic(image,
                                               'os_glance_import_task',
                                               import_task.task_id)
            except exception.Duplicate:
                msg = (_(""New operation on image '%s' is not permitted as ""
                         ""prior operation is still in progress"") % image_id)
                raise exception.Conflict(msg)

            # NOTE(danms): We now have the import lock on this image. If we
            # busted the lock above and have a reference to that task, try
            # to clean up the import status information left over from that
            # execution.
            if stole_lock_from_task:
                self._cleanup_stale_task_progress(image_repo, image,
                                                  stole_lock_from_task)

            task_repo.add(import_task)
            task_executor = executor_factory.new_task_executor(ctxt)
            pool = common.get_thread_pool(""tasks_pool"")
            pool.spawn(import_task.run, task_executor)
        except exception.Forbidden as e:
            LOG.debug(""User not permitted to create image import task."")
            raise webob.exc.HTTPForbidden(explanation=e.msg)
        except exception.Conflict as e:
            raise webob.exc.HTTPConflict(explanation=e.msg)
        except exception.InvalidImageStatusTransition as e:
            raise webob.exc.HTTPConflict(explanation=e.msg)
        except exception.LimitExceeded as e:
            raise webob.exc.HTTPRequestEntityTooLarge(explanation=str(e),
                                                      request=req)
        except ValueError as e:
            LOG.debug(""Cannot import data for image %(id)s: %(e)s"",
                      {'id': image_id,
                       'e': encodeutils.exception_to_unicode(e)})
            raise webob.exc.HTTPBadRequest(
                explanation=encodeutils.exception_to_unicode(e))"
156,apps/glance/glance/api/v2/images.py,debug,LOG.debug,task_executor,import_image.executor_factory.new_task_executor,"try:
            import_task = task_factory.new_task(task_type='api_image_import',
                                                owner=ctxt.owner,
                                                task_input=task_input,
                                                image_id=image_id,
                                                user_id=ctxt.user_id,
                                                request_id=ctxt.request_id)

            # NOTE(danms): Try to grab the lock for this task
            try:
                image_repo.set_property_atomic(image,
                                               'os_glance_import_task',
                                               import_task.task_id)
            except exception.Duplicate:
                msg = (_(""New operation on image '%s' is not permitted as ""
                         ""prior operation is still in progress"") % image_id)
                raise exception.Conflict(msg)

            # NOTE(danms): We now have the import lock on this image. If we
            # busted the lock above and have a reference to that task, try
            # to clean up the import status information left over from that
            # execution.
            if stole_lock_from_task:
                self._cleanup_stale_task_progress(image_repo, image,
                                                  stole_lock_from_task)

            task_repo.add(import_task)
            task_executor = executor_factory.new_task_executor(ctxt)
            pool = common.get_thread_pool(""tasks_pool"")
            pool.spawn(import_task.run, task_executor)
        except exception.Forbidden as e:
            LOG.debug(""User not permitted to create image import task."")
            raise webob.exc.HTTPForbidden(explanation=e.msg)
        except exception.Conflict as e:
            raise webob.exc.HTTPConflict(explanation=e.msg)
        except exception.InvalidImageStatusTransition as e:
            raise webob.exc.HTTPConflict(explanation=e.msg)
        except exception.LimitExceeded as e:
            raise webob.exc.HTTPRequestEntityTooLarge(explanation=str(e),
                                                      request=req)
        except ValueError as e:
            LOG.debug(""Cannot import data for image %(id)s: %(e)s"",
                      {'id': image_id,
                       'e': encodeutils.exception_to_unicode(e)})
            raise webob.exc.HTTPBadRequest(
                explanation=encodeutils.exception_to_unicode(e))"
157,apps/glance/glance/api/v2/images.py,debug,LOG.debug,key,index.sort_key,"try:
            # NOTE(danms): This is just a ""do you have permission to
            # list images"" check. Each image is checked against
            # get_image below.
            target = {'project_id': req.context.project_id}
            self.policy.enforce(req.context, 'get_images', target)

            images = image_repo.list(marker=marker, limit=limit,
                                     sort_key=sort_key,
                                     sort_dir=sort_dir,
                                     filters=filters,
                                     member_status=member_status)
            db_image_count = len(images)
            images = [image for image in images
                      if api_policy.ImageAPIPolicy(req.context, image,
                                                   self.policy
                                                   ).check('get_image')]

            # NOTE(danms): we need to include the next marker if the DB
            # paginated. Since we filter images based on policy, we can
            # not determine if pagination happened from the final list,
            # so use the original count.
            if len(images) != 0 and db_image_count == limit:
                result['next_marker'] = images[-1].image_id
        except (exception.NotFound, exception.InvalidSortKey,
                exception.InvalidFilterRangeValue,
                exception.InvalidParameterValue,
                exception.InvalidFilterOperatorValue) as e:
            raise webob.exc.HTTPBadRequest(explanation=e.msg)
        except exception.Forbidden as e:
            LOG.debug(""User not permitted to retrieve images index"")
            raise webob.exc.HTTPForbidden(explanation=e.msg)
        except exception.NotAuthenticated as e:
            raise webob.exc.HTTPUnauthorized(explanation=e.msg)"
158,apps/glance/glance/api/v2/images.py,debug,LOG.debug,key,index.images,"try:
            # NOTE(danms): This is just a ""do you have permission to
            # list images"" check. Each image is checked against
            # get_image below.
            target = {'project_id': req.context.project_id}
            self.policy.enforce(req.context, 'get_images', target)

            images = image_repo.list(marker=marker, limit=limit,
                                     sort_key=sort_key,
                                     sort_dir=sort_dir,
                                     filters=filters,
                                     member_status=member_status)
            db_image_count = len(images)
            images = [image for image in images
                      if api_policy.ImageAPIPolicy(req.context, image,
                                                   self.policy
                                                   ).check('get_image')]

            # NOTE(danms): we need to include the next marker if the DB
            # paginated. Since we filter images based on policy, we can
            # not determine if pagination happened from the final list,
            # so use the original count.
            if len(images) != 0 and db_image_count == limit:
                result['next_marker'] = images[-1].image_id
        except (exception.NotFound, exception.InvalidSortKey,
                exception.InvalidFilterRangeValue,
                exception.InvalidParameterValue,
                exception.InvalidFilterOperatorValue) as e:
            raise webob.exc.HTTPBadRequest(explanation=e.msg)
        except exception.Forbidden as e:
            LOG.debug(""User not permitted to retrieve images index"")
            raise webob.exc.HTTPForbidden(explanation=e.msg)
        except exception.NotAuthenticated as e:
            raise webob.exc.HTTPUnauthorized(explanation=e.msg)"
159,apps/glance/glance/api/v2/images.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"try:
            image = image_repo.get(image_id)

            # NOTE(abhishekk): This is the right place to check whether user
            # have permission to delete the image and remove the policy check
            # later from the policy layer.
            api_pol = api_policy.ImageAPIPolicy(req.context, image,
                                                self.policy)
            api_pol.delete_image()

            if self.is_proxyable(image):
                # NOTE(danms): Image is staged on another worker; proxy the
                # delete request to that worker with the user's token, as if
                # they had called it themselves.
                image = self._delete_image_on_remote(image, req)
                if image is None:
                    # Delete was proxied, so we are done here.
                    return

            # NOTE(abhishekk): Delete the data from staging area
            if CONF.enabled_backends:
                separator, staging_dir = store_utils.get_dir_separator()
                file_path = ""%s%s%s"" % (staging_dir,
                                        separator,
                                        image_id)
                try:
                    fn_call = glance_store.get_store_from_store_identifier
                    staging_store = fn_call('os_glance_staging_store')
                    loc = location.get_location_from_uri_and_backend(
                        file_path, 'os_glance_staging_store')
                    staging_store.delete(loc)
                except (glance_store.exceptions.NotFound,
                        glance_store.exceptions.UnknownScheme):
                    pass
            else:
                file_path = str(
                    CONF.node_staging_uri + '/' + image_id)[7:]
                if os.path.exists(file_path):
                    try:
                        LOG.debug(
                            ""After upload to the backend, deleting staged ""
                            ""image data from %(fn)s"", {'fn': file_path})
                        os.unlink(file_path)
                    except OSError as e:
                        LOG.error(
                            ""After upload to backend, deletion of staged ""
                            ""image data from %(fn)s has failed because ""
                            ""[Errno %(en)d]"", {'fn': file_path,
                                               'en': e.errno})
                else:
                    LOG.warning(_(
                        ""After upload to backend, deletion of staged ""
                        ""image data has failed because ""
                        ""it cannot be found at %(fn)s""), {'fn': file_path})

            image.delete()
            self._delete_encryption_key(req.context, image)
            image_repo.remove(image)
        except (glance_store.Forbidden, exception.Forbidden) as e:
            LOG.debug(""User not permitted to delete image '%s'"", image_id)
            raise webob.exc.HTTPForbidden(explanation=e.msg)
        except (glance_store.NotFound, exception.NotFound):
            msg = (_(""Failed to find image %(image_id)s to delete"") %
                   {'image_id': image_id})
            LOG.warning(msg)
            raise webob.exc.HTTPNotFound(explanation=msg)
        except glance_store.exceptions.InUseByStore as e:
            msg = (_(""Image %(id)s could not be deleted ""
                     ""because it is in use: %(exc)s"") %
                   {""id"": image_id,
                    ""exc"": e.msg})
            LOG.warning(msg)
            raise webob.exc.HTTPConflict(explanation=msg)
        except glance_store.exceptions.HasSnapshot as e:
            raise webob.exc.HTTPConflict(explanation=e.msg)
        except exception.InvalidImageStatusTransition as e:
            raise webob.exc.HTTPBadRequest(explanation=e.msg)
        except exception.NotAuthenticated as e:
            raise webob.exc.HTTPUnauthorized(explanation=e.msg)"
160,apps/glance/glance/api/v2/images.py,enabled_backends,CONF.enabled_backends,key,self._delete_encryption_key,"try:
            image = image_repo.get(image_id)

            # NOTE(abhishekk): This is the right place to check whether user
            # have permission to delete the image and remove the policy check
            # later from the policy layer.
            api_pol = api_policy.ImageAPIPolicy(req.context, image,
                                                self.policy)
            api_pol.delete_image()

            if self.is_proxyable(image):
                # NOTE(danms): Image is staged on another worker; proxy the
                # delete request to that worker with the user's token, as if
                # they had called it themselves.
                image = self._delete_image_on_remote(image, req)
                if image is None:
                    # Delete was proxied, so we are done here.
                    return

            # NOTE(abhishekk): Delete the data from staging area
            if CONF.enabled_backends:
                separator, staging_dir = store_utils.get_dir_separator()
                file_path = ""%s%s%s"" % (staging_dir,
                                        separator,
                                        image_id)
                try:
                    fn_call = glance_store.get_store_from_store_identifier
                    staging_store = fn_call('os_glance_staging_store')
                    loc = location.get_location_from_uri_and_backend(
                        file_path, 'os_glance_staging_store')
                    staging_store.delete(loc)
                except (glance_store.exceptions.NotFound,
                        glance_store.exceptions.UnknownScheme):
                    pass
            else:
                file_path = str(
                    CONF.node_staging_uri + '/' + image_id)[7:]
                if os.path.exists(file_path):
                    try:
                        LOG.debug(
                            ""After upload to the backend, deleting staged ""
                            ""image data from %(fn)s"", {'fn': file_path})
                        os.unlink(file_path)
                    except OSError as e:
                        LOG.error(
                            ""After upload to backend, deletion of staged ""
                            ""image data from %(fn)s has failed because ""
                            ""[Errno %(en)d]"", {'fn': file_path,
                                               'en': e.errno})
                else:
                    LOG.warning(_(
                        ""After upload to backend, deletion of staged ""
                        ""image data has failed because ""
                        ""it cannot be found at %(fn)s""), {'fn': file_path})

            image.delete()
            self._delete_encryption_key(req.context, image)
            image_repo.remove(image)
        except (glance_store.Forbidden, exception.Forbidden) as e:
            LOG.debug(""User not permitted to delete image '%s'"", image_id)
            raise webob.exc.HTTPForbidden(explanation=e.msg)
        except (glance_store.NotFound, exception.NotFound):
            msg = (_(""Failed to find image %(image_id)s to delete"") %
                   {'image_id': image_id})
            LOG.warning(msg)
            raise webob.exc.HTTPNotFound(explanation=msg)
        except glance_store.exceptions.InUseByStore as e:
            msg = (_(""Image %(id)s could not be deleted ""
                     ""because it is in use: %(exc)s"") %
                   {""id"": image_id,
                    ""exc"": e.msg})
            LOG.warning(msg)
            raise webob.exc.HTTPConflict(explanation=msg)
        except glance_store.exceptions.HasSnapshot as e:
            raise webob.exc.HTTPConflict(explanation=e.msg)
        except exception.InvalidImageStatusTransition as e:
            raise webob.exc.HTTPBadRequest(explanation=e.msg)
        except exception.NotAuthenticated as e:
            raise webob.exc.HTTPUnauthorized(explanation=e.msg)"
161,apps/glance/glance/api/v2/images.py,enabled,CONF.enabled_backends,key,self._delete_encryption_key,"try:
            image = image_repo.get(image_id)

            # NOTE(abhishekk): This is the right place to check whether user
            # have permission to delete the image and remove the policy check
            # later from the policy layer.
            api_pol = api_policy.ImageAPIPolicy(req.context, image,
                                                self.policy)
            api_pol.delete_image()

            if self.is_proxyable(image):
                # NOTE(danms): Image is staged on another worker; proxy the
                # delete request to that worker with the user's token, as if
                # they had called it themselves.
                image = self._delete_image_on_remote(image, req)
                if image is None:
                    # Delete was proxied, so we are done here.
                    return

            # NOTE(abhishekk): Delete the data from staging area
            if CONF.enabled_backends:
                separator, staging_dir = store_utils.get_dir_separator()
                file_path = ""%s%s%s"" % (staging_dir,
                                        separator,
                                        image_id)
                try:
                    fn_call = glance_store.get_store_from_store_identifier
                    staging_store = fn_call('os_glance_staging_store')
                    loc = location.get_location_from_uri_and_backend(
                        file_path, 'os_glance_staging_store')
                    staging_store.delete(loc)
                except (glance_store.exceptions.NotFound,
                        glance_store.exceptions.UnknownScheme):
                    pass
            else:
                file_path = str(
                    CONF.node_staging_uri + '/' + image_id)[7:]
                if os.path.exists(file_path):
                    try:
                        LOG.debug(
                            ""After upload to the backend, deleting staged ""
                            ""image data from %(fn)s"", {'fn': file_path})
                        os.unlink(file_path)
                    except OSError as e:
                        LOG.error(
                            ""After upload to backend, deletion of staged ""
                            ""image data from %(fn)s has failed because ""
                            ""[Errno %(en)d]"", {'fn': file_path,
                                               'en': e.errno})
                else:
                    LOG.warning(_(
                        ""After upload to backend, deletion of staged ""
                        ""image data has failed because ""
                        ""it cannot be found at %(fn)s""), {'fn': file_path})

            image.delete()
            self._delete_encryption_key(req.context, image)
            image_repo.remove(image)
        except (glance_store.Forbidden, exception.Forbidden) as e:
            LOG.debug(""User not permitted to delete image '%s'"", image_id)
            raise webob.exc.HTTPForbidden(explanation=e.msg)
        except (glance_store.NotFound, exception.NotFound):
            msg = (_(""Failed to find image %(image_id)s to delete"") %
                   {'image_id': image_id})
            LOG.warning(msg)
            raise webob.exc.HTTPNotFound(explanation=msg)
        except glance_store.exceptions.InUseByStore as e:
            msg = (_(""Image %(id)s could not be deleted ""
                     ""because it is in use: %(exc)s"") %
                   {""id"": image_id,
                    ""exc"": e.msg})
            LOG.warning(msg)
            raise webob.exc.HTTPConflict(explanation=msg)
        except glance_store.exceptions.HasSnapshot as e:
            raise webob.exc.HTTPConflict(explanation=e.msg)
        except exception.InvalidImageStatusTransition as e:
            raise webob.exc.HTTPBadRequest(explanation=e.msg)
        except exception.NotAuthenticated as e:
            raise webob.exc.HTTPUnauthorized(explanation=e.msg)"
162,apps/glance/glance/api/v2/images.py,debug,LOG.debug,enabled,CONF.enabled_backends,"try:
            image = image_repo.get(image_id)

            # NOTE(abhishekk): This is the right place to check whether user
            # have permission to delete the image and remove the policy check
            # later from the policy layer.
            api_pol = api_policy.ImageAPIPolicy(req.context, image,
                                                self.policy)
            api_pol.delete_image()

            if self.is_proxyable(image):
                # NOTE(danms): Image is staged on another worker; proxy the
                # delete request to that worker with the user's token, as if
                # they had called it themselves.
                image = self._delete_image_on_remote(image, req)
                if image is None:
                    # Delete was proxied, so we are done here.
                    return

            # NOTE(abhishekk): Delete the data from staging area
            if CONF.enabled_backends:
                separator, staging_dir = store_utils.get_dir_separator()
                file_path = ""%s%s%s"" % (staging_dir,
                                        separator,
                                        image_id)
                try:
                    fn_call = glance_store.get_store_from_store_identifier
                    staging_store = fn_call('os_glance_staging_store')
                    loc = location.get_location_from_uri_and_backend(
                        file_path, 'os_glance_staging_store')
                    staging_store.delete(loc)
                except (glance_store.exceptions.NotFound,
                        glance_store.exceptions.UnknownScheme):
                    pass
            else:
                file_path = str(
                    CONF.node_staging_uri + '/' + image_id)[7:]
                if os.path.exists(file_path):
                    try:
                        LOG.debug(
                            ""After upload to the backend, deleting staged ""
                            ""image data from %(fn)s"", {'fn': file_path})
                        os.unlink(file_path)
                    except OSError as e:
                        LOG.error(
                            ""After upload to backend, deletion of staged ""
                            ""image data from %(fn)s has failed because ""
                            ""[Errno %(en)d]"", {'fn': file_path,
                                               'en': e.errno})
                else:
                    LOG.warning(_(
                        ""After upload to backend, deletion of staged ""
                        ""image data has failed because ""
                        ""it cannot be found at %(fn)s""), {'fn': file_path})

            image.delete()
            self._delete_encryption_key(req.context, image)
            image_repo.remove(image)
        except (glance_store.Forbidden, exception.Forbidden) as e:
            LOG.debug(""User not permitted to delete image '%s'"", image_id)
            raise webob.exc.HTTPForbidden(explanation=e.msg)
        except (glance_store.NotFound, exception.NotFound):
            msg = (_(""Failed to find image %(image_id)s to delete"") %
                   {'image_id': image_id})
            LOG.warning(msg)
            raise webob.exc.HTTPNotFound(explanation=msg)
        except glance_store.exceptions.InUseByStore as e:
            msg = (_(""Image %(id)s could not be deleted ""
                     ""because it is in use: %(exc)s"") %
                   {""id"": image_id,
                    ""exc"": e.msg})
            LOG.warning(msg)
            raise webob.exc.HTTPConflict(explanation=msg)
        except glance_store.exceptions.HasSnapshot as e:
            raise webob.exc.HTTPConflict(explanation=e.msg)
        except exception.InvalidImageStatusTransition as e:
            raise webob.exc.HTTPBadRequest(explanation=e.msg)
        except exception.NotAuthenticated as e:
            raise webob.exc.HTTPUnauthorized(explanation=e.msg)"
163,apps/glance/glance/api/v2/images.py,debug,LOG.debug,enabled_backends,CONF.enabled_backends,"try:
            image = image_repo.get(image_id)

            # NOTE(abhishekk): This is the right place to check whether user
            # have permission to delete the image and remove the policy check
            # later from the policy layer.
            api_pol = api_policy.ImageAPIPolicy(req.context, image,
                                                self.policy)
            api_pol.delete_image()

            if self.is_proxyable(image):
                # NOTE(danms): Image is staged on another worker; proxy the
                # delete request to that worker with the user's token, as if
                # they had called it themselves.
                image = self._delete_image_on_remote(image, req)
                if image is None:
                    # Delete was proxied, so we are done here.
                    return

            # NOTE(abhishekk): Delete the data from staging area
            if CONF.enabled_backends:
                separator, staging_dir = store_utils.get_dir_separator()
                file_path = ""%s%s%s"" % (staging_dir,
                                        separator,
                                        image_id)
                try:
                    fn_call = glance_store.get_store_from_store_identifier
                    staging_store = fn_call('os_glance_staging_store')
                    loc = location.get_location_from_uri_and_backend(
                        file_path, 'os_glance_staging_store')
                    staging_store.delete(loc)
                except (glance_store.exceptions.NotFound,
                        glance_store.exceptions.UnknownScheme):
                    pass
            else:
                file_path = str(
                    CONF.node_staging_uri + '/' + image_id)[7:]
                if os.path.exists(file_path):
                    try:
                        LOG.debug(
                            ""After upload to the backend, deleting staged ""
                            ""image data from %(fn)s"", {'fn': file_path})
                        os.unlink(file_path)
                    except OSError as e:
                        LOG.error(
                            ""After upload to backend, deletion of staged ""
                            ""image data from %(fn)s has failed because ""
                            ""[Errno %(en)d]"", {'fn': file_path,
                                               'en': e.errno})
                else:
                    LOG.warning(_(
                        ""After upload to backend, deletion of staged ""
                        ""image data has failed because ""
                        ""it cannot be found at %(fn)s""), {'fn': file_path})

            image.delete()
            self._delete_encryption_key(req.context, image)
            image_repo.remove(image)
        except (glance_store.Forbidden, exception.Forbidden) as e:
            LOG.debug(""User not permitted to delete image '%s'"", image_id)
            raise webob.exc.HTTPForbidden(explanation=e.msg)
        except (glance_store.NotFound, exception.NotFound):
            msg = (_(""Failed to find image %(image_id)s to delete"") %
                   {'image_id': image_id})
            LOG.warning(msg)
            raise webob.exc.HTTPNotFound(explanation=msg)
        except glance_store.exceptions.InUseByStore as e:
            msg = (_(""Image %(id)s could not be deleted ""
                     ""because it is in use: %(exc)s"") %
                   {""id"": image_id,
                    ""exc"": e.msg})
            LOG.warning(msg)
            raise webob.exc.HTTPConflict(explanation=msg)
        except glance_store.exceptions.HasSnapshot as e:
            raise webob.exc.HTTPConflict(explanation=e.msg)
        except exception.InvalidImageStatusTransition as e:
            raise webob.exc.HTTPBadRequest(explanation=e.msg)
        except exception.NotAuthenticated as e:
            raise webob.exc.HTTPUnauthorized(explanation=e.msg)"
164,apps/glance/glance/api/v2/images.py,debug,LOG.debug,key,self._delete_encryption_key,"try:
            image = image_repo.get(image_id)

            # NOTE(abhishekk): This is the right place to check whether user
            # have permission to delete the image and remove the policy check
            # later from the policy layer.
            api_pol = api_policy.ImageAPIPolicy(req.context, image,
                                                self.policy)
            api_pol.delete_image()

            if self.is_proxyable(image):
                # NOTE(danms): Image is staged on another worker; proxy the
                # delete request to that worker with the user's token, as if
                # they had called it themselves.
                image = self._delete_image_on_remote(image, req)
                if image is None:
                    # Delete was proxied, so we are done here.
                    return

            # NOTE(abhishekk): Delete the data from staging area
            if CONF.enabled_backends:
                separator, staging_dir = store_utils.get_dir_separator()
                file_path = ""%s%s%s"" % (staging_dir,
                                        separator,
                                        image_id)
                try:
                    fn_call = glance_store.get_store_from_store_identifier
                    staging_store = fn_call('os_glance_staging_store')
                    loc = location.get_location_from_uri_and_backend(
                        file_path, 'os_glance_staging_store')
                    staging_store.delete(loc)
                except (glance_store.exceptions.NotFound,
                        glance_store.exceptions.UnknownScheme):
                    pass
            else:
                file_path = str(
                    CONF.node_staging_uri + '/' + image_id)[7:]
                if os.path.exists(file_path):
                    try:
                        LOG.debug(
                            ""After upload to the backend, deleting staged ""
                            ""image data from %(fn)s"", {'fn': file_path})
                        os.unlink(file_path)
                    except OSError as e:
                        LOG.error(
                            ""After upload to backend, deletion of staged ""
                            ""image data from %(fn)s has failed because ""
                            ""[Errno %(en)d]"", {'fn': file_path,
                                               'en': e.errno})
                else:
                    LOG.warning(_(
                        ""After upload to backend, deletion of staged ""
                        ""image data has failed because ""
                        ""it cannot be found at %(fn)s""), {'fn': file_path})

            image.delete()
            self._delete_encryption_key(req.context, image)
            image_repo.remove(image)
        except (glance_store.Forbidden, exception.Forbidden) as e:
            LOG.debug(""User not permitted to delete image '%s'"", image_id)
            raise webob.exc.HTTPForbidden(explanation=e.msg)
        except (glance_store.NotFound, exception.NotFound):
            msg = (_(""Failed to find image %(image_id)s to delete"") %
                   {'image_id': image_id})
            LOG.warning(msg)
            raise webob.exc.HTTPNotFound(explanation=msg)
        except glance_store.exceptions.InUseByStore as e:
            msg = (_(""Image %(id)s could not be deleted ""
                     ""because it is in use: %(exc)s"") %
                   {""id"": image_id,
                    ""exc"": e.msg})
            LOG.warning(msg)
            raise webob.exc.HTTPConflict(explanation=msg)
        except glance_store.exceptions.HasSnapshot as e:
            raise webob.exc.HTTPConflict(explanation=e.msg)
        except exception.InvalidImageStatusTransition as e:
            raise webob.exc.HTTPBadRequest(explanation=e.msg)
        except exception.NotAuthenticated as e:
            raise webob.exc.HTTPUnauthorized(explanation=e.msg)"
165,apps/glance/glance/api/v2/images.py,task_executor,add_location.self.gateway.get_task_executor_factory,user,add_location.ctxt.user_id,"try:
            image = image_repo.get(image_id)
            if image.status != 'queued':
                msg = _(""It's not allowed to add locations if image status is ""
                        ""%s."") % image.status
                raise webob.exc.HTTPConflict(explanation=msg)

            api_pol = api_policy.ImageAPIPolicy(req.context, image,
                                                self.policy)
            api_pol.add_location()

            roles = list(set(req.context.roles + req.context.service_roles))
            if 'service' not in roles:
                # NOTE(pdeore): Add location API is disabled for other stores
                # than http
                if not utils.is_http_store_configured(url):
                    msg = _(""http store must be enabled to use location API""
                            "" by normal user."")
                    raise exception.Forbidden(msg)

            if validation_data is not None:
                self._validate_hashing_data(validation_data)

            if 'os_glance_import_task' in image.extra_properties:
                # NOTE(pdeore): This will raise exception.Conflict if the
                # lock is present and valid, or return if absent or invalid.
                stole_lock_from_task = self._enforce_import_lock(req, image)

            task_input = {'image_id': image_id,
                          'loc_url': url,
                          'validation_data': validation_data}

            executor_factory = self.gateway.get_task_executor_factory(
                ctxt)
            add_location_task = task_factory.new_task(
                task_type='location_import',
                owner=ctxt.owner,
                task_input=task_input,
                image_id=image_id,
                user_id=ctxt.user_id,
                request_id=ctxt.request_id)

            try:
                # NOTE(pdeore): Try to grab the lock for this task
                image_repo.set_property_atomic(image, 'os_glance_import_task',
                                               add_location_task.task_id)
            except exception.Duplicate:
                msg = (_(""New operation on image '%s' is not ""
                         ""permitted as prior operation is still ""
                         ""in progress"") % image_id)
                raise exception.Conflict(msg)

            # NOTE(pdeore): We now have the import lock on this image.
            # If we busted the lock above and have a reference to that
            # task, try to clean up the import status information left
            # over from that execution.
            if stole_lock_from_task:
                self._cleanup_stale_task_progress(image_repo, image,
                                                  stole_lock_from_task)

            task_repo.add(add_location_task)
            task_executor = executor_factory.new_task_executor(ctxt)
            pool = common.get_thread_pool(""tasks_pool"")
            pool.spawn(add_location_task.run, task_executor)
        except exception.Conflict as e:
            raise webob.exc.HTTPConflict(explanation=e.msg)
        except exception.NotFound as e:
            raise webob.exc.HTTPNotFound(explanation=e.msg)
        except exception.Forbidden as e:
            LOG.debug(""User not permitted to add location to image '%s'"",
                      image_id)
            raise webob.exc.HTTPForbidden(explanation=e.msg)
        except exception.NotAuthenticated as e:
            raise webob.exc.HTTPUnauthorized(explanation=e.msg)
        except ValueError as e:
            raise webob.exc.HTTPBadRequest(
                explanation=encodeutils.exception_to_unicode(e))"
166,apps/glance/glance/api/v2/images.py,task_executor,self.gateway.get_task_executor_factory,user,add_location.ctxt.user_id,"try:
            image = image_repo.get(image_id)
            if image.status != 'queued':
                msg = _(""It's not allowed to add locations if image status is ""
                        ""%s."") % image.status
                raise webob.exc.HTTPConflict(explanation=msg)

            api_pol = api_policy.ImageAPIPolicy(req.context, image,
                                                self.policy)
            api_pol.add_location()

            roles = list(set(req.context.roles + req.context.service_roles))
            if 'service' not in roles:
                # NOTE(pdeore): Add location API is disabled for other stores
                # than http
                if not utils.is_http_store_configured(url):
                    msg = _(""http store must be enabled to use location API""
                            "" by normal user."")
                    raise exception.Forbidden(msg)

            if validation_data is not None:
                self._validate_hashing_data(validation_data)

            if 'os_glance_import_task' in image.extra_properties:
                # NOTE(pdeore): This will raise exception.Conflict if the
                # lock is present and valid, or return if absent or invalid.
                stole_lock_from_task = self._enforce_import_lock(req, image)

            task_input = {'image_id': image_id,
                          'loc_url': url,
                          'validation_data': validation_data}

            executor_factory = self.gateway.get_task_executor_factory(
                ctxt)
            add_location_task = task_factory.new_task(
                task_type='location_import',
                owner=ctxt.owner,
                task_input=task_input,
                image_id=image_id,
                user_id=ctxt.user_id,
                request_id=ctxt.request_id)

            try:
                # NOTE(pdeore): Try to grab the lock for this task
                image_repo.set_property_atomic(image, 'os_glance_import_task',
                                               add_location_task.task_id)
            except exception.Duplicate:
                msg = (_(""New operation on image '%s' is not ""
                         ""permitted as prior operation is still ""
                         ""in progress"") % image_id)
                raise exception.Conflict(msg)

            # NOTE(pdeore): We now have the import lock on this image.
            # If we busted the lock above and have a reference to that
            # task, try to clean up the import status information left
            # over from that execution.
            if stole_lock_from_task:
                self._cleanup_stale_task_progress(image_repo, image,
                                                  stole_lock_from_task)

            task_repo.add(add_location_task)
            task_executor = executor_factory.new_task_executor(ctxt)
            pool = common.get_thread_pool(""tasks_pool"")
            pool.spawn(add_location_task.run, task_executor)
        except exception.Conflict as e:
            raise webob.exc.HTTPConflict(explanation=e.msg)
        except exception.NotFound as e:
            raise webob.exc.HTTPNotFound(explanation=e.msg)
        except exception.Forbidden as e:
            LOG.debug(""User not permitted to add location to image '%s'"",
                      image_id)
            raise webob.exc.HTTPForbidden(explanation=e.msg)
        except exception.NotAuthenticated as e:
            raise webob.exc.HTTPUnauthorized(explanation=e.msg)
        except ValueError as e:
            raise webob.exc.HTTPBadRequest(
                explanation=encodeutils.exception_to_unicode(e))"
167,apps/glance/glance/api/v2/images.py,task_executor,add_location.executor_factory,user,add_location.ctxt.user_id,"try:
            image = image_repo.get(image_id)
            if image.status != 'queued':
                msg = _(""It's not allowed to add locations if image status is ""
                        ""%s."") % image.status
                raise webob.exc.HTTPConflict(explanation=msg)

            api_pol = api_policy.ImageAPIPolicy(req.context, image,
                                                self.policy)
            api_pol.add_location()

            roles = list(set(req.context.roles + req.context.service_roles))
            if 'service' not in roles:
                # NOTE(pdeore): Add location API is disabled for other stores
                # than http
                if not utils.is_http_store_configured(url):
                    msg = _(""http store must be enabled to use location API""
                            "" by normal user."")
                    raise exception.Forbidden(msg)

            if validation_data is not None:
                self._validate_hashing_data(validation_data)

            if 'os_glance_import_task' in image.extra_properties:
                # NOTE(pdeore): This will raise exception.Conflict if the
                # lock is present and valid, or return if absent or invalid.
                stole_lock_from_task = self._enforce_import_lock(req, image)

            task_input = {'image_id': image_id,
                          'loc_url': url,
                          'validation_data': validation_data}

            executor_factory = self.gateway.get_task_executor_factory(
                ctxt)
            add_location_task = task_factory.new_task(
                task_type='location_import',
                owner=ctxt.owner,
                task_input=task_input,
                image_id=image_id,
                user_id=ctxt.user_id,
                request_id=ctxt.request_id)

            try:
                # NOTE(pdeore): Try to grab the lock for this task
                image_repo.set_property_atomic(image, 'os_glance_import_task',
                                               add_location_task.task_id)
            except exception.Duplicate:
                msg = (_(""New operation on image '%s' is not ""
                         ""permitted as prior operation is still ""
                         ""in progress"") % image_id)
                raise exception.Conflict(msg)

            # NOTE(pdeore): We now have the import lock on this image.
            # If we busted the lock above and have a reference to that
            # task, try to clean up the import status information left
            # over from that execution.
            if stole_lock_from_task:
                self._cleanup_stale_task_progress(image_repo, image,
                                                  stole_lock_from_task)

            task_repo.add(add_location_task)
            task_executor = executor_factory.new_task_executor(ctxt)
            pool = common.get_thread_pool(""tasks_pool"")
            pool.spawn(add_location_task.run, task_executor)
        except exception.Conflict as e:
            raise webob.exc.HTTPConflict(explanation=e.msg)
        except exception.NotFound as e:
            raise webob.exc.HTTPNotFound(explanation=e.msg)
        except exception.Forbidden as e:
            LOG.debug(""User not permitted to add location to image '%s'"",
                      image_id)
            raise webob.exc.HTTPForbidden(explanation=e.msg)
        except exception.NotAuthenticated as e:
            raise webob.exc.HTTPUnauthorized(explanation=e.msg)
        except ValueError as e:
            raise webob.exc.HTTPBadRequest(
                explanation=encodeutils.exception_to_unicode(e))"
168,apps/glance/glance/api/v2/images.py,task_executor,add_location.executor_factory.new_task_executor,user,add_location.ctxt.user_id,"try:
            image = image_repo.get(image_id)
            if image.status != 'queued':
                msg = _(""It's not allowed to add locations if image status is ""
                        ""%s."") % image.status
                raise webob.exc.HTTPConflict(explanation=msg)

            api_pol = api_policy.ImageAPIPolicy(req.context, image,
                                                self.policy)
            api_pol.add_location()

            roles = list(set(req.context.roles + req.context.service_roles))
            if 'service' not in roles:
                # NOTE(pdeore): Add location API is disabled for other stores
                # than http
                if not utils.is_http_store_configured(url):
                    msg = _(""http store must be enabled to use location API""
                            "" by normal user."")
                    raise exception.Forbidden(msg)

            if validation_data is not None:
                self._validate_hashing_data(validation_data)

            if 'os_glance_import_task' in image.extra_properties:
                # NOTE(pdeore): This will raise exception.Conflict if the
                # lock is present and valid, or return if absent or invalid.
                stole_lock_from_task = self._enforce_import_lock(req, image)

            task_input = {'image_id': image_id,
                          'loc_url': url,
                          'validation_data': validation_data}

            executor_factory = self.gateway.get_task_executor_factory(
                ctxt)
            add_location_task = task_factory.new_task(
                task_type='location_import',
                owner=ctxt.owner,
                task_input=task_input,
                image_id=image_id,
                user_id=ctxt.user_id,
                request_id=ctxt.request_id)

            try:
                # NOTE(pdeore): Try to grab the lock for this task
                image_repo.set_property_atomic(image, 'os_glance_import_task',
                                               add_location_task.task_id)
            except exception.Duplicate:
                msg = (_(""New operation on image '%s' is not ""
                         ""permitted as prior operation is still ""
                         ""in progress"") % image_id)
                raise exception.Conflict(msg)

            # NOTE(pdeore): We now have the import lock on this image.
            # If we busted the lock above and have a reference to that
            # task, try to clean up the import status information left
            # over from that execution.
            if stole_lock_from_task:
                self._cleanup_stale_task_progress(image_repo, image,
                                                  stole_lock_from_task)

            task_repo.add(add_location_task)
            task_executor = executor_factory.new_task_executor(ctxt)
            pool = common.get_thread_pool(""tasks_pool"")
            pool.spawn(add_location_task.run, task_executor)
        except exception.Conflict as e:
            raise webob.exc.HTTPConflict(explanation=e.msg)
        except exception.NotFound as e:
            raise webob.exc.HTTPNotFound(explanation=e.msg)
        except exception.Forbidden as e:
            LOG.debug(""User not permitted to add location to image '%s'"",
                      image_id)
            raise webob.exc.HTTPForbidden(explanation=e.msg)
        except exception.NotAuthenticated as e:
            raise webob.exc.HTTPUnauthorized(explanation=e.msg)
        except ValueError as e:
            raise webob.exc.HTTPBadRequest(
                explanation=encodeutils.exception_to_unicode(e))"
169,apps/glance/glance/api/v2/images.py,task_executor,executor_factory.new_task_executor,user,add_location.ctxt.user_id,"try:
            image = image_repo.get(image_id)
            if image.status != 'queued':
                msg = _(""It's not allowed to add locations if image status is ""
                        ""%s."") % image.status
                raise webob.exc.HTTPConflict(explanation=msg)

            api_pol = api_policy.ImageAPIPolicy(req.context, image,
                                                self.policy)
            api_pol.add_location()

            roles = list(set(req.context.roles + req.context.service_roles))
            if 'service' not in roles:
                # NOTE(pdeore): Add location API is disabled for other stores
                # than http
                if not utils.is_http_store_configured(url):
                    msg = _(""http store must be enabled to use location API""
                            "" by normal user."")
                    raise exception.Forbidden(msg)

            if validation_data is not None:
                self._validate_hashing_data(validation_data)

            if 'os_glance_import_task' in image.extra_properties:
                # NOTE(pdeore): This will raise exception.Conflict if the
                # lock is present and valid, or return if absent or invalid.
                stole_lock_from_task = self._enforce_import_lock(req, image)

            task_input = {'image_id': image_id,
                          'loc_url': url,
                          'validation_data': validation_data}

            executor_factory = self.gateway.get_task_executor_factory(
                ctxt)
            add_location_task = task_factory.new_task(
                task_type='location_import',
                owner=ctxt.owner,
                task_input=task_input,
                image_id=image_id,
                user_id=ctxt.user_id,
                request_id=ctxt.request_id)

            try:
                # NOTE(pdeore): Try to grab the lock for this task
                image_repo.set_property_atomic(image, 'os_glance_import_task',
                                               add_location_task.task_id)
            except exception.Duplicate:
                msg = (_(""New operation on image '%s' is not ""
                         ""permitted as prior operation is still ""
                         ""in progress"") % image_id)
                raise exception.Conflict(msg)

            # NOTE(pdeore): We now have the import lock on this image.
            # If we busted the lock above and have a reference to that
            # task, try to clean up the import status information left
            # over from that execution.
            if stole_lock_from_task:
                self._cleanup_stale_task_progress(image_repo, image,
                                                  stole_lock_from_task)

            task_repo.add(add_location_task)
            task_executor = executor_factory.new_task_executor(ctxt)
            pool = common.get_thread_pool(""tasks_pool"")
            pool.spawn(add_location_task.run, task_executor)
        except exception.Conflict as e:
            raise webob.exc.HTTPConflict(explanation=e.msg)
        except exception.NotFound as e:
            raise webob.exc.HTTPNotFound(explanation=e.msg)
        except exception.Forbidden as e:
            LOG.debug(""User not permitted to add location to image '%s'"",
                      image_id)
            raise webob.exc.HTTPForbidden(explanation=e.msg)
        except exception.NotAuthenticated as e:
            raise webob.exc.HTTPUnauthorized(explanation=e.msg)
        except ValueError as e:
            raise webob.exc.HTTPBadRequest(
                explanation=encodeutils.exception_to_unicode(e))"
170,apps/glance/glance/api/v2/images.py,task_executor,add_location.self.gateway.get_task_executor_factory,user,ctxt.user_id,"try:
            image = image_repo.get(image_id)
            if image.status != 'queued':
                msg = _(""It's not allowed to add locations if image status is ""
                        ""%s."") % image.status
                raise webob.exc.HTTPConflict(explanation=msg)

            api_pol = api_policy.ImageAPIPolicy(req.context, image,
                                                self.policy)
            api_pol.add_location()

            roles = list(set(req.context.roles + req.context.service_roles))
            if 'service' not in roles:
                # NOTE(pdeore): Add location API is disabled for other stores
                # than http
                if not utils.is_http_store_configured(url):
                    msg = _(""http store must be enabled to use location API""
                            "" by normal user."")
                    raise exception.Forbidden(msg)

            if validation_data is not None:
                self._validate_hashing_data(validation_data)

            if 'os_glance_import_task' in image.extra_properties:
                # NOTE(pdeore): This will raise exception.Conflict if the
                # lock is present and valid, or return if absent or invalid.
                stole_lock_from_task = self._enforce_import_lock(req, image)

            task_input = {'image_id': image_id,
                          'loc_url': url,
                          'validation_data': validation_data}

            executor_factory = self.gateway.get_task_executor_factory(
                ctxt)
            add_location_task = task_factory.new_task(
                task_type='location_import',
                owner=ctxt.owner,
                task_input=task_input,
                image_id=image_id,
                user_id=ctxt.user_id,
                request_id=ctxt.request_id)

            try:
                # NOTE(pdeore): Try to grab the lock for this task
                image_repo.set_property_atomic(image, 'os_glance_import_task',
                                               add_location_task.task_id)
            except exception.Duplicate:
                msg = (_(""New operation on image '%s' is not ""
                         ""permitted as prior operation is still ""
                         ""in progress"") % image_id)
                raise exception.Conflict(msg)

            # NOTE(pdeore): We now have the import lock on this image.
            # If we busted the lock above and have a reference to that
            # task, try to clean up the import status information left
            # over from that execution.
            if stole_lock_from_task:
                self._cleanup_stale_task_progress(image_repo, image,
                                                  stole_lock_from_task)

            task_repo.add(add_location_task)
            task_executor = executor_factory.new_task_executor(ctxt)
            pool = common.get_thread_pool(""tasks_pool"")
            pool.spawn(add_location_task.run, task_executor)
        except exception.Conflict as e:
            raise webob.exc.HTTPConflict(explanation=e.msg)
        except exception.NotFound as e:
            raise webob.exc.HTTPNotFound(explanation=e.msg)
        except exception.Forbidden as e:
            LOG.debug(""User not permitted to add location to image '%s'"",
                      image_id)
            raise webob.exc.HTTPForbidden(explanation=e.msg)
        except exception.NotAuthenticated as e:
            raise webob.exc.HTTPUnauthorized(explanation=e.msg)
        except ValueError as e:
            raise webob.exc.HTTPBadRequest(
                explanation=encodeutils.exception_to_unicode(e))"
171,apps/glance/glance/api/v2/images.py,task_executor,self.gateway.get_task_executor_factory,user,ctxt.user_id,"try:
            image = image_repo.get(image_id)
            if image.status != 'queued':
                msg = _(""It's not allowed to add locations if image status is ""
                        ""%s."") % image.status
                raise webob.exc.HTTPConflict(explanation=msg)

            api_pol = api_policy.ImageAPIPolicy(req.context, image,
                                                self.policy)
            api_pol.add_location()

            roles = list(set(req.context.roles + req.context.service_roles))
            if 'service' not in roles:
                # NOTE(pdeore): Add location API is disabled for other stores
                # than http
                if not utils.is_http_store_configured(url):
                    msg = _(""http store must be enabled to use location API""
                            "" by normal user."")
                    raise exception.Forbidden(msg)

            if validation_data is not None:
                self._validate_hashing_data(validation_data)

            if 'os_glance_import_task' in image.extra_properties:
                # NOTE(pdeore): This will raise exception.Conflict if the
                # lock is present and valid, or return if absent or invalid.
                stole_lock_from_task = self._enforce_import_lock(req, image)

            task_input = {'image_id': image_id,
                          'loc_url': url,
                          'validation_data': validation_data}

            executor_factory = self.gateway.get_task_executor_factory(
                ctxt)
            add_location_task = task_factory.new_task(
                task_type='location_import',
                owner=ctxt.owner,
                task_input=task_input,
                image_id=image_id,
                user_id=ctxt.user_id,
                request_id=ctxt.request_id)

            try:
                # NOTE(pdeore): Try to grab the lock for this task
                image_repo.set_property_atomic(image, 'os_glance_import_task',
                                               add_location_task.task_id)
            except exception.Duplicate:
                msg = (_(""New operation on image '%s' is not ""
                         ""permitted as prior operation is still ""
                         ""in progress"") % image_id)
                raise exception.Conflict(msg)

            # NOTE(pdeore): We now have the import lock on this image.
            # If we busted the lock above and have a reference to that
            # task, try to clean up the import status information left
            # over from that execution.
            if stole_lock_from_task:
                self._cleanup_stale_task_progress(image_repo, image,
                                                  stole_lock_from_task)

            task_repo.add(add_location_task)
            task_executor = executor_factory.new_task_executor(ctxt)
            pool = common.get_thread_pool(""tasks_pool"")
            pool.spawn(add_location_task.run, task_executor)
        except exception.Conflict as e:
            raise webob.exc.HTTPConflict(explanation=e.msg)
        except exception.NotFound as e:
            raise webob.exc.HTTPNotFound(explanation=e.msg)
        except exception.Forbidden as e:
            LOG.debug(""User not permitted to add location to image '%s'"",
                      image_id)
            raise webob.exc.HTTPForbidden(explanation=e.msg)
        except exception.NotAuthenticated as e:
            raise webob.exc.HTTPUnauthorized(explanation=e.msg)
        except ValueError as e:
            raise webob.exc.HTTPBadRequest(
                explanation=encodeutils.exception_to_unicode(e))"
172,apps/glance/glance/api/v2/images.py,task_executor,add_location.executor_factory,user,ctxt.user_id,"try:
            image = image_repo.get(image_id)
            if image.status != 'queued':
                msg = _(""It's not allowed to add locations if image status is ""
                        ""%s."") % image.status
                raise webob.exc.HTTPConflict(explanation=msg)

            api_pol = api_policy.ImageAPIPolicy(req.context, image,
                                                self.policy)
            api_pol.add_location()

            roles = list(set(req.context.roles + req.context.service_roles))
            if 'service' not in roles:
                # NOTE(pdeore): Add location API is disabled for other stores
                # than http
                if not utils.is_http_store_configured(url):
                    msg = _(""http store must be enabled to use location API""
                            "" by normal user."")
                    raise exception.Forbidden(msg)

            if validation_data is not None:
                self._validate_hashing_data(validation_data)

            if 'os_glance_import_task' in image.extra_properties:
                # NOTE(pdeore): This will raise exception.Conflict if the
                # lock is present and valid, or return if absent or invalid.
                stole_lock_from_task = self._enforce_import_lock(req, image)

            task_input = {'image_id': image_id,
                          'loc_url': url,
                          'validation_data': validation_data}

            executor_factory = self.gateway.get_task_executor_factory(
                ctxt)
            add_location_task = task_factory.new_task(
                task_type='location_import',
                owner=ctxt.owner,
                task_input=task_input,
                image_id=image_id,
                user_id=ctxt.user_id,
                request_id=ctxt.request_id)

            try:
                # NOTE(pdeore): Try to grab the lock for this task
                image_repo.set_property_atomic(image, 'os_glance_import_task',
                                               add_location_task.task_id)
            except exception.Duplicate:
                msg = (_(""New operation on image '%s' is not ""
                         ""permitted as prior operation is still ""
                         ""in progress"") % image_id)
                raise exception.Conflict(msg)

            # NOTE(pdeore): We now have the import lock on this image.
            # If we busted the lock above and have a reference to that
            # task, try to clean up the import status information left
            # over from that execution.
            if stole_lock_from_task:
                self._cleanup_stale_task_progress(image_repo, image,
                                                  stole_lock_from_task)

            task_repo.add(add_location_task)
            task_executor = executor_factory.new_task_executor(ctxt)
            pool = common.get_thread_pool(""tasks_pool"")
            pool.spawn(add_location_task.run, task_executor)
        except exception.Conflict as e:
            raise webob.exc.HTTPConflict(explanation=e.msg)
        except exception.NotFound as e:
            raise webob.exc.HTTPNotFound(explanation=e.msg)
        except exception.Forbidden as e:
            LOG.debug(""User not permitted to add location to image '%s'"",
                      image_id)
            raise webob.exc.HTTPForbidden(explanation=e.msg)
        except exception.NotAuthenticated as e:
            raise webob.exc.HTTPUnauthorized(explanation=e.msg)
        except ValueError as e:
            raise webob.exc.HTTPBadRequest(
                explanation=encodeutils.exception_to_unicode(e))"
173,apps/glance/glance/api/v2/images.py,task_executor,add_location.executor_factory.new_task_executor,user,ctxt.user_id,"try:
            image = image_repo.get(image_id)
            if image.status != 'queued':
                msg = _(""It's not allowed to add locations if image status is ""
                        ""%s."") % image.status
                raise webob.exc.HTTPConflict(explanation=msg)

            api_pol = api_policy.ImageAPIPolicy(req.context, image,
                                                self.policy)
            api_pol.add_location()

            roles = list(set(req.context.roles + req.context.service_roles))
            if 'service' not in roles:
                # NOTE(pdeore): Add location API is disabled for other stores
                # than http
                if not utils.is_http_store_configured(url):
                    msg = _(""http store must be enabled to use location API""
                            "" by normal user."")
                    raise exception.Forbidden(msg)

            if validation_data is not None:
                self._validate_hashing_data(validation_data)

            if 'os_glance_import_task' in image.extra_properties:
                # NOTE(pdeore): This will raise exception.Conflict if the
                # lock is present and valid, or return if absent or invalid.
                stole_lock_from_task = self._enforce_import_lock(req, image)

            task_input = {'image_id': image_id,
                          'loc_url': url,
                          'validation_data': validation_data}

            executor_factory = self.gateway.get_task_executor_factory(
                ctxt)
            add_location_task = task_factory.new_task(
                task_type='location_import',
                owner=ctxt.owner,
                task_input=task_input,
                image_id=image_id,
                user_id=ctxt.user_id,
                request_id=ctxt.request_id)

            try:
                # NOTE(pdeore): Try to grab the lock for this task
                image_repo.set_property_atomic(image, 'os_glance_import_task',
                                               add_location_task.task_id)
            except exception.Duplicate:
                msg = (_(""New operation on image '%s' is not ""
                         ""permitted as prior operation is still ""
                         ""in progress"") % image_id)
                raise exception.Conflict(msg)

            # NOTE(pdeore): We now have the import lock on this image.
            # If we busted the lock above and have a reference to that
            # task, try to clean up the import status information left
            # over from that execution.
            if stole_lock_from_task:
                self._cleanup_stale_task_progress(image_repo, image,
                                                  stole_lock_from_task)

            task_repo.add(add_location_task)
            task_executor = executor_factory.new_task_executor(ctxt)
            pool = common.get_thread_pool(""tasks_pool"")
            pool.spawn(add_location_task.run, task_executor)
        except exception.Conflict as e:
            raise webob.exc.HTTPConflict(explanation=e.msg)
        except exception.NotFound as e:
            raise webob.exc.HTTPNotFound(explanation=e.msg)
        except exception.Forbidden as e:
            LOG.debug(""User not permitted to add location to image '%s'"",
                      image_id)
            raise webob.exc.HTTPForbidden(explanation=e.msg)
        except exception.NotAuthenticated as e:
            raise webob.exc.HTTPUnauthorized(explanation=e.msg)
        except ValueError as e:
            raise webob.exc.HTTPBadRequest(
                explanation=encodeutils.exception_to_unicode(e))"
174,apps/glance/glance/api/v2/images.py,task_executor,executor_factory.new_task_executor,user,ctxt.user_id,"try:
            image = image_repo.get(image_id)
            if image.status != 'queued':
                msg = _(""It's not allowed to add locations if image status is ""
                        ""%s."") % image.status
                raise webob.exc.HTTPConflict(explanation=msg)

            api_pol = api_policy.ImageAPIPolicy(req.context, image,
                                                self.policy)
            api_pol.add_location()

            roles = list(set(req.context.roles + req.context.service_roles))
            if 'service' not in roles:
                # NOTE(pdeore): Add location API is disabled for other stores
                # than http
                if not utils.is_http_store_configured(url):
                    msg = _(""http store must be enabled to use location API""
                            "" by normal user."")
                    raise exception.Forbidden(msg)

            if validation_data is not None:
                self._validate_hashing_data(validation_data)

            if 'os_glance_import_task' in image.extra_properties:
                # NOTE(pdeore): This will raise exception.Conflict if the
                # lock is present and valid, or return if absent or invalid.
                stole_lock_from_task = self._enforce_import_lock(req, image)

            task_input = {'image_id': image_id,
                          'loc_url': url,
                          'validation_data': validation_data}

            executor_factory = self.gateway.get_task_executor_factory(
                ctxt)
            add_location_task = task_factory.new_task(
                task_type='location_import',
                owner=ctxt.owner,
                task_input=task_input,
                image_id=image_id,
                user_id=ctxt.user_id,
                request_id=ctxt.request_id)

            try:
                # NOTE(pdeore): Try to grab the lock for this task
                image_repo.set_property_atomic(image, 'os_glance_import_task',
                                               add_location_task.task_id)
            except exception.Duplicate:
                msg = (_(""New operation on image '%s' is not ""
                         ""permitted as prior operation is still ""
                         ""in progress"") % image_id)
                raise exception.Conflict(msg)

            # NOTE(pdeore): We now have the import lock on this image.
            # If we busted the lock above and have a reference to that
            # task, try to clean up the import status information left
            # over from that execution.
            if stole_lock_from_task:
                self._cleanup_stale_task_progress(image_repo, image,
                                                  stole_lock_from_task)

            task_repo.add(add_location_task)
            task_executor = executor_factory.new_task_executor(ctxt)
            pool = common.get_thread_pool(""tasks_pool"")
            pool.spawn(add_location_task.run, task_executor)
        except exception.Conflict as e:
            raise webob.exc.HTTPConflict(explanation=e.msg)
        except exception.NotFound as e:
            raise webob.exc.HTTPNotFound(explanation=e.msg)
        except exception.Forbidden as e:
            LOG.debug(""User not permitted to add location to image '%s'"",
                      image_id)
            raise webob.exc.HTTPForbidden(explanation=e.msg)
        except exception.NotAuthenticated as e:
            raise webob.exc.HTTPUnauthorized(explanation=e.msg)
        except ValueError as e:
            raise webob.exc.HTTPBadRequest(
                explanation=encodeutils.exception_to_unicode(e))"
175,apps/glance/glance/api/v2/images.py,debug,LOG.debug,task_executor,add_location.self.gateway.get_task_executor_factory,"try:
            image = image_repo.get(image_id)
            if image.status != 'queued':
                msg = _(""It's not allowed to add locations if image status is ""
                        ""%s."") % image.status
                raise webob.exc.HTTPConflict(explanation=msg)

            api_pol = api_policy.ImageAPIPolicy(req.context, image,
                                                self.policy)
            api_pol.add_location()

            roles = list(set(req.context.roles + req.context.service_roles))
            if 'service' not in roles:
                # NOTE(pdeore): Add location API is disabled for other stores
                # than http
                if not utils.is_http_store_configured(url):
                    msg = _(""http store must be enabled to use location API""
                            "" by normal user."")
                    raise exception.Forbidden(msg)

            if validation_data is not None:
                self._validate_hashing_data(validation_data)

            if 'os_glance_import_task' in image.extra_properties:
                # NOTE(pdeore): This will raise exception.Conflict if the
                # lock is present and valid, or return if absent or invalid.
                stole_lock_from_task = self._enforce_import_lock(req, image)

            task_input = {'image_id': image_id,
                          'loc_url': url,
                          'validation_data': validation_data}

            executor_factory = self.gateway.get_task_executor_factory(
                ctxt)
            add_location_task = task_factory.new_task(
                task_type='location_import',
                owner=ctxt.owner,
                task_input=task_input,
                image_id=image_id,
                user_id=ctxt.user_id,
                request_id=ctxt.request_id)

            try:
                # NOTE(pdeore): Try to grab the lock for this task
                image_repo.set_property_atomic(image, 'os_glance_import_task',
                                               add_location_task.task_id)
            except exception.Duplicate:
                msg = (_(""New operation on image '%s' is not ""
                         ""permitted as prior operation is still ""
                         ""in progress"") % image_id)
                raise exception.Conflict(msg)

            # NOTE(pdeore): We now have the import lock on this image.
            # If we busted the lock above and have a reference to that
            # task, try to clean up the import status information left
            # over from that execution.
            if stole_lock_from_task:
                self._cleanup_stale_task_progress(image_repo, image,
                                                  stole_lock_from_task)

            task_repo.add(add_location_task)
            task_executor = executor_factory.new_task_executor(ctxt)
            pool = common.get_thread_pool(""tasks_pool"")
            pool.spawn(add_location_task.run, task_executor)
        except exception.Conflict as e:
            raise webob.exc.HTTPConflict(explanation=e.msg)
        except exception.NotFound as e:
            raise webob.exc.HTTPNotFound(explanation=e.msg)
        except exception.Forbidden as e:
            LOG.debug(""User not permitted to add location to image '%s'"",
                      image_id)
            raise webob.exc.HTTPForbidden(explanation=e.msg)
        except exception.NotAuthenticated as e:
            raise webob.exc.HTTPUnauthorized(explanation=e.msg)
        except ValueError as e:
            raise webob.exc.HTTPBadRequest(
                explanation=encodeutils.exception_to_unicode(e))"
176,apps/glance/glance/api/v2/images.py,debug,LOG.debug,task_executor,self.gateway.get_task_executor_factory,"try:
            image = image_repo.get(image_id)
            if image.status != 'queued':
                msg = _(""It's not allowed to add locations if image status is ""
                        ""%s."") % image.status
                raise webob.exc.HTTPConflict(explanation=msg)

            api_pol = api_policy.ImageAPIPolicy(req.context, image,
                                                self.policy)
            api_pol.add_location()

            roles = list(set(req.context.roles + req.context.service_roles))
            if 'service' not in roles:
                # NOTE(pdeore): Add location API is disabled for other stores
                # than http
                if not utils.is_http_store_configured(url):
                    msg = _(""http store must be enabled to use location API""
                            "" by normal user."")
                    raise exception.Forbidden(msg)

            if validation_data is not None:
                self._validate_hashing_data(validation_data)

            if 'os_glance_import_task' in image.extra_properties:
                # NOTE(pdeore): This will raise exception.Conflict if the
                # lock is present and valid, or return if absent or invalid.
                stole_lock_from_task = self._enforce_import_lock(req, image)

            task_input = {'image_id': image_id,
                          'loc_url': url,
                          'validation_data': validation_data}

            executor_factory = self.gateway.get_task_executor_factory(
                ctxt)
            add_location_task = task_factory.new_task(
                task_type='location_import',
                owner=ctxt.owner,
                task_input=task_input,
                image_id=image_id,
                user_id=ctxt.user_id,
                request_id=ctxt.request_id)

            try:
                # NOTE(pdeore): Try to grab the lock for this task
                image_repo.set_property_atomic(image, 'os_glance_import_task',
                                               add_location_task.task_id)
            except exception.Duplicate:
                msg = (_(""New operation on image '%s' is not ""
                         ""permitted as prior operation is still ""
                         ""in progress"") % image_id)
                raise exception.Conflict(msg)

            # NOTE(pdeore): We now have the import lock on this image.
            # If we busted the lock above and have a reference to that
            # task, try to clean up the import status information left
            # over from that execution.
            if stole_lock_from_task:
                self._cleanup_stale_task_progress(image_repo, image,
                                                  stole_lock_from_task)

            task_repo.add(add_location_task)
            task_executor = executor_factory.new_task_executor(ctxt)
            pool = common.get_thread_pool(""tasks_pool"")
            pool.spawn(add_location_task.run, task_executor)
        except exception.Conflict as e:
            raise webob.exc.HTTPConflict(explanation=e.msg)
        except exception.NotFound as e:
            raise webob.exc.HTTPNotFound(explanation=e.msg)
        except exception.Forbidden as e:
            LOG.debug(""User not permitted to add location to image '%s'"",
                      image_id)
            raise webob.exc.HTTPForbidden(explanation=e.msg)
        except exception.NotAuthenticated as e:
            raise webob.exc.HTTPUnauthorized(explanation=e.msg)
        except ValueError as e:
            raise webob.exc.HTTPBadRequest(
                explanation=encodeutils.exception_to_unicode(e))"
177,apps/glance/glance/api/v2/images.py,debug,LOG.debug,user,add_location.ctxt.user_id,"try:
            image = image_repo.get(image_id)
            if image.status != 'queued':
                msg = _(""It's not allowed to add locations if image status is ""
                        ""%s."") % image.status
                raise webob.exc.HTTPConflict(explanation=msg)

            api_pol = api_policy.ImageAPIPolicy(req.context, image,
                                                self.policy)
            api_pol.add_location()

            roles = list(set(req.context.roles + req.context.service_roles))
            if 'service' not in roles:
                # NOTE(pdeore): Add location API is disabled for other stores
                # than http
                if not utils.is_http_store_configured(url):
                    msg = _(""http store must be enabled to use location API""
                            "" by normal user."")
                    raise exception.Forbidden(msg)

            if validation_data is not None:
                self._validate_hashing_data(validation_data)

            if 'os_glance_import_task' in image.extra_properties:
                # NOTE(pdeore): This will raise exception.Conflict if the
                # lock is present and valid, or return if absent or invalid.
                stole_lock_from_task = self._enforce_import_lock(req, image)

            task_input = {'image_id': image_id,
                          'loc_url': url,
                          'validation_data': validation_data}

            executor_factory = self.gateway.get_task_executor_factory(
                ctxt)
            add_location_task = task_factory.new_task(
                task_type='location_import',
                owner=ctxt.owner,
                task_input=task_input,
                image_id=image_id,
                user_id=ctxt.user_id,
                request_id=ctxt.request_id)

            try:
                # NOTE(pdeore): Try to grab the lock for this task
                image_repo.set_property_atomic(image, 'os_glance_import_task',
                                               add_location_task.task_id)
            except exception.Duplicate:
                msg = (_(""New operation on image '%s' is not ""
                         ""permitted as prior operation is still ""
                         ""in progress"") % image_id)
                raise exception.Conflict(msg)

            # NOTE(pdeore): We now have the import lock on this image.
            # If we busted the lock above and have a reference to that
            # task, try to clean up the import status information left
            # over from that execution.
            if stole_lock_from_task:
                self._cleanup_stale_task_progress(image_repo, image,
                                                  stole_lock_from_task)

            task_repo.add(add_location_task)
            task_executor = executor_factory.new_task_executor(ctxt)
            pool = common.get_thread_pool(""tasks_pool"")
            pool.spawn(add_location_task.run, task_executor)
        except exception.Conflict as e:
            raise webob.exc.HTTPConflict(explanation=e.msg)
        except exception.NotFound as e:
            raise webob.exc.HTTPNotFound(explanation=e.msg)
        except exception.Forbidden as e:
            LOG.debug(""User not permitted to add location to image '%s'"",
                      image_id)
            raise webob.exc.HTTPForbidden(explanation=e.msg)
        except exception.NotAuthenticated as e:
            raise webob.exc.HTTPUnauthorized(explanation=e.msg)
        except ValueError as e:
            raise webob.exc.HTTPBadRequest(
                explanation=encodeutils.exception_to_unicode(e))"
178,apps/glance/glance/api/v2/images.py,debug,LOG.debug,user,ctxt.user_id,"try:
            image = image_repo.get(image_id)
            if image.status != 'queued':
                msg = _(""It's not allowed to add locations if image status is ""
                        ""%s."") % image.status
                raise webob.exc.HTTPConflict(explanation=msg)

            api_pol = api_policy.ImageAPIPolicy(req.context, image,
                                                self.policy)
            api_pol.add_location()

            roles = list(set(req.context.roles + req.context.service_roles))
            if 'service' not in roles:
                # NOTE(pdeore): Add location API is disabled for other stores
                # than http
                if not utils.is_http_store_configured(url):
                    msg = _(""http store must be enabled to use location API""
                            "" by normal user."")
                    raise exception.Forbidden(msg)

            if validation_data is not None:
                self._validate_hashing_data(validation_data)

            if 'os_glance_import_task' in image.extra_properties:
                # NOTE(pdeore): This will raise exception.Conflict if the
                # lock is present and valid, or return if absent or invalid.
                stole_lock_from_task = self._enforce_import_lock(req, image)

            task_input = {'image_id': image_id,
                          'loc_url': url,
                          'validation_data': validation_data}

            executor_factory = self.gateway.get_task_executor_factory(
                ctxt)
            add_location_task = task_factory.new_task(
                task_type='location_import',
                owner=ctxt.owner,
                task_input=task_input,
                image_id=image_id,
                user_id=ctxt.user_id,
                request_id=ctxt.request_id)

            try:
                # NOTE(pdeore): Try to grab the lock for this task
                image_repo.set_property_atomic(image, 'os_glance_import_task',
                                               add_location_task.task_id)
            except exception.Duplicate:
                msg = (_(""New operation on image '%s' is not ""
                         ""permitted as prior operation is still ""
                         ""in progress"") % image_id)
                raise exception.Conflict(msg)

            # NOTE(pdeore): We now have the import lock on this image.
            # If we busted the lock above and have a reference to that
            # task, try to clean up the import status information left
            # over from that execution.
            if stole_lock_from_task:
                self._cleanup_stale_task_progress(image_repo, image,
                                                  stole_lock_from_task)

            task_repo.add(add_location_task)
            task_executor = executor_factory.new_task_executor(ctxt)
            pool = common.get_thread_pool(""tasks_pool"")
            pool.spawn(add_location_task.run, task_executor)
        except exception.Conflict as e:
            raise webob.exc.HTTPConflict(explanation=e.msg)
        except exception.NotFound as e:
            raise webob.exc.HTTPNotFound(explanation=e.msg)
        except exception.Forbidden as e:
            LOG.debug(""User not permitted to add location to image '%s'"",
                      image_id)
            raise webob.exc.HTTPForbidden(explanation=e.msg)
        except exception.NotAuthenticated as e:
            raise webob.exc.HTTPUnauthorized(explanation=e.msg)
        except ValueError as e:
            raise webob.exc.HTTPBadRequest(
                explanation=encodeutils.exception_to_unicode(e))"
179,apps/glance/glance/api/v2/images.py,debug,LOG.debug,task_executor,add_location.executor_factory,"try:
            image = image_repo.get(image_id)
            if image.status != 'queued':
                msg = _(""It's not allowed to add locations if image status is ""
                        ""%s."") % image.status
                raise webob.exc.HTTPConflict(explanation=msg)

            api_pol = api_policy.ImageAPIPolicy(req.context, image,
                                                self.policy)
            api_pol.add_location()

            roles = list(set(req.context.roles + req.context.service_roles))
            if 'service' not in roles:
                # NOTE(pdeore): Add location API is disabled for other stores
                # than http
                if not utils.is_http_store_configured(url):
                    msg = _(""http store must be enabled to use location API""
                            "" by normal user."")
                    raise exception.Forbidden(msg)

            if validation_data is not None:
                self._validate_hashing_data(validation_data)

            if 'os_glance_import_task' in image.extra_properties:
                # NOTE(pdeore): This will raise exception.Conflict if the
                # lock is present and valid, or return if absent or invalid.
                stole_lock_from_task = self._enforce_import_lock(req, image)

            task_input = {'image_id': image_id,
                          'loc_url': url,
                          'validation_data': validation_data}

            executor_factory = self.gateway.get_task_executor_factory(
                ctxt)
            add_location_task = task_factory.new_task(
                task_type='location_import',
                owner=ctxt.owner,
                task_input=task_input,
                image_id=image_id,
                user_id=ctxt.user_id,
                request_id=ctxt.request_id)

            try:
                # NOTE(pdeore): Try to grab the lock for this task
                image_repo.set_property_atomic(image, 'os_glance_import_task',
                                               add_location_task.task_id)
            except exception.Duplicate:
                msg = (_(""New operation on image '%s' is not ""
                         ""permitted as prior operation is still ""
                         ""in progress"") % image_id)
                raise exception.Conflict(msg)

            # NOTE(pdeore): We now have the import lock on this image.
            # If we busted the lock above and have a reference to that
            # task, try to clean up the import status information left
            # over from that execution.
            if stole_lock_from_task:
                self._cleanup_stale_task_progress(image_repo, image,
                                                  stole_lock_from_task)

            task_repo.add(add_location_task)
            task_executor = executor_factory.new_task_executor(ctxt)
            pool = common.get_thread_pool(""tasks_pool"")
            pool.spawn(add_location_task.run, task_executor)
        except exception.Conflict as e:
            raise webob.exc.HTTPConflict(explanation=e.msg)
        except exception.NotFound as e:
            raise webob.exc.HTTPNotFound(explanation=e.msg)
        except exception.Forbidden as e:
            LOG.debug(""User not permitted to add location to image '%s'"",
                      image_id)
            raise webob.exc.HTTPForbidden(explanation=e.msg)
        except exception.NotAuthenticated as e:
            raise webob.exc.HTTPUnauthorized(explanation=e.msg)
        except ValueError as e:
            raise webob.exc.HTTPBadRequest(
                explanation=encodeutils.exception_to_unicode(e))"
180,apps/glance/glance/api/v2/images.py,debug,LOG.debug,task_executor,add_location.executor_factory.new_task_executor,"try:
            image = image_repo.get(image_id)
            if image.status != 'queued':
                msg = _(""It's not allowed to add locations if image status is ""
                        ""%s."") % image.status
                raise webob.exc.HTTPConflict(explanation=msg)

            api_pol = api_policy.ImageAPIPolicy(req.context, image,
                                                self.policy)
            api_pol.add_location()

            roles = list(set(req.context.roles + req.context.service_roles))
            if 'service' not in roles:
                # NOTE(pdeore): Add location API is disabled for other stores
                # than http
                if not utils.is_http_store_configured(url):
                    msg = _(""http store must be enabled to use location API""
                            "" by normal user."")
                    raise exception.Forbidden(msg)

            if validation_data is not None:
                self._validate_hashing_data(validation_data)

            if 'os_glance_import_task' in image.extra_properties:
                # NOTE(pdeore): This will raise exception.Conflict if the
                # lock is present and valid, or return if absent or invalid.
                stole_lock_from_task = self._enforce_import_lock(req, image)

            task_input = {'image_id': image_id,
                          'loc_url': url,
                          'validation_data': validation_data}

            executor_factory = self.gateway.get_task_executor_factory(
                ctxt)
            add_location_task = task_factory.new_task(
                task_type='location_import',
                owner=ctxt.owner,
                task_input=task_input,
                image_id=image_id,
                user_id=ctxt.user_id,
                request_id=ctxt.request_id)

            try:
                # NOTE(pdeore): Try to grab the lock for this task
                image_repo.set_property_atomic(image, 'os_glance_import_task',
                                               add_location_task.task_id)
            except exception.Duplicate:
                msg = (_(""New operation on image '%s' is not ""
                         ""permitted as prior operation is still ""
                         ""in progress"") % image_id)
                raise exception.Conflict(msg)

            # NOTE(pdeore): We now have the import lock on this image.
            # If we busted the lock above and have a reference to that
            # task, try to clean up the import status information left
            # over from that execution.
            if stole_lock_from_task:
                self._cleanup_stale_task_progress(image_repo, image,
                                                  stole_lock_from_task)

            task_repo.add(add_location_task)
            task_executor = executor_factory.new_task_executor(ctxt)
            pool = common.get_thread_pool(""tasks_pool"")
            pool.spawn(add_location_task.run, task_executor)
        except exception.Conflict as e:
            raise webob.exc.HTTPConflict(explanation=e.msg)
        except exception.NotFound as e:
            raise webob.exc.HTTPNotFound(explanation=e.msg)
        except exception.Forbidden as e:
            LOG.debug(""User not permitted to add location to image '%s'"",
                      image_id)
            raise webob.exc.HTTPForbidden(explanation=e.msg)
        except exception.NotAuthenticated as e:
            raise webob.exc.HTTPUnauthorized(explanation=e.msg)
        except ValueError as e:
            raise webob.exc.HTTPBadRequest(
                explanation=encodeutils.exception_to_unicode(e))"
181,apps/glance/glance/api/v2/images.py,debug,LOG.debug,task_executor,executor_factory.new_task_executor,"try:
            image = image_repo.get(image_id)
            if image.status != 'queued':
                msg = _(""It's not allowed to add locations if image status is ""
                        ""%s."") % image.status
                raise webob.exc.HTTPConflict(explanation=msg)

            api_pol = api_policy.ImageAPIPolicy(req.context, image,
                                                self.policy)
            api_pol.add_location()

            roles = list(set(req.context.roles + req.context.service_roles))
            if 'service' not in roles:
                # NOTE(pdeore): Add location API is disabled for other stores
                # than http
                if not utils.is_http_store_configured(url):
                    msg = _(""http store must be enabled to use location API""
                            "" by normal user."")
                    raise exception.Forbidden(msg)

            if validation_data is not None:
                self._validate_hashing_data(validation_data)

            if 'os_glance_import_task' in image.extra_properties:
                # NOTE(pdeore): This will raise exception.Conflict if the
                # lock is present and valid, or return if absent or invalid.
                stole_lock_from_task = self._enforce_import_lock(req, image)

            task_input = {'image_id': image_id,
                          'loc_url': url,
                          'validation_data': validation_data}

            executor_factory = self.gateway.get_task_executor_factory(
                ctxt)
            add_location_task = task_factory.new_task(
                task_type='location_import',
                owner=ctxt.owner,
                task_input=task_input,
                image_id=image_id,
                user_id=ctxt.user_id,
                request_id=ctxt.request_id)

            try:
                # NOTE(pdeore): Try to grab the lock for this task
                image_repo.set_property_atomic(image, 'os_glance_import_task',
                                               add_location_task.task_id)
            except exception.Duplicate:
                msg = (_(""New operation on image '%s' is not ""
                         ""permitted as prior operation is still ""
                         ""in progress"") % image_id)
                raise exception.Conflict(msg)

            # NOTE(pdeore): We now have the import lock on this image.
            # If we busted the lock above and have a reference to that
            # task, try to clean up the import status information left
            # over from that execution.
            if stole_lock_from_task:
                self._cleanup_stale_task_progress(image_repo, image,
                                                  stole_lock_from_task)

            task_repo.add(add_location_task)
            task_executor = executor_factory.new_task_executor(ctxt)
            pool = common.get_thread_pool(""tasks_pool"")
            pool.spawn(add_location_task.run, task_executor)
        except exception.Conflict as e:
            raise webob.exc.HTTPConflict(explanation=e.msg)
        except exception.NotFound as e:
            raise webob.exc.HTTPNotFound(explanation=e.msg)
        except exception.Forbidden as e:
            LOG.debug(""User not permitted to add location to image '%s'"",
                      image_id)
            raise webob.exc.HTTPForbidden(explanation=e.msg)
        except exception.NotAuthenticated as e:
            raise webob.exc.HTTPUnauthorized(explanation=e.msg)
        except ValueError as e:
            raise webob.exc.HTTPBadRequest(
                explanation=encodeutils.exception_to_unicode(e))"
182,apps/glance/glance/api/v2/images.py,debug,LOG.debug,enabled,CONF.enabled_backends,"try:
            image_view = {k: v for k, v in dict(image.extra_properties).items()
                          if k not in self._hidden_properties}
            attributes = ['name', 'disk_format', 'container_format',
                          'visibility', 'size', 'virtual_size', 'status',
                          'checksum', 'protected', 'min_ram', 'min_disk',
                          'owner', 'os_hidden', 'os_hash_algo',
                          'os_hash_value']
            for key in attributes:
                image_view[key] = getattr(image, key)
            image_view['id'] = image.image_id
            image_view['created_at'] = timeutils.isotime(image.created_at)
            image_view['updated_at'] = timeutils.isotime(image.updated_at)

            if CONF.show_multiple_locations:
                locations = _get_image_locations(image)
                if locations:
                    image_view['locations'] = []
                    for loc in locations:
                        tmp = dict(loc)
                        tmp.pop('id', None)
                        tmp.pop('status', None)
                        image_view['locations'].append(tmp)
                else:
                    # NOTE (flwang): We will still show ""locations"": [] if
                    # image.locations is None to indicate it's allowed to show
                    # locations but it's just non-existent.
                    image_view['locations'] = []
                    LOG.debug(""The 'locations' list of image %s is empty"",
                              image.image_id)

            if CONF.show_image_direct_url:
                locations = _get_image_locations(image)
                if locations:
                    # Choose best location configured strategy
                    loc = utils.sort_image_locations(locations)[0]
                    image_view['direct_url'] = loc['url']
                else:
                    LOG.debug(""The 'locations' list of image %s is empty, ""
                              ""not including 'direct_url' in response"",
                              image.image_id)

            image_view['tags'] = list(image.tags)
            image_view['self'] = self._get_image_href(image)
            image_view['file'] = self._get_image_href(image, 'file')
            image_view['schema'] = '/v2/schemas/image'
            image_view = self.schema.filter(image_view)  # domain

            # add store information to image
            if CONF.enabled_backends:
                locations = _get_image_locations(image)
                if locations:
                    stores = []
                    for loc in locations:
                        backend = loc['metadata'].get('store')
                        if backend:
                            stores.append(backend)

                    if stores:
                        image_view['stores'] = "","".join(stores)

            return image_view
        except exception.Forbidden as e:
            raise webob.exc.HTTPForbidden(explanation=e.msg)"
183,apps/glance/glance/api/v2/images.py,debug,LOG.debug,enabled_backends,CONF.enabled_backends,"try:
            image_view = {k: v for k, v in dict(image.extra_properties).items()
                          if k not in self._hidden_properties}
            attributes = ['name', 'disk_format', 'container_format',
                          'visibility', 'size', 'virtual_size', 'status',
                          'checksum', 'protected', 'min_ram', 'min_disk',
                          'owner', 'os_hidden', 'os_hash_algo',
                          'os_hash_value']
            for key in attributes:
                image_view[key] = getattr(image, key)
            image_view['id'] = image.image_id
            image_view['created_at'] = timeutils.isotime(image.created_at)
            image_view['updated_at'] = timeutils.isotime(image.updated_at)

            if CONF.show_multiple_locations:
                locations = _get_image_locations(image)
                if locations:
                    image_view['locations'] = []
                    for loc in locations:
                        tmp = dict(loc)
                        tmp.pop('id', None)
                        tmp.pop('status', None)
                        image_view['locations'].append(tmp)
                else:
                    # NOTE (flwang): We will still show ""locations"": [] if
                    # image.locations is None to indicate it's allowed to show
                    # locations but it's just non-existent.
                    image_view['locations'] = []
                    LOG.debug(""The 'locations' list of image %s is empty"",
                              image.image_id)

            if CONF.show_image_direct_url:
                locations = _get_image_locations(image)
                if locations:
                    # Choose best location configured strategy
                    loc = utils.sort_image_locations(locations)[0]
                    image_view['direct_url'] = loc['url']
                else:
                    LOG.debug(""The 'locations' list of image %s is empty, ""
                              ""not including 'direct_url' in response"",
                              image.image_id)

            image_view['tags'] = list(image.tags)
            image_view['self'] = self._get_image_href(image)
            image_view['file'] = self._get_image_href(image, 'file')
            image_view['schema'] = '/v2/schemas/image'
            image_view = self.schema.filter(image_view)  # domain

            # add store information to image
            if CONF.enabled_backends:
                locations = _get_image_locations(image)
                if locations:
                    stores = []
                    for loc in locations:
                        backend = loc['metadata'].get('store')
                        if backend:
                            stores.append(backend)

                    if stores:
                        image_view['stores'] = "","".join(stores)

            return image_view
        except exception.Forbidden as e:
            raise webob.exc.HTTPForbidden(explanation=e.msg)"
184,apps/glance/glance/api/v2/images.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"try:
            image_view = {k: v for k, v in dict(image.extra_properties).items()
                          if k not in self._hidden_properties}
            attributes = ['name', 'disk_format', 'container_format',
                          'visibility', 'size', 'virtual_size', 'status',
                          'checksum', 'protected', 'min_ram', 'min_disk',
                          'owner', 'os_hidden', 'os_hash_algo',
                          'os_hash_value']
            for key in attributes:
                image_view[key] = getattr(image, key)
            image_view['id'] = image.image_id
            image_view['created_at'] = timeutils.isotime(image.created_at)
            image_view['updated_at'] = timeutils.isotime(image.updated_at)

            if CONF.show_multiple_locations:
                locations = _get_image_locations(image)
                if locations:
                    image_view['locations'] = []
                    for loc in locations:
                        tmp = dict(loc)
                        tmp.pop('id', None)
                        tmp.pop('status', None)
                        image_view['locations'].append(tmp)
                else:
                    # NOTE (flwang): We will still show ""locations"": [] if
                    # image.locations is None to indicate it's allowed to show
                    # locations but it's just non-existent.
                    image_view['locations'] = []
                    LOG.debug(""The 'locations' list of image %s is empty"",
                              image.image_id)

            if CONF.show_image_direct_url:
                locations = _get_image_locations(image)
                if locations:
                    # Choose best location configured strategy
                    loc = utils.sort_image_locations(locations)[0]
                    image_view['direct_url'] = loc['url']
                else:
                    LOG.debug(""The 'locations' list of image %s is empty, ""
                              ""not including 'direct_url' in response"",
                              image.image_id)

            image_view['tags'] = list(image.tags)
            image_view['self'] = self._get_image_href(image)
            image_view['file'] = self._get_image_href(image, 'file')
            image_view['schema'] = '/v2/schemas/image'
            image_view = self.schema.filter(image_view)  # domain

            # add store information to image
            if CONF.enabled_backends:
                locations = _get_image_locations(image)
                if locations:
                    stores = []
                    for loc in locations:
                        backend = loc['metadata'].get('store')
                        if backend:
                            stores.append(backend)

                    if stores:
                        image_view['stores'] = "","".join(stores)

            return image_view
        except exception.Forbidden as e:
            raise webob.exc.HTTPForbidden(explanation=e.msg)"
185,apps/glance/glance/api/v2/metadef_namespaces.py,debug,LOG.debug,key,index.sort_key,"try:
            ns_repo = self.gateway.get_metadef_namespace_repo(req.context)

            policy_check = api_policy.MetadefAPIPolicy(
                req.context,
                enforcer=self.policy)
            # NOTE(abhishekk): This is just a ""do you have permission to
            # list namespace"" check. Each namespace is checked against
            # get_metadef_namespace below.
            policy_check.get_metadef_namespaces()

            # NOTE(abhishekk): We also need to fetch resource_types associated
            # with namespaces, so better to check we have permission for the
            # same in advance.
            policy_check.list_metadef_resource_types()

            # Get namespace id
            if marker:
                namespace_obj = ns_repo.get(marker)
                marker = namespace_obj.namespace_id

            database_ns_list = ns_repo.list(
                marker=marker, limit=limit, sort_key=sort_key,
                sort_dir=sort_dir, filters=filters)

            ns_list = [
                ns for ns in database_ns_list if api_policy.MetadefAPIPolicy(
                    req.context, md_resource=ns, enforcer=self.policy).check(
                    'get_metadef_namespace')]

            rs_repo = (
                self.gateway.get_metadef_resource_type_repo(req.context))
            for db_namespace in ns_list:
                # Get resource type associations
                filters = dict()
                filters['namespace'] = db_namespace.namespace
                try:
                    repo_rs_type_list = rs_repo.list(filters=filters)
                except exception.NotFound:
                    # NOTE(danms): If we fail to list resource_types
                    # for this namespace, do not fail the entire
                    # namespace list operation with NotFound.
                    repo_rs_type_list = []
                resource_type_list = [
                    ResourceTypeAssociation.to_wsme_model(
                        resource_type
                    ) for resource_type in repo_rs_type_list]

                if resource_type_list:
                    db_namespace.resource_type_associations = (
                        resource_type_list)

            namespace_list = [Namespace.to_wsme_model(
                db_namespace,
                get_namespace_href(db_namespace),
                self.ns_schema_link) for db_namespace in ns_list]
            namespaces = Namespaces()
            namespaces.namespaces = namespace_list
            if len(namespace_list) != 0 and len(namespace_list) == limit:
                namespaces.next = ns_list[-1].namespace

        except exception.Forbidden as e:
            LOG.debug(""User not permitted to retrieve metadata namespaces ""
                      ""index"")
            raise webob.exc.HTTPForbidden(explanation=e.msg)
        except exception.NotFound as e:
            raise webob.exc.HTTPNotFound(explanation=e.msg)"
186,apps/glance/glance/api/v2/metadef_namespaces.py,debug,LOG.debug,key,index.database_ns_list,"try:
            ns_repo = self.gateway.get_metadef_namespace_repo(req.context)

            policy_check = api_policy.MetadefAPIPolicy(
                req.context,
                enforcer=self.policy)
            # NOTE(abhishekk): This is just a ""do you have permission to
            # list namespace"" check. Each namespace is checked against
            # get_metadef_namespace below.
            policy_check.get_metadef_namespaces()

            # NOTE(abhishekk): We also need to fetch resource_types associated
            # with namespaces, so better to check we have permission for the
            # same in advance.
            policy_check.list_metadef_resource_types()

            # Get namespace id
            if marker:
                namespace_obj = ns_repo.get(marker)
                marker = namespace_obj.namespace_id

            database_ns_list = ns_repo.list(
                marker=marker, limit=limit, sort_key=sort_key,
                sort_dir=sort_dir, filters=filters)

            ns_list = [
                ns for ns in database_ns_list if api_policy.MetadefAPIPolicy(
                    req.context, md_resource=ns, enforcer=self.policy).check(
                    'get_metadef_namespace')]

            rs_repo = (
                self.gateway.get_metadef_resource_type_repo(req.context))
            for db_namespace in ns_list:
                # Get resource type associations
                filters = dict()
                filters['namespace'] = db_namespace.namespace
                try:
                    repo_rs_type_list = rs_repo.list(filters=filters)
                except exception.NotFound:
                    # NOTE(danms): If we fail to list resource_types
                    # for this namespace, do not fail the entire
                    # namespace list operation with NotFound.
                    repo_rs_type_list = []
                resource_type_list = [
                    ResourceTypeAssociation.to_wsme_model(
                        resource_type
                    ) for resource_type in repo_rs_type_list]

                if resource_type_list:
                    db_namespace.resource_type_associations = (
                        resource_type_list)

            namespace_list = [Namespace.to_wsme_model(
                db_namespace,
                get_namespace_href(db_namespace),
                self.ns_schema_link) for db_namespace in ns_list]
            namespaces = Namespaces()
            namespaces.namespaces = namespace_list
            if len(namespace_list) != 0 and len(namespace_list) == limit:
                namespaces.next = ns_list[-1].namespace

        except exception.Forbidden as e:
            LOG.debug(""User not permitted to retrieve metadata namespaces ""
                      ""index"")
            raise webob.exc.HTTPForbidden(explanation=e.msg)
        except exception.NotFound as e:
            raise webob.exc.HTTPNotFound(explanation=e.msg)"
187,apps/glance/glance/api/v2/metadef_namespaces.py,debug,LOG.debug,key,index.ns_list,"try:
            ns_repo = self.gateway.get_metadef_namespace_repo(req.context)

            policy_check = api_policy.MetadefAPIPolicy(
                req.context,
                enforcer=self.policy)
            # NOTE(abhishekk): This is just a ""do you have permission to
            # list namespace"" check. Each namespace is checked against
            # get_metadef_namespace below.
            policy_check.get_metadef_namespaces()

            # NOTE(abhishekk): We also need to fetch resource_types associated
            # with namespaces, so better to check we have permission for the
            # same in advance.
            policy_check.list_metadef_resource_types()

            # Get namespace id
            if marker:
                namespace_obj = ns_repo.get(marker)
                marker = namespace_obj.namespace_id

            database_ns_list = ns_repo.list(
                marker=marker, limit=limit, sort_key=sort_key,
                sort_dir=sort_dir, filters=filters)

            ns_list = [
                ns for ns in database_ns_list if api_policy.MetadefAPIPolicy(
                    req.context, md_resource=ns, enforcer=self.policy).check(
                    'get_metadef_namespace')]

            rs_repo = (
                self.gateway.get_metadef_resource_type_repo(req.context))
            for db_namespace in ns_list:
                # Get resource type associations
                filters = dict()
                filters['namespace'] = db_namespace.namespace
                try:
                    repo_rs_type_list = rs_repo.list(filters=filters)
                except exception.NotFound:
                    # NOTE(danms): If we fail to list resource_types
                    # for this namespace, do not fail the entire
                    # namespace list operation with NotFound.
                    repo_rs_type_list = []
                resource_type_list = [
                    ResourceTypeAssociation.to_wsme_model(
                        resource_type
                    ) for resource_type in repo_rs_type_list]

                if resource_type_list:
                    db_namespace.resource_type_associations = (
                        resource_type_list)

            namespace_list = [Namespace.to_wsme_model(
                db_namespace,
                get_namespace_href(db_namespace),
                self.ns_schema_link) for db_namespace in ns_list]
            namespaces = Namespaces()
            namespaces.namespaces = namespace_list
            if len(namespace_list) != 0 and len(namespace_list) == limit:
                namespaces.next = ns_list[-1].namespace

        except exception.Forbidden as e:
            LOG.debug(""User not permitted to retrieve metadata namespaces ""
                      ""index"")
            raise webob.exc.HTTPForbidden(explanation=e.msg)
        except exception.NotFound as e:
            raise webob.exc.HTTPNotFound(explanation=e.msg)"
188,apps/glance/glance/api/v2/metadef_namespaces.py,debug,LOG.debug,user,user_ns.namespace,"try:
            # NOTE(abhishekk): Here we are just checking if use is authorized
            # to modify the namespace or not
            api_policy.MetadefAPIPolicy(
                req.context,
                md_resource=ns_obj,
                enforcer=self.policy).modify_metadef_namespace()

            ns_obj._old_namespace = ns_obj.namespace
            ns_obj.namespace = wsme_utils._get_value(user_ns.namespace)
            ns_obj.display_name = wsme_utils._get_value(user_ns.display_name)
            ns_obj.description = wsme_utils._get_value(user_ns.description)
            # Following optional fields will default to same values as in
            # create namespace if not specified
            ns_obj.visibility = (
                wsme_utils._get_value(user_ns.visibility) or 'private')
            ns_obj.protected = (
                wsme_utils._get_value(user_ns.protected) or False)
            ns_obj.owner = (
                wsme_utils._get_value(user_ns.owner) or req.context.owner)
            updated_namespace = namespace_repo.save(ns_obj)
        except exception.Invalid as e:
            msg = (_(""Couldn't update metadata namespace: %s"")
                   % encodeutils.exception_to_unicode(e))
            raise webob.exc.HTTPBadRequest(explanation=msg)
        except exception.Forbidden as e:
            LOG.debug(""User not permitted to update metadata namespace ""
                      ""'%s'"", namespace)
            raise webob.exc.HTTPForbidden(explanation=e.msg)
        except exception.NotFound as e:
            raise webob.exc.HTTPNotFound(explanation=e.msg)
        except exception.Duplicate as e:
            raise webob.exc.HTTPConflict(explanation=e.msg)"
189,apps/glance/glance/api/v2/metadef_namespaces.py,debug,LOG.debug,user,user_ns.display_name,"try:
            # NOTE(abhishekk): Here we are just checking if use is authorized
            # to modify the namespace or not
            api_policy.MetadefAPIPolicy(
                req.context,
                md_resource=ns_obj,
                enforcer=self.policy).modify_metadef_namespace()

            ns_obj._old_namespace = ns_obj.namespace
            ns_obj.namespace = wsme_utils._get_value(user_ns.namespace)
            ns_obj.display_name = wsme_utils._get_value(user_ns.display_name)
            ns_obj.description = wsme_utils._get_value(user_ns.description)
            # Following optional fields will default to same values as in
            # create namespace if not specified
            ns_obj.visibility = (
                wsme_utils._get_value(user_ns.visibility) or 'private')
            ns_obj.protected = (
                wsme_utils._get_value(user_ns.protected) or False)
            ns_obj.owner = (
                wsme_utils._get_value(user_ns.owner) or req.context.owner)
            updated_namespace = namespace_repo.save(ns_obj)
        except exception.Invalid as e:
            msg = (_(""Couldn't update metadata namespace: %s"")
                   % encodeutils.exception_to_unicode(e))
            raise webob.exc.HTTPBadRequest(explanation=msg)
        except exception.Forbidden as e:
            LOG.debug(""User not permitted to update metadata namespace ""
                      ""'%s'"", namespace)
            raise webob.exc.HTTPForbidden(explanation=e.msg)
        except exception.NotFound as e:
            raise webob.exc.HTTPNotFound(explanation=e.msg)
        except exception.Duplicate as e:
            raise webob.exc.HTTPConflict(explanation=e.msg)"
190,apps/glance/glance/api/v2/metadef_namespaces.py,debug,LOG.debug,user,user_ns.description,"try:
            # NOTE(abhishekk): Here we are just checking if use is authorized
            # to modify the namespace or not
            api_policy.MetadefAPIPolicy(
                req.context,
                md_resource=ns_obj,
                enforcer=self.policy).modify_metadef_namespace()

            ns_obj._old_namespace = ns_obj.namespace
            ns_obj.namespace = wsme_utils._get_value(user_ns.namespace)
            ns_obj.display_name = wsme_utils._get_value(user_ns.display_name)
            ns_obj.description = wsme_utils._get_value(user_ns.description)
            # Following optional fields will default to same values as in
            # create namespace if not specified
            ns_obj.visibility = (
                wsme_utils._get_value(user_ns.visibility) or 'private')
            ns_obj.protected = (
                wsme_utils._get_value(user_ns.protected) or False)
            ns_obj.owner = (
                wsme_utils._get_value(user_ns.owner) or req.context.owner)
            updated_namespace = namespace_repo.save(ns_obj)
        except exception.Invalid as e:
            msg = (_(""Couldn't update metadata namespace: %s"")
                   % encodeutils.exception_to_unicode(e))
            raise webob.exc.HTTPBadRequest(explanation=msg)
        except exception.Forbidden as e:
            LOG.debug(""User not permitted to update metadata namespace ""
                      ""'%s'"", namespace)
            raise webob.exc.HTTPForbidden(explanation=e.msg)
        except exception.NotFound as e:
            raise webob.exc.HTTPNotFound(explanation=e.msg)
        except exception.Duplicate as e:
            raise webob.exc.HTTPConflict(explanation=e.msg)"
191,apps/glance/glance/api/v2/metadef_namespaces.py,debug,LOG.debug,user,user_ns.visibility,"try:
            # NOTE(abhishekk): Here we are just checking if use is authorized
            # to modify the namespace or not
            api_policy.MetadefAPIPolicy(
                req.context,
                md_resource=ns_obj,
                enforcer=self.policy).modify_metadef_namespace()

            ns_obj._old_namespace = ns_obj.namespace
            ns_obj.namespace = wsme_utils._get_value(user_ns.namespace)
            ns_obj.display_name = wsme_utils._get_value(user_ns.display_name)
            ns_obj.description = wsme_utils._get_value(user_ns.description)
            # Following optional fields will default to same values as in
            # create namespace if not specified
            ns_obj.visibility = (
                wsme_utils._get_value(user_ns.visibility) or 'private')
            ns_obj.protected = (
                wsme_utils._get_value(user_ns.protected) or False)
            ns_obj.owner = (
                wsme_utils._get_value(user_ns.owner) or req.context.owner)
            updated_namespace = namespace_repo.save(ns_obj)
        except exception.Invalid as e:
            msg = (_(""Couldn't update metadata namespace: %s"")
                   % encodeutils.exception_to_unicode(e))
            raise webob.exc.HTTPBadRequest(explanation=msg)
        except exception.Forbidden as e:
            LOG.debug(""User not permitted to update metadata namespace ""
                      ""'%s'"", namespace)
            raise webob.exc.HTTPForbidden(explanation=e.msg)
        except exception.NotFound as e:
            raise webob.exc.HTTPNotFound(explanation=e.msg)
        except exception.Duplicate as e:
            raise webob.exc.HTTPConflict(explanation=e.msg)"
192,apps/glance/glance/api/v2/metadef_namespaces.py,debug,LOG.debug,user,user_ns.protected,"try:
            # NOTE(abhishekk): Here we are just checking if use is authorized
            # to modify the namespace or not
            api_policy.MetadefAPIPolicy(
                req.context,
                md_resource=ns_obj,
                enforcer=self.policy).modify_metadef_namespace()

            ns_obj._old_namespace = ns_obj.namespace
            ns_obj.namespace = wsme_utils._get_value(user_ns.namespace)
            ns_obj.display_name = wsme_utils._get_value(user_ns.display_name)
            ns_obj.description = wsme_utils._get_value(user_ns.description)
            # Following optional fields will default to same values as in
            # create namespace if not specified
            ns_obj.visibility = (
                wsme_utils._get_value(user_ns.visibility) or 'private')
            ns_obj.protected = (
                wsme_utils._get_value(user_ns.protected) or False)
            ns_obj.owner = (
                wsme_utils._get_value(user_ns.owner) or req.context.owner)
            updated_namespace = namespace_repo.save(ns_obj)
        except exception.Invalid as e:
            msg = (_(""Couldn't update metadata namespace: %s"")
                   % encodeutils.exception_to_unicode(e))
            raise webob.exc.HTTPBadRequest(explanation=msg)
        except exception.Forbidden as e:
            LOG.debug(""User not permitted to update metadata namespace ""
                      ""'%s'"", namespace)
            raise webob.exc.HTTPForbidden(explanation=e.msg)
        except exception.NotFound as e:
            raise webob.exc.HTTPNotFound(explanation=e.msg)
        except exception.Duplicate as e:
            raise webob.exc.HTTPConflict(explanation=e.msg)"
193,apps/glance/glance/api/v2/metadef_namespaces.py,debug,LOG.debug,user,user_ns.owner,"try:
            # NOTE(abhishekk): Here we are just checking if use is authorized
            # to modify the namespace or not
            api_policy.MetadefAPIPolicy(
                req.context,
                md_resource=ns_obj,
                enforcer=self.policy).modify_metadef_namespace()

            ns_obj._old_namespace = ns_obj.namespace
            ns_obj.namespace = wsme_utils._get_value(user_ns.namespace)
            ns_obj.display_name = wsme_utils._get_value(user_ns.display_name)
            ns_obj.description = wsme_utils._get_value(user_ns.description)
            # Following optional fields will default to same values as in
            # create namespace if not specified
            ns_obj.visibility = (
                wsme_utils._get_value(user_ns.visibility) or 'private')
            ns_obj.protected = (
                wsme_utils._get_value(user_ns.protected) or False)
            ns_obj.owner = (
                wsme_utils._get_value(user_ns.owner) or req.context.owner)
            updated_namespace = namespace_repo.save(ns_obj)
        except exception.Invalid as e:
            msg = (_(""Couldn't update metadata namespace: %s"")
                   % encodeutils.exception_to_unicode(e))
            raise webob.exc.HTTPBadRequest(explanation=msg)
        except exception.Forbidden as e:
            LOG.debug(""User not permitted to update metadata namespace ""
                      ""'%s'"", namespace)
            raise webob.exc.HTTPForbidden(explanation=e.msg)
        except exception.NotFound as e:
            raise webob.exc.HTTPNotFound(explanation=e.msg)
        except exception.Duplicate as e:
            raise webob.exc.HTTPConflict(explanation=e.msg)"
194,apps/glance/glance/api/v2/metadef_objects.py,debug,LOG.debug,key,index.sort_key,"try:
            ns_repo = self.gateway.get_metadef_namespace_repo(req.context)
            try:
                namespace_obj = ns_repo.get(namespace)
            except exception.Forbidden:
                # NOTE (abhishekk): Returning 404 Not Found as the
                # namespace is outside of this user's project
                msg = _(""Namespace %s not found"") % namespace
                raise exception.NotFound(msg)

            # NOTE(abhishekk): This is just a ""do you have permission to
            # list objects"" check. Each object is checked against
            # get_metadef_object below.
            api_policy.MetadefAPIPolicy(
                req.context,
                md_resource=namespace_obj,
                enforcer=self.policy).get_metadef_objects()

            filters = filters or dict()
            filters['namespace'] = namespace
            object_repo = self.gateway.get_metadef_object_repo(req.context)

            db_metaobject_list = object_repo.list(
                marker=marker, limit=limit, sort_key=sort_key,
                sort_dir=sort_dir, filters=filters)

            object_list = [
                MetadefObject.to_wsme_model(
                    obj, get_object_href(namespace, obj),
                    self.obj_schema_link
                ) for obj in db_metaobject_list if api_policy.MetadefAPIPolicy(
                    req.context, md_resource=obj.namespace,
                    enforcer=self.policy
                ).check('get_metadef_object')]

            metadef_objects = MetadefObjects()
            metadef_objects.objects = object_list
        except exception.Forbidden as e:
            LOG.debug(""User not permitted to retrieve metadata objects within ""
                      ""'%s' namespace"", namespace)
            raise webob.exc.HTTPForbidden(explanation=e.msg)
        except exception.NotFound as e:
            raise webob.exc.HTTPNotFound(explanation=e.msg)"
195,apps/glance/glance/api/v2/metadef_objects.py,debug,LOG.debug,key,index.db_metaobject_list,"try:
            ns_repo = self.gateway.get_metadef_namespace_repo(req.context)
            try:
                namespace_obj = ns_repo.get(namespace)
            except exception.Forbidden:
                # NOTE (abhishekk): Returning 404 Not Found as the
                # namespace is outside of this user's project
                msg = _(""Namespace %s not found"") % namespace
                raise exception.NotFound(msg)

            # NOTE(abhishekk): This is just a ""do you have permission to
            # list objects"" check. Each object is checked against
            # get_metadef_object below.
            api_policy.MetadefAPIPolicy(
                req.context,
                md_resource=namespace_obj,
                enforcer=self.policy).get_metadef_objects()

            filters = filters or dict()
            filters['namespace'] = namespace
            object_repo = self.gateway.get_metadef_object_repo(req.context)

            db_metaobject_list = object_repo.list(
                marker=marker, limit=limit, sort_key=sort_key,
                sort_dir=sort_dir, filters=filters)

            object_list = [
                MetadefObject.to_wsme_model(
                    obj, get_object_href(namespace, obj),
                    self.obj_schema_link
                ) for obj in db_metaobject_list if api_policy.MetadefAPIPolicy(
                    req.context, md_resource=obj.namespace,
                    enforcer=self.policy
                ).check('get_metadef_object')]

            metadef_objects = MetadefObjects()
            metadef_objects.objects = object_list
        except exception.Forbidden as e:
            LOG.debug(""User not permitted to retrieve metadata objects within ""
                      ""'%s' namespace"", namespace)
            raise webob.exc.HTTPForbidden(explanation=e.msg)
        except exception.NotFound as e:
            raise webob.exc.HTTPNotFound(explanation=e.msg)"
196,apps/glance/glance/api/v2/metadef_tags.py,debug,LOG.debug,key,index.sort_key,"try:
            # NOTE(abhishekk): This is just a ""do you have permission to
            # list tags"" check. Each object is checked against
            # get_metadef_tag below.
            api_policy.MetadefAPIPolicy(
                req.context,
                md_resource=namespace_obj,
                enforcer=self.policy).get_metadef_tags()

            filters = filters or dict()
            filters['namespace'] = namespace

            tag_repo = self.gateway.get_metadef_tag_repo(req.context)
            if marker:
                metadef_tag = tag_repo.get(namespace, marker)
                marker = metadef_tag.tag_id

            db_metatag_list = tag_repo.list(
                marker=marker, limit=limit, sort_key=sort_key,
                sort_dir=sort_dir, filters=filters)

            tag_list = [MetadefTag(**{'name': db_metatag.name})
                        for db_metatag in db_metatag_list]

            metadef_tags = MetadefTags()
            metadef_tags.tags = tag_list
        except exception.Forbidden as e:
            LOG.debug(""User not permitted to retrieve metadata tags ""
                      ""within '%s' namespace"", namespace)
            raise webob.exc.HTTPForbidden(explanation=e.msg)
        except exception.NotFound as e:
            raise webob.exc.HTTPNotFound(explanation=e.msg)"
197,apps/glance/glance/api/v2/metadef_tags.py,debug,LOG.debug,key,index.db_metatag_list,"try:
            # NOTE(abhishekk): This is just a ""do you have permission to
            # list tags"" check. Each object is checked against
            # get_metadef_tag below.
            api_policy.MetadefAPIPolicy(
                req.context,
                md_resource=namespace_obj,
                enforcer=self.policy).get_metadef_tags()

            filters = filters or dict()
            filters['namespace'] = namespace

            tag_repo = self.gateway.get_metadef_tag_repo(req.context)
            if marker:
                metadef_tag = tag_repo.get(namespace, marker)
                marker = metadef_tag.tag_id

            db_metatag_list = tag_repo.list(
                marker=marker, limit=limit, sort_key=sort_key,
                sort_dir=sort_dir, filters=filters)

            tag_list = [MetadefTag(**{'name': db_metatag.name})
                        for db_metatag in db_metatag_list]

            metadef_tags = MetadefTags()
            metadef_tags.tags = tag_list
        except exception.Forbidden as e:
            LOG.debug(""User not permitted to retrieve metadata tags ""
                      ""within '%s' namespace"", namespace)
            raise webob.exc.HTTPForbidden(explanation=e.msg)
        except exception.NotFound as e:
            raise webob.exc.HTTPNotFound(explanation=e.msg)"
198,apps/glance/glance/api/v2/tasks.py,task_executor,create.executor_factory,user,create.ctxt.user_id,"try:
            new_task = task_factory.new_task(
                task_type=task['type'],
                owner=ctxt.owner,
                task_input=task['input'],
                image_id=task['input'].get('image_id'),
                user_id=ctxt.user_id,
                request_id=ctxt.request_id)
            task_repo.add(new_task)
            task_executor = executor_factory.new_task_executor(ctxt)
            pool = common.get_thread_pool(""tasks_pool"")
            pool.spawn(new_task.run, task_executor)
        except exception.Forbidden as e:
            msg = (_LW(""Forbidden to create task. Reason: %(reason)s"")
                   % {'reason': encodeutils.exception_to_unicode(e)})
            LOG.warning(msg)
            raise webob.exc.HTTPForbidden(explanation=e.msg)"
199,apps/glance/glance/api/v2/tasks.py,task_executor,create.executor_factory.new_task_executor,user,create.ctxt.user_id,"try:
            new_task = task_factory.new_task(
                task_type=task['type'],
                owner=ctxt.owner,
                task_input=task['input'],
                image_id=task['input'].get('image_id'),
                user_id=ctxt.user_id,
                request_id=ctxt.request_id)
            task_repo.add(new_task)
            task_executor = executor_factory.new_task_executor(ctxt)
            pool = common.get_thread_pool(""tasks_pool"")
            pool.spawn(new_task.run, task_executor)
        except exception.Forbidden as e:
            msg = (_LW(""Forbidden to create task. Reason: %(reason)s"")
                   % {'reason': encodeutils.exception_to_unicode(e)})
            LOG.warning(msg)
            raise webob.exc.HTTPForbidden(explanation=e.msg)"
200,apps/glance/glance/api/v2/tasks.py,task_executor,executor_factory.new_task_executor,user,create.ctxt.user_id,"try:
            new_task = task_factory.new_task(
                task_type=task['type'],
                owner=ctxt.owner,
                task_input=task['input'],
                image_id=task['input'].get('image_id'),
                user_id=ctxt.user_id,
                request_id=ctxt.request_id)
            task_repo.add(new_task)
            task_executor = executor_factory.new_task_executor(ctxt)
            pool = common.get_thread_pool(""tasks_pool"")
            pool.spawn(new_task.run, task_executor)
        except exception.Forbidden as e:
            msg = (_LW(""Forbidden to create task. Reason: %(reason)s"")
                   % {'reason': encodeutils.exception_to_unicode(e)})
            LOG.warning(msg)
            raise webob.exc.HTTPForbidden(explanation=e.msg)"
201,apps/glance/glance/api/v2/tasks.py,task_executor,create.executor_factory,user,ctxt.user_id,"try:
            new_task = task_factory.new_task(
                task_type=task['type'],
                owner=ctxt.owner,
                task_input=task['input'],
                image_id=task['input'].get('image_id'),
                user_id=ctxt.user_id,
                request_id=ctxt.request_id)
            task_repo.add(new_task)
            task_executor = executor_factory.new_task_executor(ctxt)
            pool = common.get_thread_pool(""tasks_pool"")
            pool.spawn(new_task.run, task_executor)
        except exception.Forbidden as e:
            msg = (_LW(""Forbidden to create task. Reason: %(reason)s"")
                   % {'reason': encodeutils.exception_to_unicode(e)})
            LOG.warning(msg)
            raise webob.exc.HTTPForbidden(explanation=e.msg)"
202,apps/glance/glance/api/v2/tasks.py,task_executor,create.executor_factory.new_task_executor,user,ctxt.user_id,"try:
            new_task = task_factory.new_task(
                task_type=task['type'],
                owner=ctxt.owner,
                task_input=task['input'],
                image_id=task['input'].get('image_id'),
                user_id=ctxt.user_id,
                request_id=ctxt.request_id)
            task_repo.add(new_task)
            task_executor = executor_factory.new_task_executor(ctxt)
            pool = common.get_thread_pool(""tasks_pool"")
            pool.spawn(new_task.run, task_executor)
        except exception.Forbidden as e:
            msg = (_LW(""Forbidden to create task. Reason: %(reason)s"")
                   % {'reason': encodeutils.exception_to_unicode(e)})
            LOG.warning(msg)
            raise webob.exc.HTTPForbidden(explanation=e.msg)"
203,apps/glance/glance/api/v2/tasks.py,task_executor,executor_factory.new_task_executor,user,ctxt.user_id,"try:
            new_task = task_factory.new_task(
                task_type=task['type'],
                owner=ctxt.owner,
                task_input=task['input'],
                image_id=task['input'].get('image_id'),
                user_id=ctxt.user_id,
                request_id=ctxt.request_id)
            task_repo.add(new_task)
            task_executor = executor_factory.new_task_executor(ctxt)
            pool = common.get_thread_pool(""tasks_pool"")
            pool.spawn(new_task.run, task_executor)
        except exception.Forbidden as e:
            msg = (_LW(""Forbidden to create task. Reason: %(reason)s"")
                   % {'reason': encodeutils.exception_to_unicode(e)})
            LOG.warning(msg)
            raise webob.exc.HTTPForbidden(explanation=e.msg)"
204,apps/glance/glance/api/versions.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"if CONF.image_cache_dir:
            version_objs.extend([
                build_version_object('2.16', 'v2', 'SUPPORTED'),
                build_version_object('2.15', 'v2', 'SUPPORTED'),
                build_version_object('2.14', 'v2', 'SUPPORTED'),
            ])
        else:
            version_objs.extend([
                build_version_object('2.15', 'v2', 'SUPPORTED'),
            ])
        if CONF.enabled_backends:
            version_objs.extend([
                build_version_object('2.13', 'v2', 'SUPPORTED'),
                build_version_object('2.12', 'v2', 'SUPPORTED'),
                build_version_object('2.11', 'v2', 'SUPPORTED'),
                build_version_object('2.10', 'v2', 'SUPPORTED'),
                build_version_object('2.9', 'v2', 'SUPPORTED'),
                build_version_object('2.8', 'v2', 'SUPPORTED'),
            ])
        else:"
205,apps/glance/glance/api/versions.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"if CONF.enabled_backends:
            version_objs.extend([
                build_version_object('2.13', 'v2', 'SUPPORTED'),
                build_version_object('2.12', 'v2', 'SUPPORTED'),
                build_version_object('2.11', 'v2', 'SUPPORTED'),
                build_version_object('2.10', 'v2', 'SUPPORTED'),
                build_version_object('2.9', 'v2', 'SUPPORTED'),
                build_version_object('2.8', 'v2', 'SUPPORTED'),
            ])
        else:
            version_objs.extend([
                build_version_object('2.9', 'v2', 'SUPPORTED'),
            ])"
206,apps/glance/glance/async_/flows/_internal_plugins/base_download.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"self.action_wrapper = action_wrapper
        self.stores = stores
        self._path = None
        self.plugin_name = plugin_name or 'Download'
        super(BaseDownload, self).__init__(
            name='%s-%s-%s' % (task_type, self.plugin_name, task_id))

        # NOTE(abhishekk): Use reserved 'os_glance_staging_store' for
        # staging the data, the else part will be removed once old way
        # of configuring store is deprecated.
        if CONF.enabled_backends:
            self.store = store_api.get_store_from_store_identifier(
                'os_glance_staging_store')
        else:
            if CONF.node_staging_uri is None:
                msg = (_(""%(task_id)s of %(task_type)s not configured ""
                         ""properly. Missing node_staging_uri: %(work_dir)s"") %
                       {'task_id': self.task_id,
                        'task_type': self.task_type,
                        'work_dir': CONF.node_staging_uri})"
207,apps/glance/glance/async_/flows/_internal_plugins/base_download.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"with self.action_wrapper as action:
            action.set_image_attribute(status='queued')
            action.remove_importing_stores(self.stores)
            action.add_failed_stores(self.stores)

        # NOTE(abhishekk): Deleting partial image data from staging area
        if self._path is not None:
            LOG.debug(('Deleting image %(image_id)s from staging '
                       'area.'), {'image_id': self.image_id})
            try:
                if CONF.enabled_backends:
                    store_api.delete(self._path, None)
                else:
                    store_api.delete_from_backend(self._path)
            except Exception:
                LOG.exception(_LE(""Error reverting web/glance download ""
                                  ""task: %(task_id)s""), {
                    'task_id': self.task_id})"
208,apps/glance/glance/async_/flows/_internal_plugins/base_download.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"if CONF.enabled_backends:
            self.store = store_api.get_store_from_store_identifier(
                'os_glance_staging_store')
        else:
            if CONF.node_staging_uri is None:
                msg = (_(""%(task_id)s of %(task_type)s not configured ""
                         ""properly. Missing node_staging_uri: %(work_dir)s"") %
                       {'task_id': self.task_id,
                        'task_type': self.task_type,
                        'work_dir': CONF.node_staging_uri})
                raise exception.BadTaskConfiguration(msg)

            self.store = self._build_store()"
209,apps/glance/glance/async_/flows/_internal_plugins/base_download.py,debug,LOG.debug,enabled,CONF.enabled_backends,"if self._path is not None:
            LOG.debug(('Deleting image %(image_id)s from staging '
                       'area.'), {'image_id': self.image_id})
            try:
                if CONF.enabled_backends:
                    store_api.delete(self._path, None)
                else:
                    store_api.delete_from_backend(self._path)
            except Exception:
                LOG.exception(_LE(""Error reverting web/glance download ""
                                  ""task: %(task_id)s""), {
                    'task_id': self.task_id})"
210,apps/glance/glance/async_/flows/_internal_plugins/base_download.py,debug,LOG.debug,enabled_backends,CONF.enabled_backends,"if self._path is not None:
            LOG.debug(('Deleting image %(image_id)s from staging '
                       'area.'), {'image_id': self.image_id})
            try:
                if CONF.enabled_backends:
                    store_api.delete(self._path, None)
                else:
                    store_api.delete_from_backend(self._path)
            except Exception:
                LOG.exception(_LE(""Error reverting web/glance download ""
                                  ""task: %(task_id)s""), {
                    'task_id': self.task_id})"
211,apps/glance/glance/async_/flows/_internal_plugins/base_download.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"if self._path is not None:
            LOG.debug(('Deleting image %(image_id)s from staging '
                       'area.'), {'image_id': self.image_id})
            try:
                if CONF.enabled_backends:
                    store_api.delete(self._path, None)
                else:
                    store_api.delete_from_backend(self._path)
            except Exception:
                LOG.exception(_LE(""Error reverting web/glance download ""
                                  ""task: %(task_id)s""), {
                    'task_id': self.task_id})"
212,apps/glance/glance/async_/flows/_internal_plugins/base_download.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"if CONF.enabled_backends:
                    store_api.delete(self._path, None)
                else:
                    store_api.delete_from_backend(self._path)"
213,apps/glance/glance/async_/flows/_internal_plugins/base_download.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"try:
                if CONF.enabled_backends:
                    store_api.delete(self._path, None)
                else:
                    store_api.delete_from_backend(self._path)
            except Exception:
                LOG.exception(_LE(""Error reverting web/glance download ""
                                  ""task: %(task_id)s""), {
                    'task_id': self.task_id})"
214,apps/glance/glance/async_/flows/_internal_plugins/copy_image.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"if loc['metadata'].get('store') == default_store:
                try:
                    return self._copy_to_staging_store(loc)
                except store_api.exceptions.NotFound:
                    msg = (_LE(""Image not present in default store, searching ""
                               ""in all glance-api specific available ""
                               ""stores""))
                    LOG.error(msg)
                    break

        available_backends = CONF.enabled_backends
        for loc in action.image_locations:
            image_backend = loc['metadata'].get('store')
            if (image_backend in available_backends.keys()
                    and image_backend != default_store):
                try:
                    return self._copy_to_staging_store(loc)
                except store_api.exceptions.NotFound:
                    LOG.error(_LE('Image: %(img_id)s is not present in store '
                                  '%(store)s.'),"
215,apps/glance/glance/async_/flows/_internal_plugins/copy_image.py,enabled,CONF.enabled_backends,enabled_backends,_execute.CONF.enabled_backends,"if loc['metadata'].get('store') == default_store:
                try:
                    return self._copy_to_staging_store(loc)
                except store_api.exceptions.NotFound:
                    msg = (_LE(""Image not present in default store, searching ""
                               ""in all glance-api specific available ""
                               ""stores""))
                    LOG.error(msg)
                    break

        available_backends = CONF.enabled_backends
        for loc in action.image_locations:
            image_backend = loc['metadata'].get('store')
            if (image_backend in available_backends.keys()
                    and image_backend != default_store):
                try:
                    return self._copy_to_staging_store(loc)
                except store_api.exceptions.NotFound:
                    LOG.error(_LE('Image: %(img_id)s is not present in store '
                                  '%(store)s.'),"
216,apps/glance/glance/async_/flows/_internal_plugins/copy_image.py,enabled,_execute.CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"if loc['metadata'].get('store') == default_store:
                try:
                    return self._copy_to_staging_store(loc)
                except store_api.exceptions.NotFound:
                    msg = (_LE(""Image not present in default store, searching ""
                               ""in all glance-api specific available ""
                               ""stores""))
                    LOG.error(msg)
                    break

        available_backends = CONF.enabled_backends
        for loc in action.image_locations:
            image_backend = loc['metadata'].get('store')
            if (image_backend in available_backends.keys()
                    and image_backend != default_store):
                try:
                    return self._copy_to_staging_store(loc)
                except store_api.exceptions.NotFound:
                    LOG.error(_LE('Image: %(img_id)s is not present in store '
                                  '%(store)s.'),"
217,apps/glance/glance/async_/flows/_internal_plugins/copy_image.py,enabled,_execute.CONF.enabled_backends,enabled_backends,_execute.CONF.enabled_backends,"if loc['metadata'].get('store') == default_store:
                try:
                    return self._copy_to_staging_store(loc)
                except store_api.exceptions.NotFound:
                    msg = (_LE(""Image not present in default store, searching ""
                               ""in all glance-api specific available ""
                               ""stores""))
                    LOG.error(msg)
                    break

        available_backends = CONF.enabled_backends
        for loc in action.image_locations:
            image_backend = loc['metadata'].get('store')
            if (image_backend in available_backends.keys()
                    and image_backend != default_store):
                try:
                    return self._copy_to_staging_store(loc)
                except store_api.exceptions.NotFound:
                    LOG.error(_LE('Image: %(img_id)s is not present in store '
                                  '%(store)s.'),"
218,apps/glance/glance/async_/flows/_internal_plugins/copy_image.py,debug,LOG.debug,filesystem_store_datadir,_execute.file_path,"if os.path.exists(file_path):
            # NOTE (abhishekk): If previous copy-image operation is failed
            # due to power failure, network failure or any other reason and
            # the image data here is partial then clear the staging area and
            # re-stage the fresh image data.
            # Ref: https://bugs.launchpad.net/glance/+bug/1885003
            size_in_staging = os.path.getsize(file_path)
            if action.image_size == size_in_staging:
                return file_path, 0
            else:
                LOG.debug((""Found partial image data in staging ""
                           ""%(fn)s, deleting it to re-stage ""
                           ""again""), {'fn': file_path})
                try:
                    os.unlink(file_path)
                except OSError as e:
                    LOG.error(_LE(""Deletion of staged ""
                                  ""image data from %(fn)s has failed because ""
                                  ""[Errno %(en)d]""), {'fn': file_path,
                                                      'en': e.errno})
                    raise"
219,apps/glance/glance/async_/flows/api_image_import.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"self.task_id = task_id
        self.task_type = task_type
        super(_DeleteFromFS, self).__init__(
            name='%s-DeleteFromFS-%s' % (task_type, task_id))

    def execute(self, file_path):
        """"""Remove file from the backend

        :param file_path: path to the file being deleted
        """"""
        if CONF.enabled_backends:
            try:
                store_api.delete(file_path, 'os_glance_staging_store')
            except store_api.exceptions.NotFound as e:
                LOG.error(_(""After upload to backend, deletion of staged ""
                            ""image data from %(fn)s has failed because ""
                            ""%(em)s""), {'fn': file_path,
                                        'em': e.message})
        else:
            # TODO(abhishekk): After removal of backend module from"
220,apps/glance/glance/async_/flows/api_image_import.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"try:
            uri.index('file:///', 0)
        except ValueError:
            msg = (_(""%(task_id)s of %(task_type)s not configured ""
                     ""properly. Value of node_staging_uri must be ""
                     "" in format 'file://<absolute-path>'"") %
                   {'task_id': self.task_id,
                    'task_type': self.task_type})
            raise exception.BadTaskConfiguration(msg)

        if not CONF.enabled_backends:
            # NOTE(jokke): We really don't need the store for anything but
            # verifying that we actually can build the store will allow us to
            # fail the flow early with clear message why that happens.
            self._build_store()

    def _build_store(self):
        # TODO(abhishekk): After removal of backend module from glance_store
        # need to change this to use multi_backend module.
        # NOTE(jokke): If we want to use some other store for staging, we can"
221,apps/glance/glance/async_/flows/api_image_import.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"image_id = kwargs.get('image_id')
    import_req = kwargs.get('import_req')
    import_method = import_req['method']['name']
    uri = import_req['method'].get('uri')
    stores = kwargs.get('backend', [None])
    all_stores_must_succeed = import_req.get(
        'all_stores_must_succeed', True)
    context = kwargs.get('context')

    separator = ''
    if not CONF.enabled_backends and not CONF.node_staging_uri.endswith('/'):
        separator = '/'

    # Instantiate an action wrapper with the admin repo if we got one,
    # otherwise with the regular repo.
    action_wrapper = ImportActionWrapper(admin_repo or image_repo, image_id,
                                         task_id)
    kwargs['action_wrapper'] = action_wrapper

    if not uri and import_method in ['glance-direct', 'copy-image']:"
222,apps/glance/glance/async_/flows/api_image_import.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"if not CONF.enabled_backends and not CONF.node_staging_uri.endswith('/'):
        separator = '/'

    # Instantiate an action wrapper with the admin repo if we got one,
    # otherwise with the regular repo.
    action_wrapper = ImportActionWrapper(admin_repo or image_repo, image_id,
                                         task_id)
    kwargs['action_wrapper'] = action_wrapper

    if not uri and import_method in ['glance-direct', 'copy-image']:
        if CONF.enabled_backends:
            separator, staging_dir = store_utils.get_dir_separator()
            uri = separator.join((staging_dir, str(image_id)))
        else:
            uri = separator.join((CONF.node_staging_uri, str(image_id)))

    flow = lf.Flow(task_type, retry=retry.AlwaysRevert())

    flow.add(_ImageLock(task_id, task_type, action_wrapper))"
223,apps/glance/glance/async_/flows/api_image_import.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"flow = lf.Flow(task_type, retry=retry.AlwaysRevert())

    flow.add(_ImageLock(task_id, task_type, action_wrapper))

    if import_method in ['web-download', 'copy-image', 'glance-download']:
        if import_method == 'glance-download':
            flow.add(_ImportMetadata(task_id, task_type,
                                     context, action_wrapper, import_req))
        internal_plugin = internal_plugins.get_import_plugin(**kwargs)
        flow.add(internal_plugin)
        if CONF.enabled_backends:
            separator, staging_dir = store_utils.get_dir_separator()
            file_uri = separator.join((staging_dir, str(image_id)))
        else:
            file_uri = separator.join((CONF.node_staging_uri, str(image_id)))
    else:
        file_uri = uri

    flow.add(_VerifyStaging(task_id, task_type, task_repo, file_uri))"
224,apps/glance/glance/async_/flows/api_image_import.py,debug,LOG.debug,key,merge_store_list.existing,"if subtract:
            if stores - existing:
                LOG.debug('Stores %(stores)s not in %(key)s for '
                          'image %(image_id)s',
                          {'stores': ','.join(sorted(stores - existing)),
                           'key': list_key,
                           'image_id': self.image_id})
            merged_stores = existing - stores
        else:
            merged_stores = existing | stores"
225,apps/glance/glance/async_/flows/api_image_import.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"if CONF.enabled_backends:
            try:
                store_api.delete(file_path, 'os_glance_staging_store')
            except store_api.exceptions.NotFound as e:
                LOG.error(_(""After upload to backend, deletion of staged ""
                            ""image data from %(fn)s has failed because ""
                            ""%(em)s""), {'fn': file_path,
                                        'em': e.message})
        else:
            # TODO(abhishekk): After removal of backend module from
            # glance_store need to change this to use multi_backend
            # module.
            file_path = file_path[7:]
            if os.path.exists(file_path):
                try:
                    LOG.debug(_(""After upload to the backend, deleting staged ""
                                ""image data from %(fn)s""), {'fn': file_path})
                    os.unlink(file_path)
                except OSError as e:
                    LOG.error(_(""After upload to backend, deletion of staged ""
                                ""image data from %(fn)s has failed because ""
                                ""[Errno %(en)d]""), {'fn': file_path,
                                                    'en': e.errno})
            else:
                LOG.warning(_(""After upload to backend, deletion of staged ""
                              ""image data has failed because ""
                              ""it cannot be found at %(fn)s""), {
                    'fn': file_path})"
226,apps/glance/glance/async_/flows/api_image_import.py,debug,LOG.debug,enabled,CONF.enabled_backends,"if CONF.enabled_backends:
            try:
                store_api.delete(file_path, 'os_glance_staging_store')
            except store_api.exceptions.NotFound as e:
                LOG.error(_(""After upload to backend, deletion of staged ""
                            ""image data from %(fn)s has failed because ""
                            ""%(em)s""), {'fn': file_path,
                                        'em': e.message})
        else:
            # TODO(abhishekk): After removal of backend module from
            # glance_store need to change this to use multi_backend
            # module.
            file_path = file_path[7:]
            if os.path.exists(file_path):
                try:
                    LOG.debug(_(""After upload to the backend, deleting staged ""
                                ""image data from %(fn)s""), {'fn': file_path})
                    os.unlink(file_path)
                except OSError as e:
                    LOG.error(_(""After upload to backend, deletion of staged ""
                                ""image data from %(fn)s has failed because ""
                                ""[Errno %(en)d]""), {'fn': file_path,
                                                    'en': e.errno})
            else:
                LOG.warning(_(""After upload to backend, deletion of staged ""
                              ""image data has failed because ""
                              ""it cannot be found at %(fn)s""), {
                    'fn': file_path})"
227,apps/glance/glance/async_/flows/api_image_import.py,debug,LOG.debug,enabled_backends,CONF.enabled_backends,"if CONF.enabled_backends:
            try:
                store_api.delete(file_path, 'os_glance_staging_store')
            except store_api.exceptions.NotFound as e:
                LOG.error(_(""After upload to backend, deletion of staged ""
                            ""image data from %(fn)s has failed because ""
                            ""%(em)s""), {'fn': file_path,
                                        'em': e.message})
        else:
            # TODO(abhishekk): After removal of backend module from
            # glance_store need to change this to use multi_backend
            # module.
            file_path = file_path[7:]
            if os.path.exists(file_path):
                try:
                    LOG.debug(_(""After upload to the backend, deleting staged ""
                                ""image data from %(fn)s""), {'fn': file_path})
                    os.unlink(file_path)
                except OSError as e:
                    LOG.error(_(""After upload to backend, deletion of staged ""
                                ""image data from %(fn)s has failed because ""
                                ""[Errno %(en)d]""), {'fn': file_path,
                                                    'en': e.errno})
            else:
                LOG.warning(_(""After upload to backend, deletion of staged ""
                              ""image data has failed because ""
                              ""it cannot be found at %(fn)s""), {
                    'fn': file_path})"
228,apps/glance/glance/async_/flows/api_image_import.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"if not CONF.enabled_backends:
            # NOTE(jokke): We really don't need the store for anything but
            # verifying that we actually can build the store will allow us to
            # fail the flow early with clear message why that happens.
            self._build_store()"
229,apps/glance/glance/async_/flows/api_image_import.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"if not CONF.enabled_backends and not CONF.node_staging_uri.endswith('/'):
        separator = '/'"
230,apps/glance/glance/async_/flows/api_image_import.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"if not uri and import_method in ['glance-direct', 'copy-image']:
        if CONF.enabled_backends:
            separator, staging_dir = store_utils.get_dir_separator()
            uri = separator.join((staging_dir, str(image_id)))
        else:
            uri = separator.join((CONF.node_staging_uri, str(image_id)))"
231,apps/glance/glance/async_/flows/api_image_import.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"if CONF.enabled_backends:
            separator, staging_dir = store_utils.get_dir_separator()
            uri = separator.join((staging_dir, str(image_id)))
        else:
            uri = separator.join((CONF.node_staging_uri, str(image_id)))"
232,apps/glance/glance/async_/flows/api_image_import.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"if import_method in ['web-download', 'copy-image', 'glance-download']:
        if import_method == 'glance-download':
            flow.add(_ImportMetadata(task_id, task_type,
                                     context, action_wrapper, import_req))
        internal_plugin = internal_plugins.get_import_plugin(**kwargs)
        flow.add(internal_plugin)
        if CONF.enabled_backends:
            separator, staging_dir = store_utils.get_dir_separator()
            file_uri = separator.join((staging_dir, str(image_id)))
        else:
            file_uri = separator.join((CONF.node_staging_uri, str(image_id)))
    else:
        file_uri = uri"
233,apps/glance/glance/async_/flows/api_image_import.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"if CONF.enabled_backends:
            separator, staging_dir = store_utils.get_dir_separator()
            file_uri = separator.join((staging_dir, str(image_id)))
        else:
            file_uri = separator.join((CONF.node_staging_uri, str(image_id)))"
234,apps/glance/glance/async_/flows/base_import.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"self.task_id = task_id
        self.task_type = task_type
        self.task_repo = task_repo
        self.uri = uri
        super(_ImportToFS, self).__init__(
            name='%s-ImportToFS-%s' % (task_type, task_id))

        # NOTE(abhishekk): Use reserved 'os_glance_tasks_store' for tasks,
        # the else part will be removed once old way of configuring store
        # is deprecated.
        if CONF.enabled_backends:
            self.store = store_api.get_store_from_store_identifier(
                'os_glance_tasks_store')
        else:
            if CONF.task.work_dir is None:
                msg = (_(""%(task_id)s of %(task_type)s not configured ""
                         ""properly. Missing work dir: %(work_dir)s"") %
                       {'task_id': self.task_id,
                        'task_type': self.task_type,
                        'work_dir': CONF.task.work_dir})"
235,apps/glance/glance/async_/flows/base_import.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"return path

    def revert(self, image_id, result, **kwargs):
        if isinstance(result, failure.Failure):
            LOG.exception(_LE('Task: %(task_id)s failed to import image '
                              '%(image_id)s to the filesystem.'),
                          {'task_id': self.task_id, 'image_id': image_id})
            return

        if os.path.exists(result.split(""file://"")[-1]):
            if CONF.enabled_backends:
                store_api.delete(result, 'os_glance_tasks_store')
            else:
                store_api.delete_from_backend(result)


class _DeleteFromFS(task.Task):

    def __init__(self, task_id, task_type):
        self.task_id = task_id"
236,apps/glance/glance/async_/flows/base_import.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"self.task_id = task_id
        self.task_type = task_type
        super(_DeleteFromFS, self).__init__(
            name='%s-DeleteFromFS-%s' % (task_type, task_id))

    def execute(self, file_path):
        """"""Remove file from the backend

        :param file_path: path to the file being deleted
        """"""
        if CONF.enabled_backends:
            store_api.delete(file_path, 'os_glance_tasks_store')
        else:
            store_api.delete_from_backend(file_path)


class _ImportToStore(task.Task):

    def __init__(self, task_id, task_type, image_repo, uri, backend):
        self.task_id = task_id"
237,apps/glance/glance/async_/flows/base_import.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"if CONF.enabled_backends:
            self.store = store_api.get_store_from_store_identifier(
                'os_glance_tasks_store')
        else:
            if CONF.task.work_dir is None:
                msg = (_(""%(task_id)s of %(task_type)s not configured ""
                         ""properly. Missing work dir: %(work_dir)s"") %
                       {'task_id': self.task_id,
                        'task_type': self.task_type,
                        'work_dir': CONF.task.work_dir})
                raise exception.BadTaskConfiguration(msg)

            self.store = self._build_store()"
238,apps/glance/glance/async_/flows/base_import.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"if os.path.exists(result.split(""file://"")[-1]):
            if CONF.enabled_backends:
                store_api.delete(result, 'os_glance_tasks_store')
            else:
                store_api.delete_from_backend(result)"
239,apps/glance/glance/async_/flows/base_import.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"if CONF.enabled_backends:
                store_api.delete(result, 'os_glance_tasks_store')
            else:
                store_api.delete_from_backend(result)"
240,apps/glance/glance/async_/flows/base_import.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"if CONF.enabled_backends:
            store_api.delete(file_path, 'os_glance_tasks_store')
        else:
            store_api.delete_from_backend(file_path)"
241,apps/glance/glance/async_/flows/convert.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"# format already. Probably using `qemu-img` just like the
        # `Introspection` task.

        # NOTE(hemanthm): We add '-f' parameter to the convert command here so
        # that the image format need not be inferred by qemu utils. This
        # shields us from being vulnerable to an attack vector described here
        # https://bugs.launchpad.net/glance/+bug/1449062

        data_dir = CONF.task.work_dir
        # NOTE(abhishekk): Use reserved 'os_glance_tasks_store' for tasks.
        if CONF.enabled_backends:
            data_dir = getattr(
                CONF, 'os_glance_tasks_store').filesystem_store_datadir

        dest_path = os.path.join(data_dir, ""%s.converted"" % image_id)
        stdout, stderr = putils.trycmd('qemu-img', 'convert',
                                       '-f', src_format,
                                       '-O', conversion_format,
                                       file_path, dest_path,
                                       log_errors=putils.LOG_ALL_ERRORS)"
242,apps/glance/glance/async_/flows/convert.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"if CONF.enabled_backends:
            data_dir = getattr(
                CONF, 'os_glance_tasks_store').filesystem_store_datadir"
243,apps/glance/glance/async_/flows/convert.py,enabled_backends,CONF.enabled_backends,filesystem_store_datadir,execute.filesystem_store_datadir,"if CONF.enabled_backends:
            data_dir = getattr(
                CONF, 'os_glance_tasks_store').filesystem_store_datadir"
244,apps/glance/glance/async_/flows/convert.py,enabled_backends,CONF.enabled_backends,filesystem_store_datadir,filesystem_store_datadir,"if CONF.enabled_backends:
            data_dir = getattr(
                CONF, 'os_glance_tasks_store').filesystem_store_datadir"
245,apps/glance/glance/async_/flows/convert.py,enabled,CONF.enabled_backends,filesystem_store_datadir,execute.filesystem_store_datadir,"if CONF.enabled_backends:
            data_dir = getattr(
                CONF, 'os_glance_tasks_store').filesystem_store_datadir"
246,apps/glance/glance/async_/flows/convert.py,enabled,CONF.enabled_backends,filesystem_store_datadir,filesystem_store_datadir,"if CONF.enabled_backends:
            data_dir = getattr(
                CONF, 'os_glance_tasks_store').filesystem_store_datadir"
247,apps/glance/glance/async_/flows/location_import.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,":param url: Location URL
        """"""
        image = self.image_repo.get(self.image_id)
        try:
            # (NOTE(pdeore): Add metadata key to add the store identifier
            # as location metadata
            updated_location = {
                'url': self.url,
                'metadata': {},
            }
            if CONF.enabled_backends:
                updated_location = store_utils.get_updated_store_location(
                    [updated_location], context=self.context)[0]

            image.locations.append(updated_location)
            self.image_repo.save(image)
        except (exception.Invalid, exception.BadStoreUri) as e:
            raise _InvalidLocation(e.msg)"
248,apps/glance/glance/async_/flows/location_import.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"if CONF.enabled_backends:
                updated_location = store_utils.get_updated_store_location(
                    [updated_location], context=self.context)[0]"
249,apps/glance/glance/async_/flows/location_import.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"try:
            # (NOTE(pdeore): Add metadata key to add the store identifier
            # as location metadata
            updated_location = {
                'url': self.url,
                'metadata': {},
            }
            if CONF.enabled_backends:
                updated_location = store_utils.get_updated_store_location(
                    [updated_location], context=self.context)[0]

            image.locations.append(updated_location)
            self.image_repo.save(image)
        except (exception.Invalid, exception.BadStoreUri) as e:
            raise _InvalidLocation(e.msg)"
250,apps/glance/glance/async_/flows/ovf_process.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"def __init__(self, task_id, task_type, image_repo):
        self.task_id = task_id
        self.task_type = task_type
        self.image_repo = image_repo
        super(_OVF_Process, self).__init__(
            name='%s-OVF_Process-%s' % (task_type, task_id))

    def _get_extracted_file_path(self, image_id):
        file_path = CONF.task.work_dir
        # NOTE(abhishekk): Use reserved 'os_glance_tasks_store' for tasks.
        if CONF.enabled_backends:
            file_path = getattr(
                CONF, 'os_glance_tasks_store').filesystem_store_datadir

        return os.path.join(file_path,
                            ""%s.extracted"" % image_id)

    def _get_ova_iter_objects(self, uri):
        """"""Returns iterable object either for local file or uri"
251,apps/glance/glance/async_/flows/ovf_process.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"if CONF.enabled_backends:
            file_path = getattr(
                CONF, 'os_glance_tasks_store').filesystem_store_datadir"
252,apps/glance/glance/async_/flows/ovf_process.py,enabled_backends,CONF.enabled_backends,filesystem_store_datadir,_get_extracted_file_path.filesystem_store_datadir,"if CONF.enabled_backends:
            file_path = getattr(
                CONF, 'os_glance_tasks_store').filesystem_store_datadir"
253,apps/glance/glance/async_/flows/ovf_process.py,enabled_backends,CONF.enabled_backends,filesystem_store_datadir,filesystem_store_datadir,"if CONF.enabled_backends:
            file_path = getattr(
                CONF, 'os_glance_tasks_store').filesystem_store_datadir"
254,apps/glance/glance/async_/flows/ovf_process.py,enabled,CONF.enabled_backends,filesystem_store_datadir,_get_extracted_file_path.filesystem_store_datadir,"if CONF.enabled_backends:
            file_path = getattr(
                CONF, 'os_glance_tasks_store').filesystem_store_datadir"
255,apps/glance/glance/async_/flows/ovf_process.py,enabled,CONF.enabled_backends,filesystem_store_datadir,filesystem_store_datadir,"if CONF.enabled_backends:
            file_path = getattr(
                CONF, 'os_glance_tasks_store').filesystem_store_datadir"
256,apps/glance/glance/async_/flows/plugins/image_conversion.py,debug,LOG.debug,filesystem_store_datadir,_execute.file_path,"if detected_format == 'iso':
            if source_format == 'iso':
                # NOTE(abhishekk): Excluding conversion and preserving image
                # disk_format as `iso` only
                LOG.debug(""Avoiding conversion of an image %s having""
                          "" `iso` disk format."", self.image_id)
                return file_path

            # NOTE(abhishekk): Raising error as image detected as ISO but
            # claimed as different format
            LOG.error('Image claimed to be %s format but format '
                      'inspection found: ISO', source_format)
            raise RuntimeError(""Image has disallowed configuration"")
        elif detected_format != source_format:
            LOG.error('Image claimed to be %s format failed format '
                      'inspection', source_format)
            raise RuntimeError('Image format mismatch')"
257,apps/glance/glance/async_/flows/plugins/image_conversion.py,debug,LOG.debug,filesystem_store_datadir,_execute.file_path,"if source_format == 'iso':
                # NOTE(abhishekk): Excluding conversion and preserving image
                # disk_format as `iso` only
                LOG.debug(""Avoiding conversion of an image %s having""
                          "" `iso` disk format."", self.image_id)
                return file_path"
258,apps/glance/glance/async_/flows/plugins/image_conversion.py,debug,LOG.debug,filesystem_store_datadir,_execute.file_path,"if source_format == target_format:
            LOG.debug(""Source is already in target format, ""
                      ""not doing conversion for %s"", self.image_id)
            return file_path"
259,apps/glance/glance/cmd/api.py,bind_host,CONF.bind_host,enabled,CONF.profiler.enabled,"if CONF.profiler.enabled:
            osprofiler.initializer.init_from_conf(
                conf=CONF,
                context={},
                project=""glance"",
                service=""api"",
                host=CONF.bind_host
            )"
260,apps/glance/glance/cmd/api.py,bind_host,CONF.bind_host,enabled,CONF.profiler.enabled,"try:
        config.parse_args()
        config.set_config_defaults()
        wsgi.set_eventlet_hub()
        logging.setup(CONF, 'glance')
        gmr.TextGuruMeditation.setup_autorun(version)
        notifier.set_defaults()

        if CONF.profiler.enabled:
            osprofiler.initializer.init_from_conf(
                conf=CONF,
                context={},
                project=""glance"",
                service=""api"",
                host=CONF.bind_host
            )

        # NOTE(danms): Configure system-wide threading model to use eventlet
        glance.async_.set_threadpool_model('eventlet')

        server = wsgi.Server(initialize_glance_store=True)
        server.start(config.load_paste_app('glance-api'), default_port=9292)
        server.wait()
    except Exception as e:
        fail(e)"
261,apps/glance/glance/cmd/cache_manage.py,user,get_client.options.os_user_domain_id,user_domain_id,get_client.options.os_user_domain_id,"supplied to the CLI
    """"""
    # Generate auth_url based on identity_api_version
    identity_version = env('OS_IDENTITY_API_VERSION', default='3')
    auth_url = options.os_auth_url
    if identity_version == '3' and ""/v3"" not in auth_url:
        auth_url = auth_url + ""/v3""
    elif identity_version == '2' and ""/v2"" not in auth_url:
        auth_url = auth_url + ""/v2.0""

    user_domain_id = options.os_user_domain_id
    if not user_domain_id:
        user_domain_id = options.os_domain_id
    project_domain_id = options.os_project_domain_id
    if not user_domain_id:
        project_domain_id = options.os_domain_id

    return glance.image_cache.client.get_client(
        host=options.host,
        port=options.port,"
262,apps/glance/glance/cmd/cache_manage.py,user,get_client.options.os_user_domain_id,user_domain_id,options.os_user_domain_id,"supplied to the CLI
    """"""
    # Generate auth_url based on identity_api_version
    identity_version = env('OS_IDENTITY_API_VERSION', default='3')
    auth_url = options.os_auth_url
    if identity_version == '3' and ""/v3"" not in auth_url:
        auth_url = auth_url + ""/v3""
    elif identity_version == '2' and ""/v2"" not in auth_url:
        auth_url = auth_url + ""/v2.0""

    user_domain_id = options.os_user_domain_id
    if not user_domain_id:
        user_domain_id = options.os_domain_id
    project_domain_id = options.os_project_domain_id
    if not user_domain_id:
        project_domain_id = options.os_domain_id

    return glance.image_cache.client.get_client(
        host=options.host,
        port=options.port,"
263,apps/glance/glance/cmd/cache_manage.py,user,options.os_user_domain_id,user_domain_id,get_client.options.os_user_domain_id,"supplied to the CLI
    """"""
    # Generate auth_url based on identity_api_version
    identity_version = env('OS_IDENTITY_API_VERSION', default='3')
    auth_url = options.os_auth_url
    if identity_version == '3' and ""/v3"" not in auth_url:
        auth_url = auth_url + ""/v3""
    elif identity_version == '2' and ""/v2"" not in auth_url:
        auth_url = auth_url + ""/v2.0""

    user_domain_id = options.os_user_domain_id
    if not user_domain_id:
        user_domain_id = options.os_domain_id
    project_domain_id = options.os_project_domain_id
    if not user_domain_id:
        project_domain_id = options.os_domain_id

    return glance.image_cache.client.get_client(
        host=options.host,
        port=options.port,"
264,apps/glance/glance/cmd/cache_manage.py,user,options.os_user_domain_id,user_domain_id,options.os_user_domain_id,"supplied to the CLI
    """"""
    # Generate auth_url based on identity_api_version
    identity_version = env('OS_IDENTITY_API_VERSION', default='3')
    auth_url = options.os_auth_url
    if identity_version == '3' and ""/v3"" not in auth_url:
        auth_url = auth_url + ""/v3""
    elif identity_version == '2' and ""/v2"" not in auth_url:
        auth_url = auth_url + ""/v2.0""

    user_domain_id = options.os_user_domain_id
    if not user_domain_id:
        user_domain_id = options.os_domain_id
    project_domain_id = options.os_project_domain_id
    if not user_domain_id:
        project_domain_id = options.os_domain_id

    return glance.image_cache.client.get_client(
        host=options.host,
        port=options.port,"
265,apps/glance/glance/cmd/cache_prefetcher.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"CONF.set_default(name='use_stderr', default=True)


def main():
    try:
        config.parse_cache_args()
        logging.setup(CONF, 'glance')
        CONF.import_opt('enabled_backends', 'glance.common.wsgi')
        glance.async_.set_threadpool_model('eventlet')

        if CONF.enabled_backends:
            glance_store.register_store_opts(CONF)
            glance_store.create_multi_stores(CONF)
            glance_store.verify_store()
        else:
            glance_store.register_opts(CONF)
            glance_store.create_stores(CONF)
            glance_store.verify_default_store()

        app = prefetcher.Prefetcher()"
266,apps/glance/glance/cmd/cache_prefetcher.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"if CONF.enabled_backends:
            glance_store.register_store_opts(CONF)
            glance_store.create_multi_stores(CONF)
            glance_store.verify_store()
        else:
            glance_store.register_opts(CONF)
            glance_store.create_stores(CONF)
            glance_store.verify_default_store()"
267,apps/glance/glance/cmd/cache_prefetcher.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"try:
        config.parse_cache_args()
        logging.setup(CONF, 'glance')
        CONF.import_opt('enabled_backends', 'glance.common.wsgi')
        glance.async_.set_threadpool_model('eventlet')

        if CONF.enabled_backends:
            glance_store.register_store_opts(CONF)
            glance_store.create_multi_stores(CONF)
            glance_store.verify_store()
        else:
            glance_store.register_opts(CONF)
            glance_store.create_stores(CONF)
            glance_store.verify_default_store()

        app = prefetcher.Prefetcher()
        app.run()
    except RuntimeError as e:
        sys.exit(""ERROR: %s"" % e)"
268,apps/glance/glance/cmd/replicator.py,debug,LOG.debug,key,a.keys,"if set(a.keys()) - set(b.keys()):
        LOG.debug('metadata diff -- source has extra keys: %(keys)s',
                  {'keys': ' '.join(set(a.keys()) - set(b.keys()))})
        return True"
269,apps/glance/glance/cmd/replicator.py,debug,LOG.debug,key,b.keys,"if set(a.keys()) - set(b.keys()):
        LOG.debug('metadata diff -- source has extra keys: %(keys)s',
                  {'keys': ' '.join(set(a.keys()) - set(b.keys()))})
        return True"
270,apps/glance/glance/cmd/scrubber.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"def main():
    try:
        CONF.register_cli_opts(scrubber.scrubber_cmd_cli_opts)
        CONF.register_opts(scrubber.scrubber_cmd_opts)

        config.parse_args()
        logging.setup(CONF, 'glance')
        CONF.import_opt('enabled_backends', 'glance.common.wsgi')

        if CONF.enabled_backends:
            glance_store.register_store_opts(CONF)
            glance_store.create_multi_stores(CONF)
            glance_store.verify_store()
        else:
            glance_store.register_opts(CONF)
            glance_store.create_stores(CONF)
            glance_store.verify_default_store()

        if CONF.restore and CONF.daemon:"
271,apps/glance/glance/cmd/scrubber.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"if CONF.enabled_backends:
            glance_store.register_store_opts(CONF)
            glance_store.create_multi_stores(CONF)
            glance_store.verify_store()
        else:
            glance_store.register_opts(CONF)
            glance_store.create_stores(CONF)
            glance_store.verify_default_store()"
272,apps/glance/glance/cmd/scrubber.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"try:
        CONF.register_cli_opts(scrubber.scrubber_cmd_cli_opts)
        CONF.register_opts(scrubber.scrubber_cmd_opts)

        config.parse_args()
        logging.setup(CONF, 'glance')
        CONF.import_opt('enabled_backends', 'glance.common.wsgi')

        if CONF.enabled_backends:
            glance_store.register_store_opts(CONF)
            glance_store.create_multi_stores(CONF)
            glance_store.verify_store()
        else:
            glance_store.register_opts(CONF)
            glance_store.create_stores(CONF)
            glance_store.verify_default_store()

        if CONF.restore and CONF.daemon:
            sys.exit(""ERROR: The restore and daemon options should not be set ""
                     ""together. Please use either of them in one request."")

        app = scrubber.Scrubber(glance_store)

        if CONF.restore:
            if scrubber_already_running():
                already_running_msg = (
                    ""ERROR: glance-scrubber is already running. ""
                    ""Please ensure that the daemon is stopped."")
                sys.exit(already_running_msg)

            app.revert_image_status(CONF.restore)
        elif CONF.daemon:
            server = scrubber.Daemon(CONF.wakeup_time)
            server.start(app)
            server.wait()
        else:
            app.run()
    except (exception.ImageNotFound, exception.Conflict) as e:
        sys.exit(""ERROR: %s"" % e)
    except RuntimeError as e:
        sys.exit(""ERROR: %s"" % e)"
273,apps/glance/glance/common/store_utils.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"This function try to handle all known exceptions which might be raised
    by those calls on store and DB modules in its implementation.

    :param context: The request context
    :param image_id: The image identifier
    :param location: The image location entry
    """"""

    try:
        if CONF.enabled_backends:
            backend = location['metadata'].get('store')
            ret = store_api.delete(location['url'],
                                   backend,
                                   context=context)
        else:
            ret = store_api.delete_from_backend(location['url'],
                                                context=context)

        location['status'] = 'deleted'"
274,apps/glance/glance/common/store_utils.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,":param uri: The URI of external image location.
    :returns: Whether given URI of external image location are OK.
    """"""
    if not uri:
        return False

    # TODO(zhiyan): This function could be moved to glance_store.
    # TODO(gm): Use a whitelist of allowed schemes
    scheme = urlparse.urlparse(uri).scheme
    known_schemes = store_api.get_known_schemes()
    if CONF.enabled_backends:
        known_schemes = store_api.get_known_schemes_for_multi_store()

    return (scheme in known_schemes and
            scheme not in RESTRICTED_URI_SCHEMAS)


def _get_store_id_from_uri(uri):
    scheme = urlparse.urlparse(uri).scheme
    location_map = store_api.location.SCHEME_TO_CLS_BACKEND_MAP"
275,apps/glance/glance/common/store_utils.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"else:
        LOG.warning(""Invalid location uri %s"", uri)
        return


def update_store_in_locations(context, image, image_repo):
    store_updated = False
    for loc in image.locations:
        if (not loc['metadata'].get(
                'store') or loc['metadata'].get(
                'store') not in CONF.enabled_backends):
            if loc['url'].startswith(""cinder://""):
                _update_cinder_location_and_store_id(context, loc)

            store_id = _get_store_id_from_uri(loc['url'])
            if store_id:
                if 'store' in loc['metadata']:
                    old_store = loc['metadata']['store']
                    if old_store != store_id:
                        LOG.debug(""Store '%(old)s' has changed to """
276,apps/glance/glance/common/store_utils.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"for loc in image.locations:
        if (not loc['metadata'].get(
                'store') or loc['metadata'].get(
                'store') not in CONF.enabled_backends):
            if loc['url'].startswith(""cinder://""):
                _update_cinder_location_and_store_id(context, loc)

            store_id = _get_store_id_from_uri(loc['url'])
            if store_id:
                if 'store' in loc['metadata']:
                    old_store = loc['metadata']['store']
                    if old_store != store_id:
                        LOG.debug(""Store '%(old)s' has changed to ""
                                  ""'%(new)s' by operator, updating ""
                                  ""the same in the location of image ""
                                  ""'%(id)s'"", {'old': old_store,
                                               'new': store_id,
                                               'id': image.image_id})

                store_updated = True
                loc['metadata']['store'] = store_id"
277,apps/glance/glance/common/store_utils.py,debug,LOG.debug,enabled,CONF.enabled_backends,"for loc in image.locations:
        if (not loc['metadata'].get(
                'store') or loc['metadata'].get(
                'store') not in CONF.enabled_backends):
            if loc['url'].startswith(""cinder://""):
                _update_cinder_location_and_store_id(context, loc)

            store_id = _get_store_id_from_uri(loc['url'])
            if store_id:
                if 'store' in loc['metadata']:
                    old_store = loc['metadata']['store']
                    if old_store != store_id:
                        LOG.debug(""Store '%(old)s' has changed to ""
                                  ""'%(new)s' by operator, updating ""
                                  ""the same in the location of image ""
                                  ""'%(id)s'"", {'old': old_store,
                                               'new': store_id,
                                               'id': image.image_id})

                store_updated = True
                loc['metadata']['store'] = store_id"
278,apps/glance/glance/common/store_utils.py,debug,LOG.debug,enabled_backends,CONF.enabled_backends,"for loc in image.locations:
        if (not loc['metadata'].get(
                'store') or loc['metadata'].get(
                'store') not in CONF.enabled_backends):
            if loc['url'].startswith(""cinder://""):
                _update_cinder_location_and_store_id(context, loc)

            store_id = _get_store_id_from_uri(loc['url'])
            if store_id:
                if 'store' in loc['metadata']:
                    old_store = loc['metadata']['store']
                    if old_store != store_id:
                        LOG.debug(""Store '%(old)s' has changed to ""
                                  ""'%(new)s' by operator, updating ""
                                  ""the same in the location of image ""
                                  ""'%(id)s'"", {'old': old_store,
                                               'new': store_id,
                                               'id': image.image_id})

                store_updated = True
                loc['metadata']['store'] = store_id"
279,apps/glance/glance/common/store_utils.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"if CONF.enabled_backends:
            backend = location['metadata'].get('store')
            ret = store_api.delete(location['url'],
                                   backend,
                                   context=context)
        else:
            ret = store_api.delete_from_backend(location['url'],
                                                context=context)"
280,apps/glance/glance/common/store_utils.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"if CONF.enabled_backends:
        known_schemes = store_api.get_known_schemes_for_multi_store()"
281,apps/glance/glance/common/store_utils.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"if (not loc['metadata'].get(
                'store') or loc['metadata'].get(
                'store') not in CONF.enabled_backends):
            if loc['url'].startswith(""cinder://""):
                _update_cinder_location_and_store_id(context, loc)

            store_id = _get_store_id_from_uri(loc['url'])
            if store_id:
                if 'store' in loc['metadata']:
                    old_store = loc['metadata']['store']
                    if old_store != store_id:
                        LOG.debug(""Store '%(old)s' has changed to ""
                                  ""'%(new)s' by operator, updating ""
                                  ""the same in the location of image ""
                                  ""'%(id)s'"", {'old': old_store,
                                               'new': store_id,
                                               'id': image.image_id})

                store_updated = True
                loc['metadata']['store'] = store_id"
282,apps/glance/glance/common/store_utils.py,debug,LOG.debug,enabled,CONF.enabled_backends,"if (not loc['metadata'].get(
                'store') or loc['metadata'].get(
                'store') not in CONF.enabled_backends):
            if loc['url'].startswith(""cinder://""):
                _update_cinder_location_and_store_id(context, loc)

            store_id = _get_store_id_from_uri(loc['url'])
            if store_id:
                if 'store' in loc['metadata']:
                    old_store = loc['metadata']['store']
                    if old_store != store_id:
                        LOG.debug(""Store '%(old)s' has changed to ""
                                  ""'%(new)s' by operator, updating ""
                                  ""the same in the location of image ""
                                  ""'%(id)s'"", {'old': old_store,
                                               'new': store_id,
                                               'id': image.image_id})

                store_updated = True
                loc['metadata']['store'] = store_id"
283,apps/glance/glance/common/store_utils.py,debug,LOG.debug,enabled_backends,CONF.enabled_backends,"if (not loc['metadata'].get(
                'store') or loc['metadata'].get(
                'store') not in CONF.enabled_backends):
            if loc['url'].startswith(""cinder://""):
                _update_cinder_location_and_store_id(context, loc)

            store_id = _get_store_id_from_uri(loc['url'])
            if store_id:
                if 'store' in loc['metadata']:
                    old_store = loc['metadata']['store']
                    if old_store != store_id:
                        LOG.debug(""Store '%(old)s' has changed to ""
                                  ""'%(new)s' by operator, updating ""
                                  ""the same in the location of image ""
                                  ""'%(id)s'"", {'old': old_store,
                                               'new': store_id,
                                               'id': image.image_id})

                store_updated = True
                loc['metadata']['store'] = store_id"
284,apps/glance/glance/common/store_utils.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"try:
        if CONF.enabled_backends:
            backend = location['metadata'].get('store')
            ret = store_api.delete(location['url'],
                                   backend,
                                   context=context)
        else:
            ret = store_api.delete_from_backend(location['url'],
                                                context=context)

        location['status'] = 'deleted'
        if 'id' in location:
            db_api.get_api().image_location_delete(context, image_id,
                                                   location['id'], 'deleted')
        return ret
    except store_api.NotFound:
        msg = (""The image data for %(iid)s was not found in the store. ""
               ""The image record has been updated to reflect ""
               ""this."" % {'iid': image_id})
        LOG.warning(msg)
    except store_api.StoreDeleteNotSupported as e:
        LOG.warning(encodeutils.exception_to_unicode(e))
    except store_api.UnsupportedBackend:
        exc_type = sys.exc_info()[0].__name__
        msg = (_LE('Failed to delete image %(image_id)s from store: %(exc)s') %
               dict(image_id=image_id, exc=exc_type))
        LOG.error(msg)"
285,apps/glance/glance/common/swift_store_utils.py,key,CONF.swift_store_key,swift_store_key,CONF.swift_store_key,"class SwiftParams(object):
    def __init__(self):
        if is_multiple_swift_store_accounts_enabled():
            self.params = self._load_config()
        else:
            self.params = self._form_default_params()

    def _form_default_params(self):
        default = {}
        if (CONF.swift_store_user and CONF.swift_store_key
           and CONF.swift_store_auth_address):
            default['user'] = CONF.swift_store_user
            default['key'] = CONF.swift_store_key
            default['auth_address'] = CONF.swift_store_auth_address
            return {CONF.default_swift_reference: default}
        return {}

    def _load_config(self):
        try:"
286,apps/glance/glance/common/swift_store_utils.py,key,CONF.swift_store_key,swift_store_user,CONF.swift_store_user,"class SwiftParams(object):
    def __init__(self):
        if is_multiple_swift_store_accounts_enabled():
            self.params = self._load_config()
        else:
            self.params = self._form_default_params()

    def _form_default_params(self):
        default = {}
        if (CONF.swift_store_user and CONF.swift_store_key
           and CONF.swift_store_auth_address):
            default['user'] = CONF.swift_store_user
            default['key'] = CONF.swift_store_key
            default['auth_address'] = CONF.swift_store_auth_address
            return {CONF.default_swift_reference: default}
        return {}

    def _load_config(self):
        try:"
287,apps/glance/glance/common/swift_store_utils.py,key,CONF.swift_store_key,user,CONF.swift_store_user,"class SwiftParams(object):
    def __init__(self):
        if is_multiple_swift_store_accounts_enabled():
            self.params = self._load_config()
        else:
            self.params = self._form_default_params()

    def _form_default_params(self):
        default = {}
        if (CONF.swift_store_user and CONF.swift_store_key
           and CONF.swift_store_auth_address):
            default['user'] = CONF.swift_store_user
            default['key'] = CONF.swift_store_key
            default['auth_address'] = CONF.swift_store_auth_address
            return {CONF.default_swift_reference: default}
        return {}

    def _load_config(self):
        try:"
288,apps/glance/glance/common/swift_store_utils.py,swift_store_key,CONF.swift_store_key,swift_store_user,CONF.swift_store_user,"class SwiftParams(object):
    def __init__(self):
        if is_multiple_swift_store_accounts_enabled():
            self.params = self._load_config()
        else:
            self.params = self._form_default_params()

    def _form_default_params(self):
        default = {}
        if (CONF.swift_store_user and CONF.swift_store_key
           and CONF.swift_store_auth_address):
            default['user'] = CONF.swift_store_user
            default['key'] = CONF.swift_store_key
            default['auth_address'] = CONF.swift_store_auth_address
            return {CONF.default_swift_reference: default}
        return {}

    def _load_config(self):
        try:"
289,apps/glance/glance/common/swift_store_utils.py,swift_store_key,CONF.swift_store_key,user,CONF.swift_store_user,"class SwiftParams(object):
    def __init__(self):
        if is_multiple_swift_store_accounts_enabled():
            self.params = self._load_config()
        else:
            self.params = self._form_default_params()

    def _form_default_params(self):
        default = {}
        if (CONF.swift_store_user and CONF.swift_store_key
           and CONF.swift_store_auth_address):
            default['user'] = CONF.swift_store_user
            default['key'] = CONF.swift_store_key
            default['auth_address'] = CONF.swift_store_auth_address
            return {CONF.default_swift_reference: default}
        return {}

    def _load_config(self):
        try:"
290,apps/glance/glance/common/swift_store_utils.py,swift_store_user,CONF.swift_store_user,user,CONF.swift_store_user,"class SwiftParams(object):
    def __init__(self):
        if is_multiple_swift_store_accounts_enabled():
            self.params = self._load_config()
        else:
            self.params = self._form_default_params()

    def _form_default_params(self):
        default = {}
        if (CONF.swift_store_user and CONF.swift_store_key
           and CONF.swift_store_auth_address):
            default['user'] = CONF.swift_store_user
            default['key'] = CONF.swift_store_key
            default['auth_address'] = CONF.swift_store_auth_address
            return {CONF.default_swift_reference: default}
        return {}

    def _load_config(self):
        try:"
291,apps/glance/glance/common/swift_store_utils.py,auth_address,CONF.swift_store_auth_address,swift_store_auth_address,CONF.swift_store_auth_address,"class SwiftParams(object):
    def __init__(self):
        if is_multiple_swift_store_accounts_enabled():
            self.params = self._load_config()
        else:
            self.params = self._form_default_params()

    def _form_default_params(self):
        default = {}
        if (CONF.swift_store_user and CONF.swift_store_key
           and CONF.swift_store_auth_address):
            default['user'] = CONF.swift_store_user
            default['key'] = CONF.swift_store_key
            default['auth_address'] = CONF.swift_store_auth_address
            return {CONF.default_swift_reference: default}
        return {}

    def _load_config(self):
        try:
            conf_file = CONF.find_file(CONF.swift_store_config_file)"
292,apps/glance/glance/common/swift_store_utils.py,swift_store_user,CONF.swift_store_user,user,CONF.swift_store_user,"def __init__(self):
        if is_multiple_swift_store_accounts_enabled():
            self.params = self._load_config()
        else:
            self.params = self._form_default_params()

    def _form_default_params(self):
        default = {}
        if (CONF.swift_store_user and CONF.swift_store_key
           and CONF.swift_store_auth_address):
            default['user'] = CONF.swift_store_user
            default['key'] = CONF.swift_store_key
            default['auth_address'] = CONF.swift_store_auth_address
            return {CONF.default_swift_reference: default}
        return {}

    def _load_config(self):
        try:
            conf_file = CONF.find_file(CONF.swift_store_config_file)
            CONFIG.read(conf_file)"
293,apps/glance/glance/common/swift_store_utils.py,key,CONF.swift_store_key,swift_store_key,CONF.swift_store_key,"if is_multiple_swift_store_accounts_enabled():
            self.params = self._load_config()
        else:
            self.params = self._form_default_params()

    def _form_default_params(self):
        default = {}
        if (CONF.swift_store_user and CONF.swift_store_key
           and CONF.swift_store_auth_address):
            default['user'] = CONF.swift_store_user
            default['key'] = CONF.swift_store_key
            default['auth_address'] = CONF.swift_store_auth_address
            return {CONF.default_swift_reference: default}
        return {}

    def _load_config(self):
        try:
            conf_file = CONF.find_file(CONF.swift_store_config_file)
            CONFIG.read(conf_file)
        except Exception as e:"
294,apps/glance/glance/common/swift_store_utils.py,auth_address,CONF.swift_store_auth_address,swift_store_auth_address,CONF.swift_store_auth_address,"self.params = self._load_config()
        else:
            self.params = self._form_default_params()

    def _form_default_params(self):
        default = {}
        if (CONF.swift_store_user and CONF.swift_store_key
           and CONF.swift_store_auth_address):
            default['user'] = CONF.swift_store_user
            default['key'] = CONF.swift_store_key
            default['auth_address'] = CONF.swift_store_auth_address
            return {CONF.default_swift_reference: default}
        return {}

    def _load_config(self):
        try:
            conf_file = CONF.find_file(CONF.swift_store_config_file)
            CONFIG.read(conf_file)
        except Exception as e:
            msg = (_LE(""swift config file %(conf_file)s:%(exc)s not found"") %"
295,apps/glance/glance/common/swift_store_utils.py,key,CONF.swift_store_key,swift_store_key,CONF.swift_store_key,"if (CONF.swift_store_user and CONF.swift_store_key
           and CONF.swift_store_auth_address):
            default['user'] = CONF.swift_store_user
            default['key'] = CONF.swift_store_key
            default['auth_address'] = CONF.swift_store_auth_address
            return {CONF.default_swift_reference: default}"
296,apps/glance/glance/common/swift_store_utils.py,key,CONF.swift_store_key,swift_store_user,CONF.swift_store_user,"if (CONF.swift_store_user and CONF.swift_store_key
           and CONF.swift_store_auth_address):
            default['user'] = CONF.swift_store_user
            default['key'] = CONF.swift_store_key
            default['auth_address'] = CONF.swift_store_auth_address
            return {CONF.default_swift_reference: default}"
297,apps/glance/glance/common/swift_store_utils.py,key,CONF.swift_store_key,user,CONF.swift_store_user,"if (CONF.swift_store_user and CONF.swift_store_key
           and CONF.swift_store_auth_address):
            default['user'] = CONF.swift_store_user
            default['key'] = CONF.swift_store_key
            default['auth_address'] = CONF.swift_store_auth_address
            return {CONF.default_swift_reference: default}"
298,apps/glance/glance/common/swift_store_utils.py,swift_store_key,CONF.swift_store_key,swift_store_user,CONF.swift_store_user,"if (CONF.swift_store_user and CONF.swift_store_key
           and CONF.swift_store_auth_address):
            default['user'] = CONF.swift_store_user
            default['key'] = CONF.swift_store_key
            default['auth_address'] = CONF.swift_store_auth_address
            return {CONF.default_swift_reference: default}"
299,apps/glance/glance/common/swift_store_utils.py,swift_store_key,CONF.swift_store_key,user,CONF.swift_store_user,"if (CONF.swift_store_user and CONF.swift_store_key
           and CONF.swift_store_auth_address):
            default['user'] = CONF.swift_store_user
            default['key'] = CONF.swift_store_key
            default['auth_address'] = CONF.swift_store_auth_address
            return {CONF.default_swift_reference: default}"
300,apps/glance/glance/common/swift_store_utils.py,swift_store_user,CONF.swift_store_user,user,CONF.swift_store_user,"if (CONF.swift_store_user and CONF.swift_store_key
           and CONF.swift_store_auth_address):
            default['user'] = CONF.swift_store_user
            default['key'] = CONF.swift_store_key
            default['auth_address'] = CONF.swift_store_auth_address
            return {CONF.default_swift_reference: default}"
301,apps/glance/glance/common/swift_store_utils.py,auth_address,CONF.swift_store_auth_address,key,CONF.swift_store_key,"if (CONF.swift_store_user and CONF.swift_store_key
           and CONF.swift_store_auth_address):
            default['user'] = CONF.swift_store_user
            default['key'] = CONF.swift_store_key
            default['auth_address'] = CONF.swift_store_auth_address
            return {CONF.default_swift_reference: default}"
302,apps/glance/glance/common/swift_store_utils.py,auth_address,CONF.swift_store_auth_address,swift_store_key,CONF.swift_store_key,"if (CONF.swift_store_user and CONF.swift_store_key
           and CONF.swift_store_auth_address):
            default['user'] = CONF.swift_store_user
            default['key'] = CONF.swift_store_key
            default['auth_address'] = CONF.swift_store_auth_address
            return {CONF.default_swift_reference: default}"
303,apps/glance/glance/common/swift_store_utils.py,auth_address,CONF.swift_store_auth_address,swift_store_user,CONF.swift_store_user,"if (CONF.swift_store_user and CONF.swift_store_key
           and CONF.swift_store_auth_address):
            default['user'] = CONF.swift_store_user
            default['key'] = CONF.swift_store_key
            default['auth_address'] = CONF.swift_store_auth_address
            return {CONF.default_swift_reference: default}"
304,apps/glance/glance/common/swift_store_utils.py,auth_address,CONF.swift_store_auth_address,user,CONF.swift_store_user,"if (CONF.swift_store_user and CONF.swift_store_key
           and CONF.swift_store_auth_address):
            default['user'] = CONF.swift_store_user
            default['key'] = CONF.swift_store_key
            default['auth_address'] = CONF.swift_store_auth_address
            return {CONF.default_swift_reference: default}"
305,apps/glance/glance/common/swift_store_utils.py,default_swift_reference,CONF.default_swift_reference,swift_store_key,CONF.swift_store_key,"if (CONF.swift_store_user and CONF.swift_store_key
           and CONF.swift_store_auth_address):
            default['user'] = CONF.swift_store_user
            default['key'] = CONF.swift_store_key
            default['auth_address'] = CONF.swift_store_auth_address
            return {CONF.default_swift_reference: default}"
306,apps/glance/glance/common/swift_store_utils.py,default_swift_reference,CONF.default_swift_reference,swift_store_user,CONF.swift_store_user,"if (CONF.swift_store_user and CONF.swift_store_key
           and CONF.swift_store_auth_address):
            default['user'] = CONF.swift_store_user
            default['key'] = CONF.swift_store_key
            default['auth_address'] = CONF.swift_store_auth_address
            return {CONF.default_swift_reference: default}"
307,apps/glance/glance/common/swift_store_utils.py,key,CONF.swift_store_key,swift_store_auth_address,CONF.swift_store_auth_address,"if (CONF.swift_store_user and CONF.swift_store_key
           and CONF.swift_store_auth_address):
            default['user'] = CONF.swift_store_user
            default['key'] = CONF.swift_store_key
            default['auth_address'] = CONF.swift_store_auth_address
            return {CONF.default_swift_reference: default}"
308,apps/glance/glance/common/swift_store_utils.py,swift_store_auth_address,CONF.swift_store_auth_address,swift_store_key,CONF.swift_store_key,"if (CONF.swift_store_user and CONF.swift_store_key
           and CONF.swift_store_auth_address):
            default['user'] = CONF.swift_store_user
            default['key'] = CONF.swift_store_key
            default['auth_address'] = CONF.swift_store_auth_address
            return {CONF.default_swift_reference: default}"
309,apps/glance/glance/common/swift_store_utils.py,swift_store_auth_address,CONF.swift_store_auth_address,swift_store_user,CONF.swift_store_user,"if (CONF.swift_store_user and CONF.swift_store_key
           and CONF.swift_store_auth_address):
            default['user'] = CONF.swift_store_user
            default['key'] = CONF.swift_store_key
            default['auth_address'] = CONF.swift_store_auth_address
            return {CONF.default_swift_reference: default}"
310,apps/glance/glance/common/swift_store_utils.py,swift_store_auth_address,CONF.swift_store_auth_address,user,CONF.swift_store_user,"if (CONF.swift_store_user and CONF.swift_store_key
           and CONF.swift_store_auth_address):
            default['user'] = CONF.swift_store_user
            default['key'] = CONF.swift_store_key
            default['auth_address'] = CONF.swift_store_auth_address
            return {CONF.default_swift_reference: default}"
311,apps/glance/glance/common/swift_store_utils.py,auth_address,CONF.swift_store_auth_address,swift_store_auth_address,CONF.swift_store_auth_address,"if (CONF.swift_store_user and CONF.swift_store_key
           and CONF.swift_store_auth_address):
            default['user'] = CONF.swift_store_user
            default['key'] = CONF.swift_store_key
            default['auth_address'] = CONF.swift_store_auth_address
            return {CONF.default_swift_reference: default}"
312,apps/glance/glance/common/swift_store_utils.py,default_swift_reference,CONF.default_swift_reference,swift_store_auth_address,CONF.swift_store_auth_address,"if (CONF.swift_store_user and CONF.swift_store_key
           and CONF.swift_store_auth_address):
            default['user'] = CONF.swift_store_user
            default['key'] = CONF.swift_store_key
            default['auth_address'] = CONF.swift_store_auth_address
            return {CONF.default_swift_reference: default}"
313,apps/glance/glance/common/swift_store_utils.py,default_swift_reference,CONF.default_swift_reference,key,CONF.swift_store_key,"if (CONF.swift_store_user and CONF.swift_store_key
           and CONF.swift_store_auth_address):
            default['user'] = CONF.swift_store_user
            default['key'] = CONF.swift_store_key
            default['auth_address'] = CONF.swift_store_auth_address
            return {CONF.default_swift_reference: default}"
314,apps/glance/glance/common/swift_store_utils.py,default_swift_reference,CONF.default_swift_reference,user,CONF.swift_store_user,"if (CONF.swift_store_user and CONF.swift_store_key
           and CONF.swift_store_auth_address):
            default['user'] = CONF.swift_store_user
            default['key'] = CONF.swift_store_key
            default['auth_address'] = CONF.swift_store_auth_address
            return {CONF.default_swift_reference: default}"
315,apps/glance/glance/common/swift_store_utils.py,auth_address,CONF.swift_store_auth_address,default_swift_reference,CONF.default_swift_reference,"if (CONF.swift_store_user and CONF.swift_store_key
           and CONF.swift_store_auth_address):
            default['user'] = CONF.swift_store_user
            default['key'] = CONF.swift_store_key
            default['auth_address'] = CONF.swift_store_auth_address
            return {CONF.default_swift_reference: default}"
316,apps/glance/glance/common/utils.py,backlog,stash_conf_values.CONF.backlog,bind_host,stash_conf_values.CONF.bind_host,"return f(*args, **kwargs)
    return wrapper


def stash_conf_values():
    """"""
    Make a copy of some of the current global CONF's settings.
    Allows determining if any of these values have changed
    when the config is reloaded.
    """"""
    conf = {
        'bind_host': CONF.bind_host,
        'bind_port': CONF.bind_port,
        'backlog': CONF.backlog,
    }

    return conf


def split_filter_op(expression):"
317,apps/glance/glance/common/utils.py,backlog,stash_conf_values.CONF.backlog,bind_port,stash_conf_values.CONF.bind_port,"return f(*args, **kwargs)
    return wrapper


def stash_conf_values():
    """"""
    Make a copy of some of the current global CONF's settings.
    Allows determining if any of these values have changed
    when the config is reloaded.
    """"""
    conf = {
        'bind_host': CONF.bind_host,
        'bind_port': CONF.bind_port,
        'backlog': CONF.backlog,
    }

    return conf


def split_filter_op(expression):"
318,apps/glance/glance/common/utils.py,bind_host,stash_conf_values.CONF.bind_host,bind_port,stash_conf_values.CONF.bind_port,"return f(*args, **kwargs)
    return wrapper


def stash_conf_values():
    """"""
    Make a copy of some of the current global CONF's settings.
    Allows determining if any of these values have changed
    when the config is reloaded.
    """"""
    conf = {
        'bind_host': CONF.bind_host,
        'bind_port': CONF.bind_port,
        'backlog': CONF.backlog,
    }

    return conf


def split_filter_op(expression):"
319,apps/glance/glance/common/utils.py,backlog,stash_conf_values.conf,bind_host,stash_conf_values.conf,"Make a copy of some of the current global CONF's settings.
    Allows determining if any of these values have changed
    when the config is reloaded.
    """"""
    conf = {
        'bind_host': CONF.bind_host,
        'bind_port': CONF.bind_port,
        'backlog': CONF.backlog,
    }

    return conf


def split_filter_op(expression):
    """"""Split operator from threshold in an expression.
    Designed for use on a comparative-filtering query field.
    When no operator is found, default to an equality comparison.

    :param expression: the expression to parse"
320,apps/glance/glance/common/utils.py,backlog,stash_conf_values.conf,bind_port,stash_conf_values.conf,"Make a copy of some of the current global CONF's settings.
    Allows determining if any of these values have changed
    when the config is reloaded.
    """"""
    conf = {
        'bind_host': CONF.bind_host,
        'bind_port': CONF.bind_port,
        'backlog': CONF.backlog,
    }

    return conf


def split_filter_op(expression):
    """"""Split operator from threshold in an expression.
    Designed for use on a comparative-filtering query field.
    When no operator is found, default to an equality comparison.

    :param expression: the expression to parse"
321,apps/glance/glance/common/utils.py,bind_host,stash_conf_values.conf,bind_port,stash_conf_values.conf,"Make a copy of some of the current global CONF's settings.
    Allows determining if any of these values have changed
    when the config is reloaded.
    """"""
    conf = {
        'bind_host': CONF.bind_host,
        'bind_port': CONF.bind_port,
        'backlog': CONF.backlog,
    }

    return conf


def split_filter_op(expression):
    """"""Split operator from threshold in an expression.
    Designed for use on a comparative-filtering query field.
    When no operator is found, default to an equality comparison.

    :param expression: the expression to parse"
322,apps/glance/glance/common/utils.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"elif operator == 'neq':
        return value != threshold
    elif operator == 'eq':
        return value == threshold

    msg = _(""Unable to filter on a unknown operator."")
    raise exception.InvalidFilterOperatorValue(msg)


def _get_available_stores():
    available_stores = CONF.enabled_backends
    stores = []
    # Remove reserved stores from the available stores list
    for store in available_stores:
        # NOTE (abhishekk): http store is readonly and should be
        # excluded from the list.
        if available_stores[store] == 'http':
            continue
        if store not in wsgi.RESERVED_STORES:
            stores.append(store)"
323,apps/glance/glance/common/utils.py,enabled,CONF.enabled_backends,enabled_backends,_get_available_stores.CONF.enabled_backends,"elif operator == 'neq':
        return value != threshold
    elif operator == 'eq':
        return value == threshold

    msg = _(""Unable to filter on a unknown operator."")
    raise exception.InvalidFilterOperatorValue(msg)


def _get_available_stores():
    available_stores = CONF.enabled_backends
    stores = []
    # Remove reserved stores from the available stores list
    for store in available_stores:
        # NOTE (abhishekk): http store is readonly and should be
        # excluded from the list.
        if available_stores[store] == 'http':
            continue
        if store not in wsgi.RESERVED_STORES:
            stores.append(store)"
324,apps/glance/glance/common/utils.py,enabled,_get_available_stores.CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"elif operator == 'neq':
        return value != threshold
    elif operator == 'eq':
        return value == threshold

    msg = _(""Unable to filter on a unknown operator."")
    raise exception.InvalidFilterOperatorValue(msg)


def _get_available_stores():
    available_stores = CONF.enabled_backends
    stores = []
    # Remove reserved stores from the available stores list
    for store in available_stores:
        # NOTE (abhishekk): http store is readonly and should be
        # excluded from the list.
        if available_stores[store] == 'http':
            continue
        if store not in wsgi.RESERVED_STORES:
            stores.append(store)"
325,apps/glance/glance/common/utils.py,enabled,_get_available_stores.CONF.enabled_backends,enabled_backends,_get_available_stores.CONF.enabled_backends,"elif operator == 'neq':
        return value != threshold
    elif operator == 'eq':
        return value == threshold

    msg = _(""Unable to filter on a unknown operator."")
    raise exception.InvalidFilterOperatorValue(msg)


def _get_available_stores():
    available_stores = CONF.enabled_backends
    stores = []
    # Remove reserved stores from the available stores list
    for store in available_stores:
        # NOTE (abhishekk): http store is readonly and should be
        # excluded from the list.
        if available_stores[store] == 'http':
            continue
        if store not in wsgi.RESERVED_STORES:
            stores.append(store)"
326,apps/glance/glance/common/utils.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"msg = _(""Stores parameter and x-image-meta-store header can't ""
                        ""be both specified"")
                raise exc.HTTPBadRequest(explanation=msg)
    # Validate each store
    for store in stores:
        glance_store.get_store_from_store_identifier(store)
    return stores


def sort_image_locations(locations):
    if not CONF.enabled_backends:
        return locations

    def get_store_weight(location):
        store_id = location['metadata'].get('store')
        if not store_id:
            return 0
        try:
            return glance_store.get_store_weight(store_id)
        except glance_store.exceptions.UnknownScheme:"
327,apps/glance/glance/common/utils.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"scrubbed.append({'store_name': loc[""metadata""].get(""store"")})

    LOG.debug(('Sorted locations: %s'), scrubbed)
    return sorted_locations


def is_http_store_configured(url):
    if not url.startswith(""http""):
        return False

    enabled_backends = CONF.enabled_backends
    if enabled_backends:
        return 'http' in enabled_backends.values()
    else:
        return 'http' in CONF.glance_store.stores"
328,apps/glance/glance/common/utils.py,enabled,CONF.enabled_backends,enabled_backends,is_http_store_configured.CONF.enabled_backends,"scrubbed.append({'store_name': loc[""metadata""].get(""store"")})

    LOG.debug(('Sorted locations: %s'), scrubbed)
    return sorted_locations


def is_http_store_configured(url):
    if not url.startswith(""http""):
        return False

    enabled_backends = CONF.enabled_backends
    if enabled_backends:
        return 'http' in enabled_backends.values()
    else:
        return 'http' in CONF.glance_store.stores"
329,apps/glance/glance/common/utils.py,enabled,is_http_store_configured.CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"scrubbed.append({'store_name': loc[""metadata""].get(""store"")})

    LOG.debug(('Sorted locations: %s'), scrubbed)
    return sorted_locations


def is_http_store_configured(url):
    if not url.startswith(""http""):
        return False

    enabled_backends = CONF.enabled_backends
    if enabled_backends:
        return 'http' in enabled_backends.values()
    else:
        return 'http' in CONF.glance_store.stores"
330,apps/glance/glance/common/utils.py,enabled,is_http_store_configured.CONF.enabled_backends,enabled_backends,is_http_store_configured.CONF.enabled_backends,"scrubbed.append({'store_name': loc[""metadata""].get(""store"")})

    LOG.debug(('Sorted locations: %s'), scrubbed)
    return sorted_locations


def is_http_store_configured(url):
    if not url.startswith(""http""):
        return False

    enabled_backends = CONF.enabled_backends
    if enabled_backends:
        return 'http' in enabled_backends.values()
    else:
        return 'http' in CONF.glance_store.stores"
331,apps/glance/glance/common/utils.py,enabled,enabled_backends.values,enabled_backends,enabled_backends.values,"LOG.debug(('Sorted locations: %s'), scrubbed)
    return sorted_locations


def is_http_store_configured(url):
    if not url.startswith(""http""):
        return False

    enabled_backends = CONF.enabled_backends
    if enabled_backends:
        return 'http' in enabled_backends.values()
    else:
        return 'http' in CONF.glance_store.stores"
332,apps/glance/glance/common/utils.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"if not CONF.enabled_backends:
        return locations"
333,apps/glance/glance/common/utils.py,enabled,enabled_backends.values,enabled_backends,enabled_backends.values,"if enabled_backends:
        return 'http' in enabled_backends.values()
    else:
        return 'http' in CONF.glance_store.stores"
334,apps/glance/glance/common/wsgi.py,bind_host,CONF.bind_host,bind_port,CONF.bind_port,"if CONF.workers is None:
        # None implies the number of CPUs limited to 8
        # See Launchpad bug #1748916 and the config help text
        workers = processutils.get_worker_count()
        return workers if workers < 8 else 8
    return CONF.workers


def get_bind_addr(default_port=None):
    """"""Return the host and port to bind to.""""""
    return (CONF.bind_host, CONF.bind_port or default_port)


def get_socket(default_port):
    """"""
    Bind socket to bind ip:port in conf

    note: Mostly comes from Swift with a few small changes...

    :param default_port: port to bind to if none is specified in conf"
335,apps/glance/glance/common/wsgi.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"def configure(self, old_conf=None, has_changed=None):
        """"""
        Apply configuration settings

        :param old_conf: Cached old configuration settings (if any)
        :param has_changed: callable to determine if a parameter has changed
        """"""
        eventlet.wsgi.MAX_HEADER_LINE = CONF.max_header_line
        self.client_socket_timeout = CONF.client_socket_timeout or None
        if self.initialize_glance_store:
            if CONF.enabled_backends:
                if store_utils.check_reserved_stores(CONF.enabled_backends):
                    msg = _(""'os_glance_' prefix should not be used in ""
                            ""enabled_backends config option. It is reserved ""
                            ""for internal use only."")
                    raise RuntimeError(msg)
                initialize_multi_store()
            else:
                initialize_glance_store()
        self.configure_socket(old_conf, has_changed)"
336,apps/glance/glance/common/wsgi.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"""""""
        Apply configuration settings

        :param old_conf: Cached old configuration settings (if any)
        :param has_changed: callable to determine if a parameter has changed
        """"""
        eventlet.wsgi.MAX_HEADER_LINE = CONF.max_header_line
        self.client_socket_timeout = CONF.client_socket_timeout or None
        if self.initialize_glance_store:
            if CONF.enabled_backends:
                if store_utils.check_reserved_stores(CONF.enabled_backends):
                    msg = _(""'os_glance_' prefix should not be used in ""
                            ""enabled_backends config option. It is reserved ""
                            ""for internal use only."")
                    raise RuntimeError(msg)
                initialize_multi_store()
            else:
                initialize_glance_store()
        self.configure_socket(old_conf, has_changed)"
337,apps/glance/glance/common/wsgi.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"if self.initialize_glance_store:
            if CONF.enabled_backends:
                if store_utils.check_reserved_stores(CONF.enabled_backends):
                    msg = _(""'os_glance_' prefix should not be used in ""
                            ""enabled_backends config option. It is reserved ""
                            ""for internal use only."")
                    raise RuntimeError(msg)
                initialize_multi_store()
            else:
                initialize_glance_store()"
338,apps/glance/glance/common/wsgi.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"if CONF.enabled_backends:
                if store_utils.check_reserved_stores(CONF.enabled_backends):
                    msg = _(""'os_glance_' prefix should not be used in ""
                            ""enabled_backends config option. It is reserved ""
                            ""for internal use only."")
                    raise RuntimeError(msg)
                initialize_multi_store()
            else:
                initialize_glance_store()"
339,apps/glance/glance/common/wsgi.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"if store_utils.check_reserved_stores(CONF.enabled_backends):
                    msg = _(""'os_glance_' prefix should not be used in ""
                            ""enabled_backends config option. It is reserved ""
                            ""for internal use only."")
                    raise RuntimeError(msg)"
340,apps/glance/glance/common/wsgi.py,client_socket_timeout,self.client_socket_timeout,http_keepalive,CONF.http_keepalive,"try:
            eventlet.wsgi.server(self.sock,
                                 self.application,
                                 log=self._logger,
                                 custom_pool=self.pool,
                                 debug=False,
                                 keepalive=CONF.http_keepalive,
                                 socket_timeout=self.client_socket_timeout)
        except socket.error as err:
            if err[0] != errno.EINVAL:
                raise"
341,apps/glance/glance/common/wsgi_app.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"else:
        atexit.register(drain_workers)

    # NOTE(danms): Change the default threadpool size since we
    # are dealing with native threads and not greenthreads.
    # Right now, the only pool of default size is tasks_pool,
    # so if others are created this will need to change to be
    # more specific.
    common.DEFAULT_POOL_SIZE = CONF.wsgi.task_pool_threads

    if CONF.enabled_backends:
        if store_utils.check_reserved_stores(CONF.enabled_backends):
            msg = _(""'os_glance_' prefix should not be used in ""
                    ""enabled_backends config option. It is reserved ""
                    ""for internal use only."")
            raise RuntimeError(msg)
        glance_store.register_store_opts(CONF, reserved_stores=RESERVED_STORES)
        glance_store.create_multi_stores(CONF, reserved_stores=RESERVED_STORES)
        glance_store.verify_store()
    else:"
342,apps/glance/glance/common/wsgi_app.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"atexit.register(drain_workers)

    # NOTE(danms): Change the default threadpool size since we
    # are dealing with native threads and not greenthreads.
    # Right now, the only pool of default size is tasks_pool,
    # so if others are created this will need to change to be
    # more specific.
    common.DEFAULT_POOL_SIZE = CONF.wsgi.task_pool_threads

    if CONF.enabled_backends:
        if store_utils.check_reserved_stores(CONF.enabled_backends):
            msg = _(""'os_glance_' prefix should not be used in ""
                    ""enabled_backends config option. It is reserved ""
                    ""for internal use only."")
            raise RuntimeError(msg)
        glance_store.register_store_opts(CONF, reserved_stores=RESERVED_STORES)
        glance_store.create_multi_stores(CONF, reserved_stores=RESERVED_STORES)
        glance_store.verify_store()
    else:
        glance_store.register_opts(CONF)"
343,apps/glance/glance/common/wsgi_app.py,bind_host,CONF.bind_host,enabled,CONF.profiler.enabled,"if CONF.profiler.enabled:
        osprofiler.initializer.init_from_conf(conf=CONF,
                                              context={},
                                              project='glance',
                                              service='api',
                                              host=CONF.bind_host)"
344,apps/glance/glance/common/wsgi_app.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"if CONF.enabled_backends:
        if store_utils.check_reserved_stores(CONF.enabled_backends):
            msg = _(""'os_glance_' prefix should not be used in ""
                    ""enabled_backends config option. It is reserved ""
                    ""for internal use only."")
            raise RuntimeError(msg)
        glance_store.register_store_opts(CONF, reserved_stores=RESERVED_STORES)
        glance_store.create_multi_stores(CONF, reserved_stores=RESERVED_STORES)
        glance_store.verify_store()
    else:
        glance_store.register_opts(CONF)
        glance_store.create_stores(CONF)
        glance_store.verify_default_store()"
345,apps/glance/glance/common/wsgi_app.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"if store_utils.check_reserved_stores(CONF.enabled_backends):
            msg = _(""'os_glance_' prefix should not be used in ""
                    ""enabled_backends config option. It is reserved ""
                    ""for internal use only."")
            raise RuntimeError(msg)"
346,apps/glance/glance/db/simple/api.py,key,image_get_all.images,user,image_get_all.admin_as_user,"return tasks


@log_call
def image_get_all(context, filters=None, marker=None, limit=None,
                  sort_key=None, sort_dir=None,
                  member_status='accepted', is_public=None,
                  admin_as_user=False, return_tag=False, v1_mode=False):
    filters = filters or {}
    images = DATA['images'].values()
    images = _filter_images(images, filters, context, member_status,
                            is_public, admin_as_user)
    images = _sort_images(images, sort_key, sort_dir)
    images = _do_pagination(context, images, marker, limit,
                            filters.get('deleted'))

    force_show_deleted = True if filters.get('deleted') else False
    res = []
    for image in images:
        img = _normalize_locations(context, copy.deepcopy(image),"
347,apps/glance/glance/db/simple/api.py,key,image_get_all.images,user,image_get_all.images,"return tasks


@log_call
def image_get_all(context, filters=None, marker=None, limit=None,
                  sort_key=None, sort_dir=None,
                  member_status='accepted', is_public=None,
                  admin_as_user=False, return_tag=False, v1_mode=False):
    filters = filters or {}
    images = DATA['images'].values()
    images = _filter_images(images, filters, context, member_status,
                            is_public, admin_as_user)
    images = _sort_images(images, sort_key, sort_dir)
    images = _do_pagination(context, images, marker, limit,
                            filters.get('deleted'))

    force_show_deleted = True if filters.get('deleted') else False
    res = []
    for image in images:
        img = _normalize_locations(context, copy.deepcopy(image),"
348,apps/glance/glance/db/simple/api.py,key,image_get_all.images,user,image_get_all.images,"@log_call
def image_get_all(context, filters=None, marker=None, limit=None,
                  sort_key=None, sort_dir=None,
                  member_status='accepted', is_public=None,
                  admin_as_user=False, return_tag=False, v1_mode=False):
    filters = filters or {}
    images = DATA['images'].values()
    images = _filter_images(images, filters, context, member_status,
                            is_public, admin_as_user)
    images = _sort_images(images, sort_key, sort_dir)
    images = _do_pagination(context, images, marker, limit,
                            filters.get('deleted'))

    force_show_deleted = True if filters.get('deleted') else False
    res = []
    for image in images:
        img = _normalize_locations(context, copy.deepcopy(image),
                                   force_show_deleted=force_show_deleted)
        if return_tag:"
349,apps/glance/glance/db/simple/api.py,key,image_get_all.sort_key,user,image_get_all.images,"@log_call
def image_get_all(context, filters=None, marker=None, limit=None,
                  sort_key=None, sort_dir=None,
                  member_status='accepted', is_public=None,
                  admin_as_user=False, return_tag=False, v1_mode=False):
    filters = filters or {}
    images = DATA['images'].values()
    images = _filter_images(images, filters, context, member_status,
                            is_public, admin_as_user)
    images = _sort_images(images, sort_key, sort_dir)
    images = _do_pagination(context, images, marker, limit,
                            filters.get('deleted'))

    force_show_deleted = True if filters.get('deleted') else False
    res = []
    for image in images:
        img = _normalize_locations(context, copy.deepcopy(image),
                                   force_show_deleted=force_show_deleted)
        if return_tag:"
350,apps/glance/glance/db/simple/api.py,key,image_get_all.images,user,image_get_all.images,"@log_call
def image_get_all(context, filters=None, marker=None, limit=None,
                  sort_key=None, sort_dir=None,
                  member_status='accepted', is_public=None,
                  admin_as_user=False, return_tag=False, v1_mode=False):
    filters = filters or {}
    images = DATA['images'].values()
    images = _filter_images(images, filters, context, member_status,
                            is_public, admin_as_user)
    images = _sort_images(images, sort_key, sort_dir)
    images = _do_pagination(context, images, marker, limit,
                            filters.get('deleted'))

    force_show_deleted = True if filters.get('deleted') else False
    res = []
    for image in images:
        img = _normalize_locations(context, copy.deepcopy(image),
                                   force_show_deleted=force_show_deleted)
        if return_tag:
            img['tags'] = image_tag_get_all(context, img['id'])"
351,apps/glance/glance/db/simple/api.py,key,_filter_images.key,user,_filter_images.admin_as_user,"for image in images:
        member = image_member_find(context, image_id=image['id'],
                                   member=context.owner, status=status)
        is_member = len(member) > 0
        has_ownership = context.owner and image['owner'] == context.owner
        image_is_public = image['visibility'] == 'public'
        image_is_community = image['visibility'] == 'community'
        image_is_shared = image['visibility'] == 'shared'
        image_is_hidden = image['os_hidden'] == True
        acts_as_admin = context.is_admin and not admin_as_user
        can_see = (image_is_public
                   or image_is_community
                   or has_ownership
                   or (is_member and image_is_shared)
                   or acts_as_admin)
        if not can_see:
            continue

        if visibility:
            if visibility == 'public':
                if not image_is_public:
                    continue
            elif visibility == 'private':
                if not (image['visibility'] == 'private'):
                    continue
                if not (has_ownership or acts_as_admin):
                    continue
            elif visibility == 'shared':
                if not image_is_shared:
                    continue
            elif visibility == 'community':
                if not image_is_community:
                    continue
        else:
            if (not has_ownership) and image_is_community:
                continue

        if is_public is not None:
            if not image_is_public == is_public:
                continue

        if os_hidden:
            if image_is_hidden:
                continue

        to_add = True
        for k, value in filters.items():
            key = k
            if k.endswith('_min') or k.endswith('_max'):
                key = key[0:-4]
                try:
                    value = int(value)
                except ValueError:
                    msg = _(""Unable to filter on a range ""
                            ""with a non-numeric value."")
                    raise exception.InvalidFilterRangeValue(msg)
            if k.endswith('_min'):
                to_add = image.get(key) >= value
            elif k.endswith('_max'):
                to_add = image.get(key) <= value
            elif k in ['created_at', 'updated_at']:
                attr_value = image.get(key)
                operator, isotime = utils.split_filter_op(value)
                parsed_time = oslo_timeutils.parse_isotime(isotime)
                threshold = oslo_timeutils.normalize_time(parsed_time)
                to_add = utils.evaluate_filter_op(attr_value, operator,
                                                  threshold)
            elif k in ['name', 'id', 'status',
                       'container_format', 'disk_format']:
                attr_value = image.get(key)
                operator, list_value = utils.split_filter_op(value)
                if operator == 'in':
                    threshold = utils.split_filter_value_for_quotes(list_value)
                    to_add = attr_value in threshold
                elif operator == 'eq':
                    to_add = (attr_value == list_value)
                else:
                    msg = (_(""Unable to filter by unknown operator '%s'."")
                           % operator)
                    raise exception.InvalidFilterOperatorValue(msg)

            elif k != 'is_public' and image.get(k) is not None:
                to_add = image.get(key) == value
            elif k == 'tags':
                filter_tags = value
                image_tags = image_tag_get_all(context, image['id'])
                for tag in filter_tags:
                    if tag not in image_tags:
                        to_add = False
                        break
            else:
                to_add = False
                for p in image['properties']:
                    properties = {p['name']: p['value'],
                                  'deleted': p['deleted']}
                    to_add |= (properties.get(key) == value and
                               properties.get('deleted') is False)

            if not to_add:
                break

        if to_add:
            filtered_images.append(image)"
352,apps/glance/glance/db/simple/api.py,key,_filter_images.attr_value,user,_filter_images.admin_as_user,"for image in images:
        member = image_member_find(context, image_id=image['id'],
                                   member=context.owner, status=status)
        is_member = len(member) > 0
        has_ownership = context.owner and image['owner'] == context.owner
        image_is_public = image['visibility'] == 'public'
        image_is_community = image['visibility'] == 'community'
        image_is_shared = image['visibility'] == 'shared'
        image_is_hidden = image['os_hidden'] == True
        acts_as_admin = context.is_admin and not admin_as_user
        can_see = (image_is_public
                   or image_is_community
                   or has_ownership
                   or (is_member and image_is_shared)
                   or acts_as_admin)
        if not can_see:
            continue

        if visibility:
            if visibility == 'public':
                if not image_is_public:
                    continue
            elif visibility == 'private':
                if not (image['visibility'] == 'private'):
                    continue
                if not (has_ownership or acts_as_admin):
                    continue
            elif visibility == 'shared':
                if not image_is_shared:
                    continue
            elif visibility == 'community':
                if not image_is_community:
                    continue
        else:
            if (not has_ownership) and image_is_community:
                continue

        if is_public is not None:
            if not image_is_public == is_public:
                continue

        if os_hidden:
            if image_is_hidden:
                continue

        to_add = True
        for k, value in filters.items():
            key = k
            if k.endswith('_min') or k.endswith('_max'):
                key = key[0:-4]
                try:
                    value = int(value)
                except ValueError:
                    msg = _(""Unable to filter on a range ""
                            ""with a non-numeric value."")
                    raise exception.InvalidFilterRangeValue(msg)
            if k.endswith('_min'):
                to_add = image.get(key) >= value
            elif k.endswith('_max'):
                to_add = image.get(key) <= value
            elif k in ['created_at', 'updated_at']:
                attr_value = image.get(key)
                operator, isotime = utils.split_filter_op(value)
                parsed_time = oslo_timeutils.parse_isotime(isotime)
                threshold = oslo_timeutils.normalize_time(parsed_time)
                to_add = utils.evaluate_filter_op(attr_value, operator,
                                                  threshold)
            elif k in ['name', 'id', 'status',
                       'container_format', 'disk_format']:
                attr_value = image.get(key)
                operator, list_value = utils.split_filter_op(value)
                if operator == 'in':
                    threshold = utils.split_filter_value_for_quotes(list_value)
                    to_add = attr_value in threshold
                elif operator == 'eq':
                    to_add = (attr_value == list_value)
                else:
                    msg = (_(""Unable to filter by unknown operator '%s'."")
                           % operator)
                    raise exception.InvalidFilterOperatorValue(msg)

            elif k != 'is_public' and image.get(k) is not None:
                to_add = image.get(key) == value
            elif k == 'tags':
                filter_tags = value
                image_tags = image_tag_get_all(context, image['id'])
                for tag in filter_tags:
                    if tag not in image_tags:
                        to_add = False
                        break
            else:
                to_add = False
                for p in image['properties']:
                    properties = {p['name']: p['value'],
                                  'deleted': p['deleted']}
                    to_add |= (properties.get(key) == value and
                               properties.get('deleted') is False)

            if not to_add:
                break

        if to_add:
            filtered_images.append(image)"
353,apps/glance/glance/db/simple/api.py,key,_filter_images.key,user,_filter_images.acts_as_admin,"for image in images:
        member = image_member_find(context, image_id=image['id'],
                                   member=context.owner, status=status)
        is_member = len(member) > 0
        has_ownership = context.owner and image['owner'] == context.owner
        image_is_public = image['visibility'] == 'public'
        image_is_community = image['visibility'] == 'community'
        image_is_shared = image['visibility'] == 'shared'
        image_is_hidden = image['os_hidden'] == True
        acts_as_admin = context.is_admin and not admin_as_user
        can_see = (image_is_public
                   or image_is_community
                   or has_ownership
                   or (is_member and image_is_shared)
                   or acts_as_admin)
        if not can_see:
            continue

        if visibility:
            if visibility == 'public':
                if not image_is_public:
                    continue
            elif visibility == 'private':
                if not (image['visibility'] == 'private'):
                    continue
                if not (has_ownership or acts_as_admin):
                    continue
            elif visibility == 'shared':
                if not image_is_shared:
                    continue
            elif visibility == 'community':
                if not image_is_community:
                    continue
        else:
            if (not has_ownership) and image_is_community:
                continue

        if is_public is not None:
            if not image_is_public == is_public:
                continue

        if os_hidden:
            if image_is_hidden:
                continue

        to_add = True
        for k, value in filters.items():
            key = k
            if k.endswith('_min') or k.endswith('_max'):
                key = key[0:-4]
                try:
                    value = int(value)
                except ValueError:
                    msg = _(""Unable to filter on a range ""
                            ""with a non-numeric value."")
                    raise exception.InvalidFilterRangeValue(msg)
            if k.endswith('_min'):
                to_add = image.get(key) >= value
            elif k.endswith('_max'):
                to_add = image.get(key) <= value
            elif k in ['created_at', 'updated_at']:
                attr_value = image.get(key)
                operator, isotime = utils.split_filter_op(value)
                parsed_time = oslo_timeutils.parse_isotime(isotime)
                threshold = oslo_timeutils.normalize_time(parsed_time)
                to_add = utils.evaluate_filter_op(attr_value, operator,
                                                  threshold)
            elif k in ['name', 'id', 'status',
                       'container_format', 'disk_format']:
                attr_value = image.get(key)
                operator, list_value = utils.split_filter_op(value)
                if operator == 'in':
                    threshold = utils.split_filter_value_for_quotes(list_value)
                    to_add = attr_value in threshold
                elif operator == 'eq':
                    to_add = (attr_value == list_value)
                else:
                    msg = (_(""Unable to filter by unknown operator '%s'."")
                           % operator)
                    raise exception.InvalidFilterOperatorValue(msg)

            elif k != 'is_public' and image.get(k) is not None:
                to_add = image.get(key) == value
            elif k == 'tags':
                filter_tags = value
                image_tags = image_tag_get_all(context, image['id'])
                for tag in filter_tags:
                    if tag not in image_tags:
                        to_add = False
                        break
            else:
                to_add = False
                for p in image['properties']:
                    properties = {p['name']: p['value'],
                                  'deleted': p['deleted']}
                    to_add |= (properties.get(key) == value and
                               properties.get('deleted') is False)

            if not to_add:
                break

        if to_add:
            filtered_images.append(image)"
354,apps/glance/glance/db/simple/api.py,key,_filter_images.attr_value,user,_filter_images.acts_as_admin,"for image in images:
        member = image_member_find(context, image_id=image['id'],
                                   member=context.owner, status=status)
        is_member = len(member) > 0
        has_ownership = context.owner and image['owner'] == context.owner
        image_is_public = image['visibility'] == 'public'
        image_is_community = image['visibility'] == 'community'
        image_is_shared = image['visibility'] == 'shared'
        image_is_hidden = image['os_hidden'] == True
        acts_as_admin = context.is_admin and not admin_as_user
        can_see = (image_is_public
                   or image_is_community
                   or has_ownership
                   or (is_member and image_is_shared)
                   or acts_as_admin)
        if not can_see:
            continue

        if visibility:
            if visibility == 'public':
                if not image_is_public:
                    continue
            elif visibility == 'private':
                if not (image['visibility'] == 'private'):
                    continue
                if not (has_ownership or acts_as_admin):
                    continue
            elif visibility == 'shared':
                if not image_is_shared:
                    continue
            elif visibility == 'community':
                if not image_is_community:
                    continue
        else:
            if (not has_ownership) and image_is_community:
                continue

        if is_public is not None:
            if not image_is_public == is_public:
                continue

        if os_hidden:
            if image_is_hidden:
                continue

        to_add = True
        for k, value in filters.items():
            key = k
            if k.endswith('_min') or k.endswith('_max'):
                key = key[0:-4]
                try:
                    value = int(value)
                except ValueError:
                    msg = _(""Unable to filter on a range ""
                            ""with a non-numeric value."")
                    raise exception.InvalidFilterRangeValue(msg)
            if k.endswith('_min'):
                to_add = image.get(key) >= value
            elif k.endswith('_max'):
                to_add = image.get(key) <= value
            elif k in ['created_at', 'updated_at']:
                attr_value = image.get(key)
                operator, isotime = utils.split_filter_op(value)
                parsed_time = oslo_timeutils.parse_isotime(isotime)
                threshold = oslo_timeutils.normalize_time(parsed_time)
                to_add = utils.evaluate_filter_op(attr_value, operator,
                                                  threshold)
            elif k in ['name', 'id', 'status',
                       'container_format', 'disk_format']:
                attr_value = image.get(key)
                operator, list_value = utils.split_filter_op(value)
                if operator == 'in':
                    threshold = utils.split_filter_value_for_quotes(list_value)
                    to_add = attr_value in threshold
                elif operator == 'eq':
                    to_add = (attr_value == list_value)
                else:
                    msg = (_(""Unable to filter by unknown operator '%s'."")
                           % operator)
                    raise exception.InvalidFilterOperatorValue(msg)

            elif k != 'is_public' and image.get(k) is not None:
                to_add = image.get(key) == value
            elif k == 'tags':
                filter_tags = value
                image_tags = image_tag_get_all(context, image['id'])
                for tag in filter_tags:
                    if tag not in image_tags:
                        to_add = False
                        break
            else:
                to_add = False
                for p in image['properties']:
                    properties = {p['name']: p['value'],
                                  'deleted': p['deleted']}
                    to_add |= (properties.get(key) == value and
                               properties.get('deleted') is False)

            if not to_add:
                break

        if to_add:
            filtered_images.append(image)"
355,apps/glance/glance/db/simple/api.py,debug,LOG.debug,key,metadef_tag_create_tags.tag_values.keys,"for tag_value in tag_list:
        tag_values = copy.deepcopy(tag_value)
        tag_name = tag_values['name']

        for key in required_attributes:
            if key not in tag_values:
                raise exception.Invalid('%s is a required attribute' % key)

        incorrect_keys = set(tag_values.keys()) - set(allowed_attributes)
        if incorrect_keys:
            raise exception.Invalid(
                'The keys %s are not valid' % str(incorrect_keys))

        if tag_name in tag_name_list:
            LOG.debug(""A metadata definition tag with name=%(name)s""
                      "" in namespace=%(namespace_name)s already exists."",
                      {'name': tag_name, 'namespace_name': namespace_name})
            raise exception.MetadefDuplicateTag(
                name=tag_name, namespace_name=namespace_name)
        else:
            tag_name_list.append(tag_name)

        tag_values['namespace_id'] = namespace['id']
        data_tag_list.append(_format_tag(tag_values))"
356,apps/glance/glance/db/simple/api.py,debug,LOG.debug,key,tag_values.keys,"for tag_value in tag_list:
        tag_values = copy.deepcopy(tag_value)
        tag_name = tag_values['name']

        for key in required_attributes:
            if key not in tag_values:
                raise exception.Invalid('%s is a required attribute' % key)

        incorrect_keys = set(tag_values.keys()) - set(allowed_attributes)
        if incorrect_keys:
            raise exception.Invalid(
                'The keys %s are not valid' % str(incorrect_keys))

        if tag_name in tag_name_list:
            LOG.debug(""A metadata definition tag with name=%(name)s""
                      "" in namespace=%(namespace_name)s already exists."",
                      {'name': tag_name, 'namespace_name': namespace_name})
            raise exception.MetadefDuplicateTag(
                name=tag_name, namespace_name=namespace_name)
        else:
            tag_name_list.append(tag_name)

        tag_values['namespace_id'] = namespace['id']
        data_tag_list.append(_format_tag(tag_values))"
357,apps/glance/glance/db/sqlalchemy/api.py,enabled,CONF.profiler.enabled,trace_sqlalchemy,CONF.profiler.trace_sqlalchemy,"def _create_facade_lazily():
    global _LOCK, _FACADE
    if _FACADE is None:
        with _LOCK:
            if _FACADE is None:
                _FACADE = oslo_db_session.EngineFacade.from_config(
                    CONF,
                    sqlite_fk=True,
                )

                if CONF.profiler.enabled and CONF.profiler.trace_sqlalchemy:
                    osprofiler.sqlalchemy.add_tracing(sqlalchemy,
                                                      _FACADE.get_engine(),
                                                      ""db"")
    return _FACADE


def get_engine():
    facade = _create_facade_lazily()
    return facade.get_engine()"
358,apps/glance/glance/db/sqlalchemy/api.py,key,_image_get_all.query,user,_image_get_all.query,"query = _select_images_query(context,
                                 session,
                                 img_cond,
                                 admin_as_user,
                                 member_status,
                                 visibility)
    if visibility is not None:
        # with a visibility, we always and only include images with that
        # visibility except when using the 'all' visibility
        if visibility != 'all':
            query = query.filter(models.Image.visibility == visibility)
    elif context.owner is None:
        # without either a visibility or an owner, we never include
        # 'community' images
        query = query.filter(models.Image.visibility != 'community')
    else:
        # without a visibility and with an owner, we only want to include
        # 'community' images if and only if they are owned by this owner
        community_filters = [
            models.Image.owner == context.owner,"
359,apps/glance/glance/db/sqlalchemy/api.py,key,_image_get_all.query,user,_image_get_all.query,"member_status,
                                 visibility)
    if visibility is not None:
        # with a visibility, we always and only include images with that
        # visibility except when using the 'all' visibility
        if visibility != 'all':
            query = query.filter(models.Image.visibility == visibility)
    elif context.owner is None:
        # without either a visibility or an owner, we never include
        # 'community' images
        query = query.filter(models.Image.visibility != 'community')
    else:
        # without a visibility and with an owner, we only want to include
        # 'community' images if and only if they are owned by this owner
        community_filters = [
            models.Image.owner == context.owner,
            models.Image.visibility != 'community',
        ]
        query = query.filter(sa_sql.or_(*community_filters))"
360,apps/glance/glance/db/sqlalchemy/api.py,key,_image_get_all.query,user,_image_get_all.query,"# without either a visibility or an owner, we never include
        # 'community' images
        query = query.filter(models.Image.visibility != 'community')
    else:
        # without a visibility and with an owner, we only want to include
        # 'community' images if and only if they are owned by this owner
        community_filters = [
            models.Image.owner == context.owner,
            models.Image.visibility != 'community',
        ]
        query = query.filter(sa_sql.or_(*community_filters))

    if prop_cond:
        for alias, prop_condition in prop_cond:
            query = query.join(alias).filter(sa_sql.and_(*prop_condition))

    if tag_cond:
        for alias, tag_condition in tag_cond:
            query = query.join(alias).filter(sa_sql.and_(*tag_condition))"
361,apps/glance/glance/db/sqlalchemy/api.py,key,_image_get_all.query,user,_image_get_all.query,"# without a visibility and with an owner, we only want to include
        # 'community' images if and only if they are owned by this owner
        community_filters = [
            models.Image.owner == context.owner,
            models.Image.visibility != 'community',
        ]
        query = query.filter(sa_sql.or_(*community_filters))

    if prop_cond:
        for alias, prop_condition in prop_cond:
            query = query.join(alias).filter(sa_sql.and_(*prop_condition))

    if tag_cond:
        for alias, tag_condition in tag_cond:
            query = query.join(alias).filter(sa_sql.and_(*tag_condition))

    marker_image = None
    if marker is not None:
        marker_image = _image_get(context,
                                  session,"
362,apps/glance/glance/db/sqlalchemy/api.py,key,_image_get_all.query,user,_image_get_all.query,"models.Image.visibility != 'community',
        ]
        query = query.filter(sa_sql.or_(*community_filters))

    if prop_cond:
        for alias, prop_condition in prop_cond:
            query = query.join(alias).filter(sa_sql.and_(*prop_condition))

    if tag_cond:
        for alias, tag_condition in tag_cond:
            query = query.join(alias).filter(sa_sql.and_(*tag_condition))

    marker_image = None
    if marker is not None:
        marker_image = _image_get(context,
                                  session,
                                  marker,
                                  force_show_deleted=showing_deleted)

    for key in ['created_at', 'id']:"
363,apps/glance/glance/db/sqlalchemy/api.py,key,_image_get_all.query,user,_image_get_all.query,"marker_image = _image_get(context,
                                  session,
                                  marker,
                                  force_show_deleted=showing_deleted)

    for key in ['created_at', 'id']:
        if key not in sort_key:
            sort_key.append(key)
            sort_dir.append(default_sort_dir)

    query = _paginate_query(query, models.Image, limit,
                            sort_key,
                            marker=marker_image,
                            sort_dir=None,
                            sort_dirs=sort_dir)

    query = query.options(sa_orm.joinedload(
        models.Image.properties)).options(
            sa_orm.joinedload(models.Image.locations))
    if return_tag:"
364,apps/glance/glance/db/sqlalchemy/api.py,key,_image_get_all.sort_dir,user,_image_get_all.query,"marker_image = _image_get(context,
                                  session,
                                  marker,
                                  force_show_deleted=showing_deleted)

    for key in ['created_at', 'id']:
        if key not in sort_key:
            sort_key.append(key)
            sort_dir.append(default_sort_dir)

    query = _paginate_query(query, models.Image, limit,
                            sort_key,
                            marker=marker_image,
                            sort_dir=None,
                            sort_dirs=sort_dir)

    query = query.options(sa_orm.joinedload(
        models.Image.properties)).options(
            sa_orm.joinedload(models.Image.locations))
    if return_tag:"
365,apps/glance/glance/db/sqlalchemy/api.py,key,_image_get_all.sort_key,user,_image_get_all.query,"marker_image = _image_get(context,
                                  session,
                                  marker,
                                  force_show_deleted=showing_deleted)

    for key in ['created_at', 'id']:
        if key not in sort_key:
            sort_key.append(key)
            sort_dir.append(default_sort_dir)

    query = _paginate_query(query, models.Image, limit,
                            sort_key,
                            marker=marker_image,
                            sort_dir=None,
                            sort_dirs=sort_dir)

    query = query.options(sa_orm.joinedload(
        models.Image.properties)).options(
            sa_orm.joinedload(models.Image.locations))
    if return_tag:"
366,apps/glance/glance/db/sqlalchemy/api.py,key,_image_get_all.query,user,_image_get_all.query,"if key not in sort_key:
            sort_key.append(key)
            sort_dir.append(default_sort_dir)

    query = _paginate_query(query, models.Image, limit,
                            sort_key,
                            marker=marker_image,
                            sort_dir=None,
                            sort_dirs=sort_dir)

    query = query.options(sa_orm.joinedload(
        models.Image.properties)).options(
            sa_orm.joinedload(models.Image.locations))
    if return_tag:
        query = query.options(sa_orm.joinedload(models.Image.tags))

    images = []
    for image in query.all():
        image_dict = image.to_dict()
        image_dict = _normalize_locations("
367,apps/glance/glance/db/sqlalchemy/api.py,key,_image_get_all.query,user,_image_get_all.query,"query = _paginate_query(query, models.Image, limit,
                            sort_key,
                            marker=marker_image,
                            sort_dir=None,
                            sort_dirs=sort_dir)

    query = query.options(sa_orm.joinedload(
        models.Image.properties)).options(
            sa_orm.joinedload(models.Image.locations))
    if return_tag:
        query = query.options(sa_orm.joinedload(models.Image.tags))

    images = []
    for image in query.all():
        image_dict = image.to_dict()
        image_dict = _normalize_locations(
            context, image_dict, force_show_deleted=showing_deleted)
        if return_tag:
            image_dict = _normalize_tags(image_dict)
        if v1_mode:"
368,apps/glance/glance/db/sqlalchemy/api.py,key,_image_get_all.query,user,_image_get_all.query,"for alias, prop_condition in prop_cond:
            query = query.join(alias).filter(sa_sql.and_(*prop_condition))"
369,apps/glance/glance/db/sqlalchemy/api.py,key,_image_get_all.query,user,_image_get_all.query,"for alias, tag_condition in tag_cond:
            query = query.join(alias).filter(sa_sql.and_(*tag_condition))"
370,apps/glance/glance/db/sqlalchemy/api.py,enabled,CONF.profiler.enabled,trace_sqlalchemy,CONF.profiler.trace_sqlalchemy,"if _FACADE is None:
        with _LOCK:
            if _FACADE is None:
                _FACADE = oslo_db_session.EngineFacade.from_config(
                    CONF,
                    sqlite_fk=True,
                )

                if CONF.profiler.enabled and CONF.profiler.trace_sqlalchemy:
                    osprofiler.sqlalchemy.add_tracing(sqlalchemy,
                                                      _FACADE.get_engine(),
                                                      ""db"")"
371,apps/glance/glance/db/sqlalchemy/api.py,enabled,CONF.profiler.enabled,trace_sqlalchemy,CONF.profiler.trace_sqlalchemy,"if _FACADE is None:
                _FACADE = oslo_db_session.EngineFacade.from_config(
                    CONF,
                    sqlite_fk=True,
                )

                if CONF.profiler.enabled and CONF.profiler.trace_sqlalchemy:
                    osprofiler.sqlalchemy.add_tracing(sqlalchemy,
                                                      _FACADE.get_engine(),
                                                      ""db"")"
372,apps/glance/glance/db/sqlalchemy/api.py,enabled,CONF.profiler.enabled,trace_sqlalchemy,CONF.profiler.trace_sqlalchemy,"if CONF.profiler.enabled and CONF.profiler.trace_sqlalchemy:
                    osprofiler.sqlalchemy.add_tracing(sqlalchemy,
                                                      _FACADE.get_engine(),
                                                      ""db"")"
373,apps/glance/glance/db/sqlalchemy/api.py,key,_image_get_all.query,user,_image_get_all.query,"if visibility is not None:
        # with a visibility, we always and only include images with that
        # visibility except when using the 'all' visibility
        if visibility != 'all':
            query = query.filter(models.Image.visibility == visibility)
    elif context.owner is None:
        # without either a visibility or an owner, we never include
        # 'community' images
        query = query.filter(models.Image.visibility != 'community')
    else:
        # without a visibility and with an owner, we only want to include
        # 'community' images if and only if they are owned by this owner
        community_filters = [
            models.Image.owner == context.owner,
            models.Image.visibility != 'community',
        ]
        query = query.filter(sa_sql.or_(*community_filters))"
374,apps/glance/glance/db/sqlalchemy/api.py,key,_image_get_all.query,user,_image_get_all.query,"if visibility != 'all':
            query = query.filter(models.Image.visibility == visibility)"
375,apps/glance/glance/db/sqlalchemy/api.py,key,_image_get_all.query,user,_image_get_all.query,"elif context.owner is None:
        # without either a visibility or an owner, we never include
        # 'community' images
        query = query.filter(models.Image.visibility != 'community')
    else:
        # without a visibility and with an owner, we only want to include
        # 'community' images if and only if they are owned by this owner
        community_filters = [
            models.Image.owner == context.owner,
            models.Image.visibility != 'community',
        ]
        query = query.filter(sa_sql.or_(*community_filters))"
376,apps/glance/glance/db/sqlalchemy/api.py,key,_image_get_all.query,user,_image_get_all.query,"if prop_cond:
        for alias, prop_condition in prop_cond:
            query = query.join(alias).filter(sa_sql.and_(*prop_condition))"
377,apps/glance/glance/db/sqlalchemy/api.py,key,_image_get_all.query,user,_image_get_all.query,"if tag_cond:
        for alias, tag_condition in tag_cond:
            query = query.join(alias).filter(sa_sql.and_(*tag_condition))"
378,apps/glance/glance/db/sqlalchemy/api.py,key,_image_get_all.query,user,_image_get_all.query,"if return_tag:
        query = query.options(sa_orm.joinedload(models.Image.tags))"
379,apps/glance/glance/db/sqlalchemy/api.py,enabled,CONF.profiler.enabled,trace_sqlalchemy,CONF.profiler.trace_sqlalchemy,"with _LOCK:
            if _FACADE is None:
                _FACADE = oslo_db_session.EngineFacade.from_config(
                    CONF,
                    sqlite_fk=True,
                )

                if CONF.profiler.enabled and CONF.profiler.trace_sqlalchemy:
                    osprofiler.sqlalchemy.add_tracing(sqlalchemy,
                                                      _FACADE.get_engine(),
                                                      ""db"")"
380,apps/glance/glance/domain/__init__.py,debug,LOG.debug,task_executor,new_task_executor.CONF,"try:
            # NOTE(flaper87): Backwards compatibility layer.
            # It'll allow us to provide a deprecation path to
            # users that are currently consuming the `eventlet`
            # executor.
            task_executor = CONF.task.task_executor
            if task_executor == 'eventlet':
                # NOTE(jokke): Making sure we do not log the deprecation
                # warning 1000 times or anything crazy like that.
                if not TaskExecutorFactory.eventlet_deprecation_warned:
                    msg = _LW(""The `eventlet` executor has been deprecated. ""
                              ""Use `taskflow` instead."")
                    LOG.warning(msg)
                    TaskExecutorFactory.eventlet_deprecation_warned = True
                task_executor = 'taskflow'

            executor_cls = ('glance.async_.%s_executor.'
                            'TaskExecutor' % task_executor)
            LOG.debug(""Loading %s executor"", task_executor)
            executor = importutils.import_class(executor_cls)
            return executor(context,
                            self.task_repo,
                            self.image_repo,
                            self.image_factory,
                            admin_repo=self.admin_repo)
        except ImportError:
            with excutils.save_and_reraise_exception():
                LOG.exception(_LE(""Failed to load the %s executor provided ""
                                  ""in the config.""), CONF.task.task_executor)"
381,apps/glance/glance/domain/__init__.py,debug,LOG.debug,task_executor,new_task_executor.CONF.task,"try:
            # NOTE(flaper87): Backwards compatibility layer.
            # It'll allow us to provide a deprecation path to
            # users that are currently consuming the `eventlet`
            # executor.
            task_executor = CONF.task.task_executor
            if task_executor == 'eventlet':
                # NOTE(jokke): Making sure we do not log the deprecation
                # warning 1000 times or anything crazy like that.
                if not TaskExecutorFactory.eventlet_deprecation_warned:
                    msg = _LW(""The `eventlet` executor has been deprecated. ""
                              ""Use `taskflow` instead."")
                    LOG.warning(msg)
                    TaskExecutorFactory.eventlet_deprecation_warned = True
                task_executor = 'taskflow'

            executor_cls = ('glance.async_.%s_executor.'
                            'TaskExecutor' % task_executor)
            LOG.debug(""Loading %s executor"", task_executor)
            executor = importutils.import_class(executor_cls)
            return executor(context,
                            self.task_repo,
                            self.image_repo,
                            self.image_factory,
                            admin_repo=self.admin_repo)
        except ImportError:
            with excutils.save_and_reraise_exception():
                LOG.exception(_LE(""Failed to load the %s executor provided ""
                                  ""in the config.""), CONF.task.task_executor)"
382,apps/glance/glance/domain/__init__.py,debug,LOG.debug,task_executor,new_task_executor.CONF.task.task_executor,"try:
            # NOTE(flaper87): Backwards compatibility layer.
            # It'll allow us to provide a deprecation path to
            # users that are currently consuming the `eventlet`
            # executor.
            task_executor = CONF.task.task_executor
            if task_executor == 'eventlet':
                # NOTE(jokke): Making sure we do not log the deprecation
                # warning 1000 times or anything crazy like that.
                if not TaskExecutorFactory.eventlet_deprecation_warned:
                    msg = _LW(""The `eventlet` executor has been deprecated. ""
                              ""Use `taskflow` instead."")
                    LOG.warning(msg)
                    TaskExecutorFactory.eventlet_deprecation_warned = True
                task_executor = 'taskflow'

            executor_cls = ('glance.async_.%s_executor.'
                            'TaskExecutor' % task_executor)
            LOG.debug(""Loading %s executor"", task_executor)
            executor = importutils.import_class(executor_cls)
            return executor(context,
                            self.task_repo,
                            self.image_repo,
                            self.image_factory,
                            admin_repo=self.admin_repo)
        except ImportError:
            with excutils.save_and_reraise_exception():
                LOG.exception(_LE(""Failed to load the %s executor provided ""
                                  ""in the config.""), CONF.task.task_executor)"
383,apps/glance/glance/domain/__init__.py,debug,LOG.debug,task_executor,new_task_executor._LW,"try:
            # NOTE(flaper87): Backwards compatibility layer.
            # It'll allow us to provide a deprecation path to
            # users that are currently consuming the `eventlet`
            # executor.
            task_executor = CONF.task.task_executor
            if task_executor == 'eventlet':
                # NOTE(jokke): Making sure we do not log the deprecation
                # warning 1000 times or anything crazy like that.
                if not TaskExecutorFactory.eventlet_deprecation_warned:
                    msg = _LW(""The `eventlet` executor has been deprecated. ""
                              ""Use `taskflow` instead."")
                    LOG.warning(msg)
                    TaskExecutorFactory.eventlet_deprecation_warned = True
                task_executor = 'taskflow'

            executor_cls = ('glance.async_.%s_executor.'
                            'TaskExecutor' % task_executor)
            LOG.debug(""Loading %s executor"", task_executor)
            executor = importutils.import_class(executor_cls)
            return executor(context,
                            self.task_repo,
                            self.image_repo,
                            self.image_factory,
                            admin_repo=self.admin_repo)
        except ImportError:
            with excutils.save_and_reraise_exception():
                LOG.exception(_LE(""Failed to load the %s executor provided ""
                                  ""in the config.""), CONF.task.task_executor)"
384,apps/glance/glance/domain/__init__.py,debug,LOG.debug,task_executor,new_task_executor.task_executor,"try:
            # NOTE(flaper87): Backwards compatibility layer.
            # It'll allow us to provide a deprecation path to
            # users that are currently consuming the `eventlet`
            # executor.
            task_executor = CONF.task.task_executor
            if task_executor == 'eventlet':
                # NOTE(jokke): Making sure we do not log the deprecation
                # warning 1000 times or anything crazy like that.
                if not TaskExecutorFactory.eventlet_deprecation_warned:
                    msg = _LW(""The `eventlet` executor has been deprecated. ""
                              ""Use `taskflow` instead."")
                    LOG.warning(msg)
                    TaskExecutorFactory.eventlet_deprecation_warned = True
                task_executor = 'taskflow'

            executor_cls = ('glance.async_.%s_executor.'
                            'TaskExecutor' % task_executor)
            LOG.debug(""Loading %s executor"", task_executor)
            executor = importutils.import_class(executor_cls)
            return executor(context,
                            self.task_repo,
                            self.image_repo,
                            self.image_factory,
                            admin_repo=self.admin_repo)
        except ImportError:
            with excutils.save_and_reraise_exception():
                LOG.exception(_LE(""Failed to load the %s executor provided ""
                                  ""in the config.""), CONF.task.task_executor)"
385,apps/glance/glance/domain/__init__.py,debug,LOG.debug,task_executor,new_task_executor.executor_cls,"try:
            # NOTE(flaper87): Backwards compatibility layer.
            # It'll allow us to provide a deprecation path to
            # users that are currently consuming the `eventlet`
            # executor.
            task_executor = CONF.task.task_executor
            if task_executor == 'eventlet':
                # NOTE(jokke): Making sure we do not log the deprecation
                # warning 1000 times or anything crazy like that.
                if not TaskExecutorFactory.eventlet_deprecation_warned:
                    msg = _LW(""The `eventlet` executor has been deprecated. ""
                              ""Use `taskflow` instead."")
                    LOG.warning(msg)
                    TaskExecutorFactory.eventlet_deprecation_warned = True
                task_executor = 'taskflow'

            executor_cls = ('glance.async_.%s_executor.'
                            'TaskExecutor' % task_executor)
            LOG.debug(""Loading %s executor"", task_executor)
            executor = importutils.import_class(executor_cls)
            return executor(context,
                            self.task_repo,
                            self.image_repo,
                            self.image_factory,
                            admin_repo=self.admin_repo)
        except ImportError:
            with excutils.save_and_reraise_exception():
                LOG.exception(_LE(""Failed to load the %s executor provided ""
                                  ""in the config.""), CONF.task.task_executor)"
386,apps/glance/glance/domain/__init__.py,debug,LOG.debug,task_executor,new_task_executor.importutils,"try:
            # NOTE(flaper87): Backwards compatibility layer.
            # It'll allow us to provide a deprecation path to
            # users that are currently consuming the `eventlet`
            # executor.
            task_executor = CONF.task.task_executor
            if task_executor == 'eventlet':
                # NOTE(jokke): Making sure we do not log the deprecation
                # warning 1000 times or anything crazy like that.
                if not TaskExecutorFactory.eventlet_deprecation_warned:
                    msg = _LW(""The `eventlet` executor has been deprecated. ""
                              ""Use `taskflow` instead."")
                    LOG.warning(msg)
                    TaskExecutorFactory.eventlet_deprecation_warned = True
                task_executor = 'taskflow'

            executor_cls = ('glance.async_.%s_executor.'
                            'TaskExecutor' % task_executor)
            LOG.debug(""Loading %s executor"", task_executor)
            executor = importutils.import_class(executor_cls)
            return executor(context,
                            self.task_repo,
                            self.image_repo,
                            self.image_factory,
                            admin_repo=self.admin_repo)
        except ImportError:
            with excutils.save_and_reraise_exception():
                LOG.exception(_LE(""Failed to load the %s executor provided ""
                                  ""in the config.""), CONF.task.task_executor)"
387,apps/glance/glance/domain/__init__.py,debug,LOG.debug,task_executor,new_task_executor.importutils.import_class,"try:
            # NOTE(flaper87): Backwards compatibility layer.
            # It'll allow us to provide a deprecation path to
            # users that are currently consuming the `eventlet`
            # executor.
            task_executor = CONF.task.task_executor
            if task_executor == 'eventlet':
                # NOTE(jokke): Making sure we do not log the deprecation
                # warning 1000 times or anything crazy like that.
                if not TaskExecutorFactory.eventlet_deprecation_warned:
                    msg = _LW(""The `eventlet` executor has been deprecated. ""
                              ""Use `taskflow` instead."")
                    LOG.warning(msg)
                    TaskExecutorFactory.eventlet_deprecation_warned = True
                task_executor = 'taskflow'

            executor_cls = ('glance.async_.%s_executor.'
                            'TaskExecutor' % task_executor)
            LOG.debug(""Loading %s executor"", task_executor)
            executor = importutils.import_class(executor_cls)
            return executor(context,
                            self.task_repo,
                            self.image_repo,
                            self.image_factory,
                            admin_repo=self.admin_repo)
        except ImportError:
            with excutils.save_and_reraise_exception():
                LOG.exception(_LE(""Failed to load the %s executor provided ""
                                  ""in the config.""), CONF.task.task_executor)"
388,apps/glance/glance/domain/__init__.py,debug,LOG.debug,task_executor,CONF.task.task_executor,"try:
            # NOTE(flaper87): Backwards compatibility layer.
            # It'll allow us to provide a deprecation path to
            # users that are currently consuming the `eventlet`
            # executor.
            task_executor = CONF.task.task_executor
            if task_executor == 'eventlet':
                # NOTE(jokke): Making sure we do not log the deprecation
                # warning 1000 times or anything crazy like that.
                if not TaskExecutorFactory.eventlet_deprecation_warned:
                    msg = _LW(""The `eventlet` executor has been deprecated. ""
                              ""Use `taskflow` instead."")
                    LOG.warning(msg)
                    TaskExecutorFactory.eventlet_deprecation_warned = True
                task_executor = 'taskflow'

            executor_cls = ('glance.async_.%s_executor.'
                            'TaskExecutor' % task_executor)
            LOG.debug(""Loading %s executor"", task_executor)
            executor = importutils.import_class(executor_cls)
            return executor(context,
                            self.task_repo,
                            self.image_repo,
                            self.image_factory,
                            admin_repo=self.admin_repo)
        except ImportError:
            with excutils.save_and_reraise_exception():
                LOG.exception(_LE(""Failed to load the %s executor provided ""
                                  ""in the config.""), CONF.task.task_executor)"
389,apps/glance/glance/housekeeping.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"LOG = logging.getLogger(__name__)
CONF = cfg.CONF


def staging_store_path():
    """"""Return the local path to the staging store.

    :raises: GlanceException if staging store is not configured to be
             a file:// URI
    """"""
    if CONF.enabled_backends:
        separator, staging_dir = store_utils.get_dir_separator()
    else:
        staging_dir = CONF.node_staging_uri
    expected_prefix = 'file://'
    if not staging_dir.startswith(expected_prefix):
        raise exception.GlanceException(
            'Unexpected scheme in staging store; '
            'unable to scan for residue')
    return staging_dir[len(expected_prefix):]"
390,apps/glance/glance/housekeeping.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"if CONF.enabled_backends:
        separator, staging_dir = store_utils.get_dir_separator()
    else:
        staging_dir = CONF.node_staging_uri"
391,apps/glance/glance/image_cache/client.py,project_domain_id,get_client.project_domain_id,user,get_client.user_domain_id,"Returns a new client Glance client object based on common kwargs.
    If an option isn't specified falls back to common environment variable
    defaults.
    """"""

    if auth_url or os.getenv('OS_AUTH_URL'):
        force_strategy = 'keystone'
    else:
        force_strategy = None

    creds = {
        'username': username or
        os.getenv('OS_AUTH_USER', os.getenv('OS_USERNAME')),
        'password': password or
        os.getenv('OS_AUTH_KEY', os.getenv('OS_PASSWORD')),
        'project': project or
        os.getenv('OS_AUTH_PROJECT', os.getenv('OS_PROJECT_NAME')),
        'auth_url': auth_url or
        os.getenv('OS_AUTH_URL'),
        'strategy': force_strategy or"
392,apps/glance/glance/image_cache/client.py,project_domain_id,get_client.project_domain_id,user,get_client.user_domain_id,"Returns a new client Glance client object based on common kwargs.
    If an option isn't specified falls back to common environment variable
    defaults.
    """"""

    if auth_url or os.getenv('OS_AUTH_URL'):
        force_strategy = 'keystone'
    else:
        force_strategy = None

    creds = {
        'username': username or
        os.getenv('OS_AUTH_USER', os.getenv('OS_USERNAME')),
        'password': password or
        os.getenv('OS_AUTH_KEY', os.getenv('OS_PASSWORD')),
        'project': project or
        os.getenv('OS_AUTH_PROJECT', os.getenv('OS_PROJECT_NAME')),
        'auth_url': auth_url or
        os.getenv('OS_AUTH_URL'),
        'strategy': force_strategy or"
393,apps/glance/glance/image_cache/client.py,project_domain_id,get_client.project_domain_id,user,get_client.user_domain_id,"Returns a new client Glance client object based on common kwargs.
    If an option isn't specified falls back to common environment variable
    defaults.
    """"""

    if auth_url or os.getenv('OS_AUTH_URL'):
        force_strategy = 'keystone'
    else:
        force_strategy = None

    creds = {
        'username': username or
        os.getenv('OS_AUTH_USER', os.getenv('OS_USERNAME')),
        'password': password or
        os.getenv('OS_AUTH_KEY', os.getenv('OS_PASSWORD')),
        'project': project or
        os.getenv('OS_AUTH_PROJECT', os.getenv('OS_PROJECT_NAME')),
        'auth_url': auth_url or
        os.getenv('OS_AUTH_URL'),
        'strategy': force_strategy or"
394,apps/glance/glance/image_cache/client.py,project_domain_id,get_client.project_domain_id,user,get_client.user_domain_id,"Returns a new client Glance client object based on common kwargs.
    If an option isn't specified falls back to common environment variable
    defaults.
    """"""

    if auth_url or os.getenv('OS_AUTH_URL'):
        force_strategy = 'keystone'
    else:
        force_strategy = None

    creds = {
        'username': username or
        os.getenv('OS_AUTH_USER', os.getenv('OS_USERNAME')),
        'password': password or
        os.getenv('OS_AUTH_KEY', os.getenv('OS_PASSWORD')),
        'project': project or
        os.getenv('OS_AUTH_PROJECT', os.getenv('OS_PROJECT_NAME')),
        'auth_url': auth_url or
        os.getenv('OS_AUTH_URL'),
        'strategy': force_strategy or"
395,apps/glance/glance/image_cache/client.py,project_domain_id,get_client.project_domain_id,user,get_client.username,"Returns a new client Glance client object based on common kwargs.
    If an option isn't specified falls back to common environment variable
    defaults.
    """"""

    if auth_url or os.getenv('OS_AUTH_URL'):
        force_strategy = 'keystone'
    else:
        force_strategy = None

    creds = {
        'username': username or
        os.getenv('OS_AUTH_USER', os.getenv('OS_USERNAME')),
        'password': password or
        os.getenv('OS_AUTH_KEY', os.getenv('OS_PASSWORD')),
        'project': project or
        os.getenv('OS_AUTH_PROJECT', os.getenv('OS_PROJECT_NAME')),
        'auth_url': auth_url or
        os.getenv('OS_AUTH_URL'),
        'strategy': force_strategy or"
396,apps/glance/glance/image_cache/client.py,project_domain_id,get_client.project_domain_id,user,get_client.username,"Returns a new client Glance client object based on common kwargs.
    If an option isn't specified falls back to common environment variable
    defaults.
    """"""

    if auth_url or os.getenv('OS_AUTH_URL'):
        force_strategy = 'keystone'
    else:
        force_strategy = None

    creds = {
        'username': username or
        os.getenv('OS_AUTH_USER', os.getenv('OS_USERNAME')),
        'password': password or
        os.getenv('OS_AUTH_KEY', os.getenv('OS_PASSWORD')),
        'project': project or
        os.getenv('OS_AUTH_PROJECT', os.getenv('OS_PROJECT_NAME')),
        'auth_url': auth_url or
        os.getenv('OS_AUTH_URL'),
        'strategy': force_strategy or"
397,apps/glance/glance/image_cache/client.py,project_domain_id,get_client.project_domain_id,user_domain_id,get_client.user_domain_id,"Returns a new client Glance client object based on common kwargs.
    If an option isn't specified falls back to common environment variable
    defaults.
    """"""

    if auth_url or os.getenv('OS_AUTH_URL'):
        force_strategy = 'keystone'
    else:
        force_strategy = None

    creds = {
        'username': username or
        os.getenv('OS_AUTH_USER', os.getenv('OS_USERNAME')),
        'password': password or
        os.getenv('OS_AUTH_KEY', os.getenv('OS_PASSWORD')),
        'project': project or
        os.getenv('OS_AUTH_PROJECT', os.getenv('OS_PROJECT_NAME')),
        'auth_url': auth_url or
        os.getenv('OS_AUTH_URL'),
        'strategy': force_strategy or"
398,apps/glance/glance/image_cache/client.py,project_domain_id,get_client.project_domain_id,user_domain_id,get_client.user_domain_id,"Returns a new client Glance client object based on common kwargs.
    If an option isn't specified falls back to common environment variable
    defaults.
    """"""

    if auth_url or os.getenv('OS_AUTH_URL'):
        force_strategy = 'keystone'
    else:
        force_strategy = None

    creds = {
        'username': username or
        os.getenv('OS_AUTH_USER', os.getenv('OS_USERNAME')),
        'password': password or
        os.getenv('OS_AUTH_KEY', os.getenv('OS_PASSWORD')),
        'project': project or
        os.getenv('OS_AUTH_PROJECT', os.getenv('OS_PROJECT_NAME')),
        'auth_url': auth_url or
        os.getenv('OS_AUTH_URL'),
        'strategy': force_strategy or"
399,apps/glance/glance/image_cache/client.py,project_domain_id,get_client.project_domain_id,user_domain_id,get_client.user_domain_id,"Returns a new client Glance client object based on common kwargs.
    If an option isn't specified falls back to common environment variable
    defaults.
    """"""

    if auth_url or os.getenv('OS_AUTH_URL'):
        force_strategy = 'keystone'
    else:
        force_strategy = None

    creds = {
        'username': username or
        os.getenv('OS_AUTH_USER', os.getenv('OS_USERNAME')),
        'password': password or
        os.getenv('OS_AUTH_KEY', os.getenv('OS_PASSWORD')),
        'project': project or
        os.getenv('OS_AUTH_PROJECT', os.getenv('OS_PROJECT_NAME')),
        'auth_url': auth_url or
        os.getenv('OS_AUTH_URL'),
        'strategy': force_strategy or"
400,apps/glance/glance/image_cache/client.py,project_domain_id,get_client.project_domain_id,user_domain_id,get_client.user_domain_id,"Returns a new client Glance client object based on common kwargs.
    If an option isn't specified falls back to common environment variable
    defaults.
    """"""

    if auth_url or os.getenv('OS_AUTH_URL'):
        force_strategy = 'keystone'
    else:
        force_strategy = None

    creds = {
        'username': username or
        os.getenv('OS_AUTH_USER', os.getenv('OS_USERNAME')),
        'password': password or
        os.getenv('OS_AUTH_KEY', os.getenv('OS_PASSWORD')),
        'project': project or
        os.getenv('OS_AUTH_PROJECT', os.getenv('OS_PROJECT_NAME')),
        'auth_url': auth_url or
        os.getenv('OS_AUTH_URL'),
        'strategy': force_strategy or"
401,apps/glance/glance/image_cache/client.py,user,get_client.user_domain_id,user_domain_id,get_client.user_domain_id,"Returns a new client Glance client object based on common kwargs.
    If an option isn't specified falls back to common environment variable
    defaults.
    """"""

    if auth_url or os.getenv('OS_AUTH_URL'):
        force_strategy = 'keystone'
    else:
        force_strategy = None

    creds = {
        'username': username or
        os.getenv('OS_AUTH_USER', os.getenv('OS_USERNAME')),
        'password': password or
        os.getenv('OS_AUTH_KEY', os.getenv('OS_PASSWORD')),
        'project': project or
        os.getenv('OS_AUTH_PROJECT', os.getenv('OS_PROJECT_NAME')),
        'auth_url': auth_url or
        os.getenv('OS_AUTH_URL'),
        'strategy': force_strategy or"
402,apps/glance/glance/image_cache/client.py,user,get_client.user_domain_id,user_domain_id,get_client.user_domain_id,"Returns a new client Glance client object based on common kwargs.
    If an option isn't specified falls back to common environment variable
    defaults.
    """"""

    if auth_url or os.getenv('OS_AUTH_URL'):
        force_strategy = 'keystone'
    else:
        force_strategy = None

    creds = {
        'username': username or
        os.getenv('OS_AUTH_USER', os.getenv('OS_USERNAME')),
        'password': password or
        os.getenv('OS_AUTH_KEY', os.getenv('OS_PASSWORD')),
        'project': project or
        os.getenv('OS_AUTH_PROJECT', os.getenv('OS_PROJECT_NAME')),
        'auth_url': auth_url or
        os.getenv('OS_AUTH_URL'),
        'strategy': force_strategy or"
403,apps/glance/glance/image_cache/client.py,user,get_client.user_domain_id,user_domain_id,get_client.user_domain_id,"Returns a new client Glance client object based on common kwargs.
    If an option isn't specified falls back to common environment variable
    defaults.
    """"""

    if auth_url or os.getenv('OS_AUTH_URL'):
        force_strategy = 'keystone'
    else:
        force_strategy = None

    creds = {
        'username': username or
        os.getenv('OS_AUTH_USER', os.getenv('OS_USERNAME')),
        'password': password or
        os.getenv('OS_AUTH_KEY', os.getenv('OS_PASSWORD')),
        'project': project or
        os.getenv('OS_AUTH_PROJECT', os.getenv('OS_PROJECT_NAME')),
        'auth_url': auth_url or
        os.getenv('OS_AUTH_URL'),
        'strategy': force_strategy or"
404,apps/glance/glance/image_cache/client.py,user,get_client.user_domain_id,user_domain_id,get_client.user_domain_id,"Returns a new client Glance client object based on common kwargs.
    If an option isn't specified falls back to common environment variable
    defaults.
    """"""

    if auth_url or os.getenv('OS_AUTH_URL'):
        force_strategy = 'keystone'
    else:
        force_strategy = None

    creds = {
        'username': username or
        os.getenv('OS_AUTH_USER', os.getenv('OS_USERNAME')),
        'password': password or
        os.getenv('OS_AUTH_KEY', os.getenv('OS_PASSWORD')),
        'project': project or
        os.getenv('OS_AUTH_PROJECT', os.getenv('OS_PROJECT_NAME')),
        'auth_url': auth_url or
        os.getenv('OS_AUTH_URL'),
        'strategy': force_strategy or"
405,apps/glance/glance/image_cache/client.py,user,get_client.username,user_domain_id,get_client.user_domain_id,"Returns a new client Glance client object based on common kwargs.
    If an option isn't specified falls back to common environment variable
    defaults.
    """"""

    if auth_url or os.getenv('OS_AUTH_URL'):
        force_strategy = 'keystone'
    else:
        force_strategy = None

    creds = {
        'username': username or
        os.getenv('OS_AUTH_USER', os.getenv('OS_USERNAME')),
        'password': password or
        os.getenv('OS_AUTH_KEY', os.getenv('OS_PASSWORD')),
        'project': project or
        os.getenv('OS_AUTH_PROJECT', os.getenv('OS_PROJECT_NAME')),
        'auth_url': auth_url or
        os.getenv('OS_AUTH_URL'),
        'strategy': force_strategy or"
406,apps/glance/glance/image_cache/client.py,user,get_client.username,user_domain_id,get_client.user_domain_id,"Returns a new client Glance client object based on common kwargs.
    If an option isn't specified falls back to common environment variable
    defaults.
    """"""

    if auth_url or os.getenv('OS_AUTH_URL'):
        force_strategy = 'keystone'
    else:
        force_strategy = None

    creds = {
        'username': username or
        os.getenv('OS_AUTH_USER', os.getenv('OS_USERNAME')),
        'password': password or
        os.getenv('OS_AUTH_KEY', os.getenv('OS_PASSWORD')),
        'project': project or
        os.getenv('OS_AUTH_PROJECT', os.getenv('OS_PROJECT_NAME')),
        'auth_url': auth_url or
        os.getenv('OS_AUTH_URL'),
        'strategy': force_strategy or"
407,apps/glance/glance/image_cache/prefetcher.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"except exception.NotFound:
            LOG.warning(_LW(""Image '%s' not found""), image_id)
            return False

        if image.status != 'active':
            LOG.warning(_LW(""Image '%s' is not active. Not caching.""),
                        image_id)
            return False

        for loc in image.locations:
            if CONF.enabled_backends:
                image_data, image_size = glance_store.get(loc['url'],
                                                          None,
                                                          context=ctx)
            else:
                image_data, image_size = glance_store.get_from_backend(
                    loc['url'], context=ctx)

            LOG.debug(""Caching image '%s'"", image_id)
            cache_tee_iter = self.cache.cache_tee_iter(image_id, image_data,"
408,apps/glance/glance/image_cache/prefetcher.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"for loc in image.locations:
            if CONF.enabled_backends:
                image_data, image_size = glance_store.get(loc['url'],
                                                          None,
                                                          context=ctx)
            else:
                image_data, image_size = glance_store.get_from_backend(
                    loc['url'], context=ctx)

            LOG.debug(""Caching image '%s'"", image_id)
            cache_tee_iter = self.cache.cache_tee_iter(image_id, image_data,
                                                       image.checksum)
            # Image is tee'd into cache and checksum verified
            # as we iterate
            list(cache_tee_iter)
            return True"
409,apps/glance/glance/image_cache/prefetcher.py,debug,LOG.debug,enabled,CONF.enabled_backends,"for loc in image.locations:
            if CONF.enabled_backends:
                image_data, image_size = glance_store.get(loc['url'],
                                                          None,
                                                          context=ctx)
            else:
                image_data, image_size = glance_store.get_from_backend(
                    loc['url'], context=ctx)

            LOG.debug(""Caching image '%s'"", image_id)
            cache_tee_iter = self.cache.cache_tee_iter(image_id, image_data,
                                                       image.checksum)
            # Image is tee'd into cache and checksum verified
            # as we iterate
            list(cache_tee_iter)
            return True"
410,apps/glance/glance/image_cache/prefetcher.py,debug,LOG.debug,enabled_backends,CONF.enabled_backends,"for loc in image.locations:
            if CONF.enabled_backends:
                image_data, image_size = glance_store.get(loc['url'],
                                                          None,
                                                          context=ctx)
            else:
                image_data, image_size = glance_store.get_from_backend(
                    loc['url'], context=ctx)

            LOG.debug(""Caching image '%s'"", image_id)
            cache_tee_iter = self.cache.cache_tee_iter(image_id, image_data,
                                                       image.checksum)
            # Image is tee'd into cache and checksum verified
            # as we iterate
            list(cache_tee_iter)
            return True"
411,apps/glance/glance/image_cache/prefetcher.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"if CONF.enabled_backends:
                image_data, image_size = glance_store.get(loc['url'],
                                                          None,
                                                          context=ctx)
            else:
                image_data, image_size = glance_store.get_from_backend(
                    loc['url'], context=ctx)"
412,apps/glance/glance/location.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"def _set_acls(self, image):
        public = image.visibility in ['public', 'community']
        member_ids = []
        if image.locations and not public:
            member_repo = _get_member_repo_for_store(image,
                                                     self.context,
                                                     self.db_api,
                                                     self.store_api)
            member_ids = [m.member_id for m in member_repo.list()]
        for location in image.locations:
            if CONF.enabled_backends:
                # NOTE(whoami-rajat): Do not set_acls if store is not defined
                # on this node. This is possible in case of edge deployment
                # that image location is present but the actual store is
                # not related to this node.
                image_store = location['metadata'].get('store')
                if image_store not in CONF.enabled_backends:
                    msg = (_(""Store %s is not available on ""
                             ""this node, skipping `_set_acls` ""
                             ""call."") % image_store)"
413,apps/glance/glance/location.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"self.db_api,
                                                     self.store_api)
            member_ids = [m.member_id for m in member_repo.list()]
        for location in image.locations:
            if CONF.enabled_backends:
                # NOTE(whoami-rajat): Do not set_acls if store is not defined
                # on this node. This is possible in case of edge deployment
                # that image location is present but the actual store is
                # not related to this node.
                image_store = location['metadata'].get('store')
                if image_store not in CONF.enabled_backends:
                    msg = (_(""Store %s is not available on ""
                             ""this node, skipping `_set_acls` ""
                             ""call."") % image_store)
                    LOG.debug(msg)
                    continue
                self.store_api.set_acls_for_multi_store(
                    location['url'], image_store,
                    public=public, read_tenants=member_ids,
                    context=self.context"
414,apps/glance/glance/location.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"self._set_acls(image)
        return result

    def save(self, image, from_state=None):
        result = super(ImageRepoProxy, self).save(image, from_state=from_state)
        self._set_acls(image)
        return result

    def get(self, image_id):
        image = super(ImageRepoProxy, self).get(image_id)
        if CONF.enabled_backends:
            try:
                store_utils.update_store_in_locations(
                    self.context, image, self.image_repo)
            except exception.Forbidden:
                # NOTE(danms): We may not be able to complete a store
                # update if we do not own the image. That should not
                # break us, so avoid raising Forbidden in that
                # case. Note that modifications to @image here will
                # still be returned to the user, just not saved in the"
415,apps/glance/glance/location.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,":param context: Glance request context
    :param store_api: store API module
    :param store_utils: store utils module
    :param uri: location's uri string
    :param backend: A backend name for the store
    """"""

    try:
        # NOTE(zhiyan): Some stores return zero when it catch exception
        if CONF.enabled_backends:
            size_from_backend = store_api.get_size_from_uri_and_backend(
                uri, backend, context=context)
        else:
            size_from_backend = store_api.get_size_from_backend(
                uri, context=context)

        is_ok = (store_utils.validate_external_location(uri) and
                 size_from_backend > 0)
    except (store.UnknownScheme, store.NotFound, store.BadStoreUri):"
416,apps/glance/glance/location.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"size_from_backend > 0)
    except (store.UnknownScheme, store.NotFound, store.BadStoreUri):
        is_ok = False
    if not is_ok:
        reason = _('Invalid location')
        raise exception.BadStoreUri(message=reason)


def _check_image_location(context, store_api, store_utils, location):
    backend = None
    if CONF.enabled_backends:
        backend = location['metadata'].get('store')

    _check_location_uri(context, store_api, store_utils, location['url'],
                        backend=backend)
    store_api.check_location_metadata(location['metadata'])


def _set_image_size(context, image, locations):
    if not image.size:"
417,apps/glance/glance/location.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"backend = location['metadata'].get('store')

    _check_location_uri(context, store_api, store_utils, location['url'],
                        backend=backend)
    store_api.check_location_metadata(location['metadata'])


def _set_image_size(context, image, locations):
    if not image.size:
        for location in locations:
            if CONF.enabled_backends:
                size_from_backend = store.get_size_from_uri_and_backend(
                    location['url'], location['metadata'].get('store'),
                    context=context)
            else:
                size_from_backend = store.get_size_from_backend(
                    location['url'], context=context)

            if size_from_backend:
                # NOTE(flwang): This assumes all locations have the same size"
418,apps/glance/glance/location.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"""""""
        Upload data to store

        :param data: data to upload to store
        :param verifier: for signature verification
        :param store: store to upload data to
        :param size: data size
        :return:
        """"""
        hashing_algo = self.image.os_hash_algo or CONF['hashing_algorithm']
        if CONF.enabled_backends:
            (location, size, checksum,
             multihash, loc_meta) = self.store_api.add_with_multihash(
                CONF,
                self.image.image_id,
                utils.LimitingReader(utils.CooperativeReader(data),
                                     CONF.image_size_cap),
                size,
                store,
                hashing_algo,"
419,apps/glance/glance/location.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,":param verifier: for signature verification
        """"""
        # NOTE(bpoulos): if verification fails, exception will be raised
        if verifier is not None:
            try:
                verifier.verify()
                msg = _LI(""Successfully verified signature for image %s"")
                LOG.info(msg, self.image.image_id)
            except crypto_exception.InvalidSignature:
                if CONF.enabled_backends:
                    self.store_api.delete(location,
                                          loc_meta.get('store'),
                                          context=self.context)
                else:
                    self.store_api.delete_from_backend(location,
                                                       context=self.context)
                raise cursive_exception.SignatureVerificationError(
                    _('Signature verification failed')
                )"
420,apps/glance/glance/location.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"# NOTE(mclaren): This is the only set of arguments
            # which work with this exception currently, see:
            # https://bugs.launchpad.net/glance-store/+bug/1501443
            # When the above glance_store bug is fixed we can
            # add a msg as usual.
            raise store.NotFound(image=None)
        err = None
        for loc in self.image.locations:
            try:
                backend = loc['metadata'].get('store')
                if CONF.enabled_backends:
                    data, size = self.store_api.get(
                        loc['url'], backend, offset=offset,
                        chunk_size=chunk_size, context=self.context
                    )
                else:
                    data, size = self.store_api.get_from_backend(
                        loc['url'],
                        offset=offset,
                        chunk_size=chunk_size,"
421,apps/glance/glance/location.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"self.image = image
        self.context = context
        self.store_api = store_api
        super(ImageMemberRepoProxy, self).__init__(repo)

    def _set_acls(self):
        public = self.image.visibility in ['public', 'community']
        if self.image.locations and not public:
            member_ids = [m.member_id for m in self.repo.list()]
            for location in self.image.locations:
                if CONF.enabled_backends:
                    # NOTE(whoami-rajat): Do not set_acls if store is not
                    # defined on this node. This is possible in case of edge
                    # deployment that image location is present but the actual
                    # store is not related to this node.
                    image_store = location['metadata'].get('store')
                    if image_store not in CONF.enabled_backends:
                        msg = (_(""Store %s is not available on ""
                                 ""this node, skipping `_set_acls` ""
                                 ""call."") % image_store)"
422,apps/glance/glance/location.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"public = self.image.visibility in ['public', 'community']
        if self.image.locations and not public:
            member_ids = [m.member_id for m in self.repo.list()]
            for location in self.image.locations:
                if CONF.enabled_backends:
                    # NOTE(whoami-rajat): Do not set_acls if store is not
                    # defined on this node. This is possible in case of edge
                    # deployment that image location is present but the actual
                    # store is not related to this node.
                    image_store = location['metadata'].get('store')
                    if image_store not in CONF.enabled_backends:
                        msg = (_(""Store %s is not available on ""
                                 ""this node, skipping `_set_acls` ""
                                 ""call."") % image_store)
                        LOG.debug(msg)
                        continue
                    self.store_api.set_acls_for_multi_store(
                        location['url'], image_store,
                        public=public, read_tenants=member_ids,
                        context=self.context"
423,apps/glance/glance/location.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"for location in image.locations:
            if CONF.enabled_backends:
                # NOTE(whoami-rajat): Do not set_acls if store is not defined
                # on this node. This is possible in case of edge deployment
                # that image location is present but the actual store is
                # not related to this node.
                image_store = location['metadata'].get('store')
                if image_store not in CONF.enabled_backends:
                    msg = (_(""Store %s is not available on ""
                             ""this node, skipping `_set_acls` ""
                             ""call."") % image_store)
                    LOG.debug(msg)
                    continue
                self.store_api.set_acls_for_multi_store(
                    location['url'], image_store,
                    public=public, read_tenants=member_ids,
                    context=self.context
                )
            else:
                self.store_api.set_acls(location['url'], public=public,
                                        read_tenants=member_ids,
                                        context=self.context)"
424,apps/glance/glance/location.py,debug,LOG.debug,enabled,CONF.enabled_backends,"for location in image.locations:
            if CONF.enabled_backends:
                # NOTE(whoami-rajat): Do not set_acls if store is not defined
                # on this node. This is possible in case of edge deployment
                # that image location is present but the actual store is
                # not related to this node.
                image_store = location['metadata'].get('store')
                if image_store not in CONF.enabled_backends:
                    msg = (_(""Store %s is not available on ""
                             ""this node, skipping `_set_acls` ""
                             ""call."") % image_store)
                    LOG.debug(msg)
                    continue
                self.store_api.set_acls_for_multi_store(
                    location['url'], image_store,
                    public=public, read_tenants=member_ids,
                    context=self.context
                )
            else:
                self.store_api.set_acls(location['url'], public=public,
                                        read_tenants=member_ids,
                                        context=self.context)"
425,apps/glance/glance/location.py,debug,LOG.debug,enabled_backends,CONF.enabled_backends,"for location in image.locations:
            if CONF.enabled_backends:
                # NOTE(whoami-rajat): Do not set_acls if store is not defined
                # on this node. This is possible in case of edge deployment
                # that image location is present but the actual store is
                # not related to this node.
                image_store = location['metadata'].get('store')
                if image_store not in CONF.enabled_backends:
                    msg = (_(""Store %s is not available on ""
                             ""this node, skipping `_set_acls` ""
                             ""call."") % image_store)
                    LOG.debug(msg)
                    continue
                self.store_api.set_acls_for_multi_store(
                    location['url'], image_store,
                    public=public, read_tenants=member_ids,
                    context=self.context
                )
            else:
                self.store_api.set_acls(location['url'], public=public,
                                        read_tenants=member_ids,
                                        context=self.context)"
426,apps/glance/glance/location.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"for location in locations:
            if CONF.enabled_backends:
                size_from_backend = store.get_size_from_uri_and_backend(
                    location['url'], location['metadata'].get('store'),
                    context=context)
            else:
                size_from_backend = store.get_size_from_backend(
                    location['url'], context=context)

            if size_from_backend:
                # NOTE(flwang): This assumes all locations have the same size
                image.size = size_from_backend
                break"
427,apps/glance/glance/location.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"for loc in self.image.locations:
            try:
                backend = loc['metadata'].get('store')
                if CONF.enabled_backends:
                    data, size = self.store_api.get(
                        loc['url'], backend, offset=offset,
                        chunk_size=chunk_size, context=self.context
                    )
                else:
                    data, size = self.store_api.get_from_backend(
                        loc['url'],
                        offset=offset,
                        chunk_size=chunk_size,
                        context=self.context)

                return data
            except Exception as e:
                LOG.warning(_LW('Get image %(id)s data failed: '
                                '%(err)s.'),
                            {'id': self.image.image_id,
                            'err': encodeutils.exception_to_unicode(e)})
                err = e"
428,apps/glance/glance/location.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"for location in self.image.locations:
                if CONF.enabled_backends:
                    # NOTE(whoami-rajat): Do not set_acls if store is not
                    # defined on this node. This is possible in case of edge
                    # deployment that image location is present but the actual
                    # store is not related to this node.
                    image_store = location['metadata'].get('store')
                    if image_store not in CONF.enabled_backends:
                        msg = (_(""Store %s is not available on ""
                                 ""this node, skipping `_set_acls` ""
                                 ""call."") % image_store)
                        LOG.debug(msg)
                        continue
                    self.store_api.set_acls_for_multi_store(
                        location['url'], image_store,
                        public=public, read_tenants=member_ids,
                        context=self.context
                    )
                else:
                    self.store_api.set_acls(location['url'], public=public,
                                            read_tenants=member_ids,
                                            context=self.context)"
429,apps/glance/glance/location.py,debug,LOG.debug,enabled,CONF.enabled_backends,"for location in self.image.locations:
                if CONF.enabled_backends:
                    # NOTE(whoami-rajat): Do not set_acls if store is not
                    # defined on this node. This is possible in case of edge
                    # deployment that image location is present but the actual
                    # store is not related to this node.
                    image_store = location['metadata'].get('store')
                    if image_store not in CONF.enabled_backends:
                        msg = (_(""Store %s is not available on ""
                                 ""this node, skipping `_set_acls` ""
                                 ""call."") % image_store)
                        LOG.debug(msg)
                        continue
                    self.store_api.set_acls_for_multi_store(
                        location['url'], image_store,
                        public=public, read_tenants=member_ids,
                        context=self.context
                    )
                else:
                    self.store_api.set_acls(location['url'], public=public,
                                            read_tenants=member_ids,
                                            context=self.context)"
430,apps/glance/glance/location.py,debug,LOG.debug,enabled_backends,CONF.enabled_backends,"for location in self.image.locations:
                if CONF.enabled_backends:
                    # NOTE(whoami-rajat): Do not set_acls if store is not
                    # defined on this node. This is possible in case of edge
                    # deployment that image location is present but the actual
                    # store is not related to this node.
                    image_store = location['metadata'].get('store')
                    if image_store not in CONF.enabled_backends:
                        msg = (_(""Store %s is not available on ""
                                 ""this node, skipping `_set_acls` ""
                                 ""call."") % image_store)
                        LOG.debug(msg)
                        continue
                    self.store_api.set_acls_for_multi_store(
                        location['url'], image_store,
                        public=public, read_tenants=member_ids,
                        context=self.context
                    )
                else:
                    self.store_api.set_acls(location['url'], public=public,
                                            read_tenants=member_ids,
                                            context=self.context)"
431,apps/glance/glance/location.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"if CONF.enabled_backends:
                # NOTE(whoami-rajat): Do not set_acls if store is not defined
                # on this node. This is possible in case of edge deployment
                # that image location is present but the actual store is
                # not related to this node.
                image_store = location['metadata'].get('store')
                if image_store not in CONF.enabled_backends:
                    msg = (_(""Store %s is not available on ""
                             ""this node, skipping `_set_acls` ""
                             ""call."") % image_store)
                    LOG.debug(msg)
                    continue
                self.store_api.set_acls_for_multi_store(
                    location['url'], image_store,
                    public=public, read_tenants=member_ids,
                    context=self.context
                )
            else:
                self.store_api.set_acls(location['url'], public=public,
                                        read_tenants=member_ids,
                                        context=self.context)"
432,apps/glance/glance/location.py,debug,LOG.debug,enabled,CONF.enabled_backends,"if CONF.enabled_backends:
                # NOTE(whoami-rajat): Do not set_acls if store is not defined
                # on this node. This is possible in case of edge deployment
                # that image location is present but the actual store is
                # not related to this node.
                image_store = location['metadata'].get('store')
                if image_store not in CONF.enabled_backends:
                    msg = (_(""Store %s is not available on ""
                             ""this node, skipping `_set_acls` ""
                             ""call."") % image_store)
                    LOG.debug(msg)
                    continue
                self.store_api.set_acls_for_multi_store(
                    location['url'], image_store,
                    public=public, read_tenants=member_ids,
                    context=self.context
                )
            else:
                self.store_api.set_acls(location['url'], public=public,
                                        read_tenants=member_ids,
                                        context=self.context)"
433,apps/glance/glance/location.py,debug,LOG.debug,enabled_backends,CONF.enabled_backends,"if CONF.enabled_backends:
                # NOTE(whoami-rajat): Do not set_acls if store is not defined
                # on this node. This is possible in case of edge deployment
                # that image location is present but the actual store is
                # not related to this node.
                image_store = location['metadata'].get('store')
                if image_store not in CONF.enabled_backends:
                    msg = (_(""Store %s is not available on ""
                             ""this node, skipping `_set_acls` ""
                             ""call."") % image_store)
                    LOG.debug(msg)
                    continue
                self.store_api.set_acls_for_multi_store(
                    location['url'], image_store,
                    public=public, read_tenants=member_ids,
                    context=self.context
                )
            else:
                self.store_api.set_acls(location['url'], public=public,
                                        read_tenants=member_ids,
                                        context=self.context)"
434,apps/glance/glance/location.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"if image_store not in CONF.enabled_backends:
                    msg = (_(""Store %s is not available on ""
                             ""this node, skipping `_set_acls` ""
                             ""call."") % image_store)
                    LOG.debug(msg)
                    continue"
435,apps/glance/glance/location.py,debug,LOG.debug,enabled,CONF.enabled_backends,"if image_store not in CONF.enabled_backends:
                    msg = (_(""Store %s is not available on ""
                             ""this node, skipping `_set_acls` ""
                             ""call."") % image_store)
                    LOG.debug(msg)
                    continue"
436,apps/glance/glance/location.py,debug,LOG.debug,enabled_backends,CONF.enabled_backends,"if image_store not in CONF.enabled_backends:
                    msg = (_(""Store %s is not available on ""
                             ""this node, skipping `_set_acls` ""
                             ""call."") % image_store)
                    LOG.debug(msg)
                    continue"
437,apps/glance/glance/location.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"if CONF.enabled_backends:
            try:
                store_utils.update_store_in_locations(
                    self.context, image, self.image_repo)
            except exception.Forbidden:
                # NOTE(danms): We may not be able to complete a store
                # update if we do not own the image. That should not
                # break us, so avoid raising Forbidden in that
                # case. Note that modifications to @image here will
                # still be returned to the user, just not saved in the
                # DB. That is probably what we want anyway.
                pass"
438,apps/glance/glance/location.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"if CONF.enabled_backends:
            size_from_backend = store_api.get_size_from_uri_and_backend(
                uri, backend, context=context)
        else:
            size_from_backend = store_api.get_size_from_backend(
                uri, context=context)"
439,apps/glance/glance/location.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"if CONF.enabled_backends:
        backend = location['metadata'].get('store')"
440,apps/glance/glance/location.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"if not image.size:
        for location in locations:
            if CONF.enabled_backends:
                size_from_backend = store.get_size_from_uri_and_backend(
                    location['url'], location['metadata'].get('store'),
                    context=context)
            else:
                size_from_backend = store.get_size_from_backend(
                    location['url'], context=context)

            if size_from_backend:
                # NOTE(flwang): This assumes all locations have the same size
                image.size = size_from_backend
                break"
441,apps/glance/glance/location.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"if CONF.enabled_backends:
                size_from_backend = store.get_size_from_uri_and_backend(
                    location['url'], location['metadata'].get('store'),
                    context=context)
            else:
                size_from_backend = store.get_size_from_backend(
                    location['url'], context=context)"
442,apps/glance/glance/location.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"if CONF.enabled_backends:
            (location, size, checksum,
             multihash, loc_meta) = self.store_api.add_with_multihash(
                CONF,
                self.image.image_id,
                utils.LimitingReader(utils.CooperativeReader(data),
                                     CONF.image_size_cap),
                size,
                store,
                hashing_algo,
                context=self.context,
                verifier=verifier)
        else:
            (location,
             size,
             checksum,
             multihash,
             loc_meta) = self.store_api.add_to_backend_with_multihash(
                CONF,
                self.image.image_id,
                utils.LimitingReader(utils.CooperativeReader(data),
                                     CONF.image_size_cap),
                size,
                hashing_algo,
                context=self.context,
                verifier=verifier)"
443,apps/glance/glance/location.py,enabled_backends,CONF.enabled_backends,image_size_cap,CONF.image_size_cap,"if CONF.enabled_backends:
            (location, size, checksum,
             multihash, loc_meta) = self.store_api.add_with_multihash(
                CONF,
                self.image.image_id,
                utils.LimitingReader(utils.CooperativeReader(data),
                                     CONF.image_size_cap),
                size,
                store,
                hashing_algo,
                context=self.context,
                verifier=verifier)
        else:
            (location,
             size,
             checksum,
             multihash,
             loc_meta) = self.store_api.add_to_backend_with_multihash(
                CONF,
                self.image.image_id,
                utils.LimitingReader(utils.CooperativeReader(data),
                                     CONF.image_size_cap),
                size,
                hashing_algo,
                context=self.context,
                verifier=verifier)"
444,apps/glance/glance/location.py,enabled,CONF.enabled_backends,image_size_cap,CONF.image_size_cap,"if CONF.enabled_backends:
            (location, size, checksum,
             multihash, loc_meta) = self.store_api.add_with_multihash(
                CONF,
                self.image.image_id,
                utils.LimitingReader(utils.CooperativeReader(data),
                                     CONF.image_size_cap),
                size,
                store,
                hashing_algo,
                context=self.context,
                verifier=verifier)
        else:
            (location,
             size,
             checksum,
             multihash,
             loc_meta) = self.store_api.add_to_backend_with_multihash(
                CONF,
                self.image.image_id,
                utils.LimitingReader(utils.CooperativeReader(data),
                                     CONF.image_size_cap),
                size,
                hashing_algo,
                context=self.context,
                verifier=verifier)"
445,apps/glance/glance/location.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"if verifier is not None:
            try:
                verifier.verify()
                msg = _LI(""Successfully verified signature for image %s"")
                LOG.info(msg, self.image.image_id)
            except crypto_exception.InvalidSignature:
                if CONF.enabled_backends:
                    self.store_api.delete(location,
                                          loc_meta.get('store'),
                                          context=self.context)
                else:
                    self.store_api.delete_from_backend(location,
                                                       context=self.context)
                raise cursive_exception.SignatureVerificationError(
                    _('Signature verification failed')
                )"
446,apps/glance/glance/location.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"if CONF.enabled_backends:
                    self.store_api.delete(location,
                                          loc_meta.get('store'),
                                          context=self.context)
                else:
                    self.store_api.delete_from_backend(location,
                                                       context=self.context)"
447,apps/glance/glance/location.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"if CONF.enabled_backends:
                    data, size = self.store_api.get(
                        loc['url'], backend, offset=offset,
                        chunk_size=chunk_size, context=self.context
                    )
                else:
                    data, size = self.store_api.get_from_backend(
                        loc['url'],
                        offset=offset,
                        chunk_size=chunk_size,
                        context=self.context)"
448,apps/glance/glance/location.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"if self.image.locations and not public:
            member_ids = [m.member_id for m in self.repo.list()]
            for location in self.image.locations:
                if CONF.enabled_backends:
                    # NOTE(whoami-rajat): Do not set_acls if store is not
                    # defined on this node. This is possible in case of edge
                    # deployment that image location is present but the actual
                    # store is not related to this node.
                    image_store = location['metadata'].get('store')
                    if image_store not in CONF.enabled_backends:
                        msg = (_(""Store %s is not available on ""
                                 ""this node, skipping `_set_acls` ""
                                 ""call."") % image_store)
                        LOG.debug(msg)
                        continue
                    self.store_api.set_acls_for_multi_store(
                        location['url'], image_store,
                        public=public, read_tenants=member_ids,
                        context=self.context
                    )
                else:
                    self.store_api.set_acls(location['url'], public=public,
                                            read_tenants=member_ids,
                                            context=self.context)"
449,apps/glance/glance/location.py,debug,LOG.debug,enabled,CONF.enabled_backends,"if self.image.locations and not public:
            member_ids = [m.member_id for m in self.repo.list()]
            for location in self.image.locations:
                if CONF.enabled_backends:
                    # NOTE(whoami-rajat): Do not set_acls if store is not
                    # defined on this node. This is possible in case of edge
                    # deployment that image location is present but the actual
                    # store is not related to this node.
                    image_store = location['metadata'].get('store')
                    if image_store not in CONF.enabled_backends:
                        msg = (_(""Store %s is not available on ""
                                 ""this node, skipping `_set_acls` ""
                                 ""call."") % image_store)
                        LOG.debug(msg)
                        continue
                    self.store_api.set_acls_for_multi_store(
                        location['url'], image_store,
                        public=public, read_tenants=member_ids,
                        context=self.context
                    )
                else:
                    self.store_api.set_acls(location['url'], public=public,
                                            read_tenants=member_ids,
                                            context=self.context)"
450,apps/glance/glance/location.py,debug,LOG.debug,enabled_backends,CONF.enabled_backends,"if self.image.locations and not public:
            member_ids = [m.member_id for m in self.repo.list()]
            for location in self.image.locations:
                if CONF.enabled_backends:
                    # NOTE(whoami-rajat): Do not set_acls if store is not
                    # defined on this node. This is possible in case of edge
                    # deployment that image location is present but the actual
                    # store is not related to this node.
                    image_store = location['metadata'].get('store')
                    if image_store not in CONF.enabled_backends:
                        msg = (_(""Store %s is not available on ""
                                 ""this node, skipping `_set_acls` ""
                                 ""call."") % image_store)
                        LOG.debug(msg)
                        continue
                    self.store_api.set_acls_for_multi_store(
                        location['url'], image_store,
                        public=public, read_tenants=member_ids,
                        context=self.context
                    )
                else:
                    self.store_api.set_acls(location['url'], public=public,
                                            read_tenants=member_ids,
                                            context=self.context)"
451,apps/glance/glance/location.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"if CONF.enabled_backends:
                    # NOTE(whoami-rajat): Do not set_acls if store is not
                    # defined on this node. This is possible in case of edge
                    # deployment that image location is present but the actual
                    # store is not related to this node.
                    image_store = location['metadata'].get('store')
                    if image_store not in CONF.enabled_backends:
                        msg = (_(""Store %s is not available on ""
                                 ""this node, skipping `_set_acls` ""
                                 ""call."") % image_store)
                        LOG.debug(msg)
                        continue
                    self.store_api.set_acls_for_multi_store(
                        location['url'], image_store,
                        public=public, read_tenants=member_ids,
                        context=self.context
                    )
                else:
                    self.store_api.set_acls(location['url'], public=public,
                                            read_tenants=member_ids,
                                            context=self.context)"
452,apps/glance/glance/location.py,debug,LOG.debug,enabled,CONF.enabled_backends,"if CONF.enabled_backends:
                    # NOTE(whoami-rajat): Do not set_acls if store is not
                    # defined on this node. This is possible in case of edge
                    # deployment that image location is present but the actual
                    # store is not related to this node.
                    image_store = location['metadata'].get('store')
                    if image_store not in CONF.enabled_backends:
                        msg = (_(""Store %s is not available on ""
                                 ""this node, skipping `_set_acls` ""
                                 ""call."") % image_store)
                        LOG.debug(msg)
                        continue
                    self.store_api.set_acls_for_multi_store(
                        location['url'], image_store,
                        public=public, read_tenants=member_ids,
                        context=self.context
                    )
                else:
                    self.store_api.set_acls(location['url'], public=public,
                                            read_tenants=member_ids,
                                            context=self.context)"
453,apps/glance/glance/location.py,debug,LOG.debug,enabled_backends,CONF.enabled_backends,"if CONF.enabled_backends:
                    # NOTE(whoami-rajat): Do not set_acls if store is not
                    # defined on this node. This is possible in case of edge
                    # deployment that image location is present but the actual
                    # store is not related to this node.
                    image_store = location['metadata'].get('store')
                    if image_store not in CONF.enabled_backends:
                        msg = (_(""Store %s is not available on ""
                                 ""this node, skipping `_set_acls` ""
                                 ""call."") % image_store)
                        LOG.debug(msg)
                        continue
                    self.store_api.set_acls_for_multi_store(
                        location['url'], image_store,
                        public=public, read_tenants=member_ids,
                        context=self.context
                    )
                else:
                    self.store_api.set_acls(location['url'], public=public,
                                            read_tenants=member_ids,
                                            context=self.context)"
454,apps/glance/glance/location.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"if image_store not in CONF.enabled_backends:
                        msg = (_(""Store %s is not available on ""
                                 ""this node, skipping `_set_acls` ""
                                 ""call."") % image_store)
                        LOG.debug(msg)
                        continue"
455,apps/glance/glance/location.py,debug,LOG.debug,enabled,CONF.enabled_backends,"if image_store not in CONF.enabled_backends:
                        msg = (_(""Store %s is not available on ""
                                 ""this node, skipping `_set_acls` ""
                                 ""call."") % image_store)
                        LOG.debug(msg)
                        continue"
456,apps/glance/glance/location.py,debug,LOG.debug,enabled_backends,CONF.enabled_backends,"if image_store not in CONF.enabled_backends:
                        msg = (_(""Store %s is not available on ""
                                 ""this node, skipping `_set_acls` ""
                                 ""call."") % image_store)
                        LOG.debug(msg)
                        continue"
457,apps/glance/glance/location.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"try:
        # NOTE(zhiyan): Some stores return zero when it catch exception
        if CONF.enabled_backends:
            size_from_backend = store_api.get_size_from_uri_and_backend(
                uri, backend, context=context)
        else:
            size_from_backend = store_api.get_size_from_backend(
                uri, context=context)

        is_ok = (store_utils.validate_external_location(uri) and
                 size_from_backend > 0)
    except (store.UnknownScheme, store.NotFound, store.BadStoreUri):
        is_ok = False"
458,apps/glance/glance/location.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"try:
                verifier.verify()
                msg = _LI(""Successfully verified signature for image %s"")
                LOG.info(msg, self.image.image_id)
            except crypto_exception.InvalidSignature:
                if CONF.enabled_backends:
                    self.store_api.delete(location,
                                          loc_meta.get('store'),
                                          context=self.context)
                else:
                    self.store_api.delete_from_backend(location,
                                                       context=self.context)
                raise cursive_exception.SignatureVerificationError(
                    _('Signature verification failed')
                )"
459,apps/glance/glance/location.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"try:
                backend = loc['metadata'].get('store')
                if CONF.enabled_backends:
                    data, size = self.store_api.get(
                        loc['url'], backend, offset=offset,
                        chunk_size=chunk_size, context=self.context
                    )
                else:
                    data, size = self.store_api.get_from_backend(
                        loc['url'],
                        offset=offset,
                        chunk_size=chunk_size,
                        context=self.context)

                return data
            except Exception as e:
                LOG.warning(_LW('Get image %(id)s data failed: '
                                '%(err)s.'),
                            {'id': self.image.image_id,
                            'err': encodeutils.exception_to_unicode(e)})
                err = e"
460,apps/glance/glance/quota/__init__.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"def _calc_required_size(context, image, locations):
    required_size = None
    if image.size:
        required_size = image.size * len(locations)
    else:
        for location in locations:
            size_from_backend = None

            try:
                if CONF.enabled_backends:
                    size_from_backend = store.get_size_from_uri_and_backend(
                        location['url'], location['metadata'].get('store'),
                        context=context)
                else:
                    size_from_backend = store.get_size_from_backend(
                        location['url'], context=context)
            except (store.UnknownScheme, store.NotFound):
                pass
            except store.BadStoreUri:"
461,apps/glance/glance/quota/__init__.py,user,self._check_user_storage_quota,user_storage_quota,self._check_user_storage_quota,"def __ne__(self, other):
        return not self.__eq__(other)

    def __getitem__(self, *args, **kwargs):
        return self.locations.__getitem__(*args, **kwargs)

    def __iadd__(self, other):
        if not hasattr(other, '__iter__'):
            raise TypeError()
        self._check_user_storage_quota(other)
        return self.locations.__iadd__(other)

    def __iter__(self, *args, **kwargs):
        return self.locations.__iter__(*args, **kwargs)

    def __len__(self, *args, **kwargs):
        return self.locations.__len__(*args, **kwargs)

    def __setitem__(self, key, value):"
462,apps/glance/glance/quota/__init__.py,user,_check_user_storage_quota._calc_required_size,user_storage_quota,_check_user_storage_quota._calc_required_size,"def pop(self, *args, **kwargs):
        return self.locations.pop(*args, **kwargs)

    def remove(self, *args, **kwargs):
        return self.locations.remove(*args, **kwargs)

    def reverse(self, *args, **kwargs):
        return self.locations.reverse(*args, **kwargs)

    def _check_user_storage_quota(self, locations):
        required_size = _calc_required_size(self.context,
                                            self.image,
                                            locations)
        glance.api.common.check_quota(self.context,
                                      required_size,
                                      self.db_api)
        _enforce_image_location_quota(self.image, locations)

    def __copy__(self):
        return type(self)(self.image, self.context, self.db_api)"
463,apps/glance/glance/quota/__init__.py,user,_check_user_storage_quota._calc_required_size,user_storage_quota,_check_user_storage_quota.locations,"def pop(self, *args, **kwargs):
        return self.locations.pop(*args, **kwargs)

    def remove(self, *args, **kwargs):
        return self.locations.remove(*args, **kwargs)

    def reverse(self, *args, **kwargs):
        return self.locations.reverse(*args, **kwargs)

    def _check_user_storage_quota(self, locations):
        required_size = _calc_required_size(self.context,
                                            self.image,
                                            locations)
        glance.api.common.check_quota(self.context,
                                      required_size,
                                      self.db_api)
        _enforce_image_location_quota(self.image, locations)

    def __copy__(self):
        return type(self)(self.image, self.context, self.db_api)"
464,apps/glance/glance/quota/__init__.py,user,_check_user_storage_quota._calc_required_size,user_storage_quota,_check_user_storage_quota.self,"def pop(self, *args, **kwargs):
        return self.locations.pop(*args, **kwargs)

    def remove(self, *args, **kwargs):
        return self.locations.remove(*args, **kwargs)

    def reverse(self, *args, **kwargs):
        return self.locations.reverse(*args, **kwargs)

    def _check_user_storage_quota(self, locations):
        required_size = _calc_required_size(self.context,
                                            self.image,
                                            locations)
        glance.api.common.check_quota(self.context,
                                      required_size,
                                      self.db_api)
        _enforce_image_location_quota(self.image, locations)

    def __copy__(self):
        return type(self)(self.image, self.context, self.db_api)"
465,apps/glance/glance/quota/__init__.py,user,_check_user_storage_quota._calc_required_size,user_storage_quota,_check_user_storage_quota.self.context,"def pop(self, *args, **kwargs):
        return self.locations.pop(*args, **kwargs)

    def remove(self, *args, **kwargs):
        return self.locations.remove(*args, **kwargs)

    def reverse(self, *args, **kwargs):
        return self.locations.reverse(*args, **kwargs)

    def _check_user_storage_quota(self, locations):
        required_size = _calc_required_size(self.context,
                                            self.image,
                                            locations)
        glance.api.common.check_quota(self.context,
                                      required_size,
                                      self.db_api)
        _enforce_image_location_quota(self.image, locations)

    def __copy__(self):
        return type(self)(self.image, self.context, self.db_api)"
466,apps/glance/glance/quota/__init__.py,user,_check_user_storage_quota._calc_required_size,user_storage_quota,_check_user_storage_quota.self.image,"def pop(self, *args, **kwargs):
        return self.locations.pop(*args, **kwargs)

    def remove(self, *args, **kwargs):
        return self.locations.remove(*args, **kwargs)

    def reverse(self, *args, **kwargs):
        return self.locations.reverse(*args, **kwargs)

    def _check_user_storage_quota(self, locations):
        required_size = _calc_required_size(self.context,
                                            self.image,
                                            locations)
        glance.api.common.check_quota(self.context,
                                      required_size,
                                      self.db_api)
        _enforce_image_location_quota(self.image, locations)

    def __copy__(self):
        return type(self)(self.image, self.context, self.db_api)"
467,apps/glance/glance/quota/__init__.py,user,_check_user_storage_quota.locations,user_storage_quota,_check_user_storage_quota._calc_required_size,"def pop(self, *args, **kwargs):
        return self.locations.pop(*args, **kwargs)

    def remove(self, *args, **kwargs):
        return self.locations.remove(*args, **kwargs)

    def reverse(self, *args, **kwargs):
        return self.locations.reverse(*args, **kwargs)

    def _check_user_storage_quota(self, locations):
        required_size = _calc_required_size(self.context,
                                            self.image,
                                            locations)
        glance.api.common.check_quota(self.context,
                                      required_size,
                                      self.db_api)
        _enforce_image_location_quota(self.image, locations)

    def __copy__(self):
        return type(self)(self.image, self.context, self.db_api)"
468,apps/glance/glance/quota/__init__.py,user,_check_user_storage_quota.locations,user_storage_quota,_check_user_storage_quota.locations,"def pop(self, *args, **kwargs):
        return self.locations.pop(*args, **kwargs)

    def remove(self, *args, **kwargs):
        return self.locations.remove(*args, **kwargs)

    def reverse(self, *args, **kwargs):
        return self.locations.reverse(*args, **kwargs)

    def _check_user_storage_quota(self, locations):
        required_size = _calc_required_size(self.context,
                                            self.image,
                                            locations)
        glance.api.common.check_quota(self.context,
                                      required_size,
                                      self.db_api)
        _enforce_image_location_quota(self.image, locations)

    def __copy__(self):
        return type(self)(self.image, self.context, self.db_api)"
469,apps/glance/glance/quota/__init__.py,user,_check_user_storage_quota.locations,user_storage_quota,_check_user_storage_quota.self,"def pop(self, *args, **kwargs):
        return self.locations.pop(*args, **kwargs)

    def remove(self, *args, **kwargs):
        return self.locations.remove(*args, **kwargs)

    def reverse(self, *args, **kwargs):
        return self.locations.reverse(*args, **kwargs)

    def _check_user_storage_quota(self, locations):
        required_size = _calc_required_size(self.context,
                                            self.image,
                                            locations)
        glance.api.common.check_quota(self.context,
                                      required_size,
                                      self.db_api)
        _enforce_image_location_quota(self.image, locations)

    def __copy__(self):
        return type(self)(self.image, self.context, self.db_api)"
470,apps/glance/glance/quota/__init__.py,user,_check_user_storage_quota.locations,user_storage_quota,_check_user_storage_quota.self.context,"def pop(self, *args, **kwargs):
        return self.locations.pop(*args, **kwargs)

    def remove(self, *args, **kwargs):
        return self.locations.remove(*args, **kwargs)

    def reverse(self, *args, **kwargs):
        return self.locations.reverse(*args, **kwargs)

    def _check_user_storage_quota(self, locations):
        required_size = _calc_required_size(self.context,
                                            self.image,
                                            locations)
        glance.api.common.check_quota(self.context,
                                      required_size,
                                      self.db_api)
        _enforce_image_location_quota(self.image, locations)

    def __copy__(self):
        return type(self)(self.image, self.context, self.db_api)"
471,apps/glance/glance/quota/__init__.py,user,_check_user_storage_quota.locations,user_storage_quota,_check_user_storage_quota.self.image,"def pop(self, *args, **kwargs):
        return self.locations.pop(*args, **kwargs)

    def remove(self, *args, **kwargs):
        return self.locations.remove(*args, **kwargs)

    def reverse(self, *args, **kwargs):
        return self.locations.reverse(*args, **kwargs)

    def _check_user_storage_quota(self, locations):
        required_size = _calc_required_size(self.context,
                                            self.image,
                                            locations)
        glance.api.common.check_quota(self.context,
                                      required_size,
                                      self.db_api)
        _enforce_image_location_quota(self.image, locations)

    def __copy__(self):
        return type(self)(self.image, self.context, self.db_api)"
472,apps/glance/glance/quota/__init__.py,user,_check_user_storage_quota.self,user_storage_quota,_check_user_storage_quota._calc_required_size,"def pop(self, *args, **kwargs):
        return self.locations.pop(*args, **kwargs)

    def remove(self, *args, **kwargs):
        return self.locations.remove(*args, **kwargs)

    def reverse(self, *args, **kwargs):
        return self.locations.reverse(*args, **kwargs)

    def _check_user_storage_quota(self, locations):
        required_size = _calc_required_size(self.context,
                                            self.image,
                                            locations)
        glance.api.common.check_quota(self.context,
                                      required_size,
                                      self.db_api)
        _enforce_image_location_quota(self.image, locations)

    def __copy__(self):
        return type(self)(self.image, self.context, self.db_api)"
473,apps/glance/glance/quota/__init__.py,user,_check_user_storage_quota.self,user_storage_quota,_check_user_storage_quota.locations,"def pop(self, *args, **kwargs):
        return self.locations.pop(*args, **kwargs)

    def remove(self, *args, **kwargs):
        return self.locations.remove(*args, **kwargs)

    def reverse(self, *args, **kwargs):
        return self.locations.reverse(*args, **kwargs)

    def _check_user_storage_quota(self, locations):
        required_size = _calc_required_size(self.context,
                                            self.image,
                                            locations)
        glance.api.common.check_quota(self.context,
                                      required_size,
                                      self.db_api)
        _enforce_image_location_quota(self.image, locations)

    def __copy__(self):
        return type(self)(self.image, self.context, self.db_api)"
474,apps/glance/glance/quota/__init__.py,user,_check_user_storage_quota.self,user_storage_quota,_check_user_storage_quota.self,"def pop(self, *args, **kwargs):
        return self.locations.pop(*args, **kwargs)

    def remove(self, *args, **kwargs):
        return self.locations.remove(*args, **kwargs)

    def reverse(self, *args, **kwargs):
        return self.locations.reverse(*args, **kwargs)

    def _check_user_storage_quota(self, locations):
        required_size = _calc_required_size(self.context,
                                            self.image,
                                            locations)
        glance.api.common.check_quota(self.context,
                                      required_size,
                                      self.db_api)
        _enforce_image_location_quota(self.image, locations)

    def __copy__(self):
        return type(self)(self.image, self.context, self.db_api)"
475,apps/glance/glance/quota/__init__.py,user,_check_user_storage_quota.self,user_storage_quota,_check_user_storage_quota.self.context,"def pop(self, *args, **kwargs):
        return self.locations.pop(*args, **kwargs)

    def remove(self, *args, **kwargs):
        return self.locations.remove(*args, **kwargs)

    def reverse(self, *args, **kwargs):
        return self.locations.reverse(*args, **kwargs)

    def _check_user_storage_quota(self, locations):
        required_size = _calc_required_size(self.context,
                                            self.image,
                                            locations)
        glance.api.common.check_quota(self.context,
                                      required_size,
                                      self.db_api)
        _enforce_image_location_quota(self.image, locations)

    def __copy__(self):
        return type(self)(self.image, self.context, self.db_api)"
476,apps/glance/glance/quota/__init__.py,user,_check_user_storage_quota.self,user_storage_quota,_check_user_storage_quota.self.image,"def pop(self, *args, **kwargs):
        return self.locations.pop(*args, **kwargs)

    def remove(self, *args, **kwargs):
        return self.locations.remove(*args, **kwargs)

    def reverse(self, *args, **kwargs):
        return self.locations.reverse(*args, **kwargs)

    def _check_user_storage_quota(self, locations):
        required_size = _calc_required_size(self.context,
                                            self.image,
                                            locations)
        glance.api.common.check_quota(self.context,
                                      required_size,
                                      self.db_api)
        _enforce_image_location_quota(self.image, locations)

    def __copy__(self):
        return type(self)(self.image, self.context, self.db_api)"
477,apps/glance/glance/quota/__init__.py,user,_check_user_storage_quota.self.context,user_storage_quota,_check_user_storage_quota._calc_required_size,"def pop(self, *args, **kwargs):
        return self.locations.pop(*args, **kwargs)

    def remove(self, *args, **kwargs):
        return self.locations.remove(*args, **kwargs)

    def reverse(self, *args, **kwargs):
        return self.locations.reverse(*args, **kwargs)

    def _check_user_storage_quota(self, locations):
        required_size = _calc_required_size(self.context,
                                            self.image,
                                            locations)
        glance.api.common.check_quota(self.context,
                                      required_size,
                                      self.db_api)
        _enforce_image_location_quota(self.image, locations)

    def __copy__(self):
        return type(self)(self.image, self.context, self.db_api)"
478,apps/glance/glance/quota/__init__.py,user,_check_user_storage_quota.self.context,user_storage_quota,_check_user_storage_quota.locations,"def pop(self, *args, **kwargs):
        return self.locations.pop(*args, **kwargs)

    def remove(self, *args, **kwargs):
        return self.locations.remove(*args, **kwargs)

    def reverse(self, *args, **kwargs):
        return self.locations.reverse(*args, **kwargs)

    def _check_user_storage_quota(self, locations):
        required_size = _calc_required_size(self.context,
                                            self.image,
                                            locations)
        glance.api.common.check_quota(self.context,
                                      required_size,
                                      self.db_api)
        _enforce_image_location_quota(self.image, locations)

    def __copy__(self):
        return type(self)(self.image, self.context, self.db_api)"
479,apps/glance/glance/quota/__init__.py,user,_check_user_storage_quota.self.context,user_storage_quota,_check_user_storage_quota.self,"def pop(self, *args, **kwargs):
        return self.locations.pop(*args, **kwargs)

    def remove(self, *args, **kwargs):
        return self.locations.remove(*args, **kwargs)

    def reverse(self, *args, **kwargs):
        return self.locations.reverse(*args, **kwargs)

    def _check_user_storage_quota(self, locations):
        required_size = _calc_required_size(self.context,
                                            self.image,
                                            locations)
        glance.api.common.check_quota(self.context,
                                      required_size,
                                      self.db_api)
        _enforce_image_location_quota(self.image, locations)

    def __copy__(self):
        return type(self)(self.image, self.context, self.db_api)"
480,apps/glance/glance/quota/__init__.py,user,_check_user_storage_quota.self.context,user_storage_quota,_check_user_storage_quota.self.context,"def pop(self, *args, **kwargs):
        return self.locations.pop(*args, **kwargs)

    def remove(self, *args, **kwargs):
        return self.locations.remove(*args, **kwargs)

    def reverse(self, *args, **kwargs):
        return self.locations.reverse(*args, **kwargs)

    def _check_user_storage_quota(self, locations):
        required_size = _calc_required_size(self.context,
                                            self.image,
                                            locations)
        glance.api.common.check_quota(self.context,
                                      required_size,
                                      self.db_api)
        _enforce_image_location_quota(self.image, locations)

    def __copy__(self):
        return type(self)(self.image, self.context, self.db_api)"
481,apps/glance/glance/quota/__init__.py,user,_check_user_storage_quota.self.context,user_storage_quota,_check_user_storage_quota.self.image,"def pop(self, *args, **kwargs):
        return self.locations.pop(*args, **kwargs)

    def remove(self, *args, **kwargs):
        return self.locations.remove(*args, **kwargs)

    def reverse(self, *args, **kwargs):
        return self.locations.reverse(*args, **kwargs)

    def _check_user_storage_quota(self, locations):
        required_size = _calc_required_size(self.context,
                                            self.image,
                                            locations)
        glance.api.common.check_quota(self.context,
                                      required_size,
                                      self.db_api)
        _enforce_image_location_quota(self.image, locations)

    def __copy__(self):
        return type(self)(self.image, self.context, self.db_api)"
482,apps/glance/glance/quota/__init__.py,user,_check_user_storage_quota.self.image,user_storage_quota,_check_user_storage_quota._calc_required_size,"def pop(self, *args, **kwargs):
        return self.locations.pop(*args, **kwargs)

    def remove(self, *args, **kwargs):
        return self.locations.remove(*args, **kwargs)

    def reverse(self, *args, **kwargs):
        return self.locations.reverse(*args, **kwargs)

    def _check_user_storage_quota(self, locations):
        required_size = _calc_required_size(self.context,
                                            self.image,
                                            locations)
        glance.api.common.check_quota(self.context,
                                      required_size,
                                      self.db_api)
        _enforce_image_location_quota(self.image, locations)

    def __copy__(self):
        return type(self)(self.image, self.context, self.db_api)"
483,apps/glance/glance/quota/__init__.py,user,_check_user_storage_quota.self.image,user_storage_quota,_check_user_storage_quota.locations,"def pop(self, *args, **kwargs):
        return self.locations.pop(*args, **kwargs)

    def remove(self, *args, **kwargs):
        return self.locations.remove(*args, **kwargs)

    def reverse(self, *args, **kwargs):
        return self.locations.reverse(*args, **kwargs)

    def _check_user_storage_quota(self, locations):
        required_size = _calc_required_size(self.context,
                                            self.image,
                                            locations)
        glance.api.common.check_quota(self.context,
                                      required_size,
                                      self.db_api)
        _enforce_image_location_quota(self.image, locations)

    def __copy__(self):
        return type(self)(self.image, self.context, self.db_api)"
484,apps/glance/glance/quota/__init__.py,user,_check_user_storage_quota.self.image,user_storage_quota,_check_user_storage_quota.self,"def pop(self, *args, **kwargs):
        return self.locations.pop(*args, **kwargs)

    def remove(self, *args, **kwargs):
        return self.locations.remove(*args, **kwargs)

    def reverse(self, *args, **kwargs):
        return self.locations.reverse(*args, **kwargs)

    def _check_user_storage_quota(self, locations):
        required_size = _calc_required_size(self.context,
                                            self.image,
                                            locations)
        glance.api.common.check_quota(self.context,
                                      required_size,
                                      self.db_api)
        _enforce_image_location_quota(self.image, locations)

    def __copy__(self):
        return type(self)(self.image, self.context, self.db_api)"
485,apps/glance/glance/quota/__init__.py,user,_check_user_storage_quota.self.image,user_storage_quota,_check_user_storage_quota.self.context,"def pop(self, *args, **kwargs):
        return self.locations.pop(*args, **kwargs)

    def remove(self, *args, **kwargs):
        return self.locations.remove(*args, **kwargs)

    def reverse(self, *args, **kwargs):
        return self.locations.reverse(*args, **kwargs)

    def _check_user_storage_quota(self, locations):
        required_size = _calc_required_size(self.context,
                                            self.image,
                                            locations)
        glance.api.common.check_quota(self.context,
                                      required_size,
                                      self.db_api)
        _enforce_image_location_quota(self.image, locations)

    def __copy__(self):
        return type(self)(self.image, self.context, self.db_api)"
486,apps/glance/glance/quota/__init__.py,user,_check_user_storage_quota.self.image,user_storage_quota,_check_user_storage_quota.self.image,"def pop(self, *args, **kwargs):
        return self.locations.pop(*args, **kwargs)

    def remove(self, *args, **kwargs):
        return self.locations.remove(*args, **kwargs)

    def reverse(self, *args, **kwargs):
        return self.locations.reverse(*args, **kwargs)

    def _check_user_storage_quota(self, locations):
        required_size = _calc_required_size(self.context,
                                            self.image,
                                            locations)
        glance.api.common.check_quota(self.context,
                                      required_size,
                                      self.db_api)
        _enforce_image_location_quota(self.image, locations)

    def __copy__(self):
        return type(self)(self.image, self.context, self.db_api)"
487,apps/glance/glance/quota/__init__.py,user,self._check_user_storage_quota,user_storage_quota,self._check_user_storage_quota,"def __copy__(self):
        return type(self)(self.image, self.context, self.db_api)

    def __deepcopy__(self, memo):
        # NOTE(zhiyan): Only copy location entries, others can be reused.
        self.image.locations = copy.deepcopy(self.locations, memo)
        return type(self)(self.image, self.context, self.db_api)

    def append(self, object):
        self._check_user_storage_quota([object])
        return self.locations.append(object)

    def insert(self, index, object):
        self._check_user_storage_quota([object])
        return self.locations.insert(index, object)

    def extend(self, iter):
        self._check_user_storage_quota(iter)
        return self.locations.extend(iter)"
488,apps/glance/glance/quota/__init__.py,user,self._check_user_storage_quota,user_storage_quota,self._check_user_storage_quota,"def __deepcopy__(self, memo):
        # NOTE(zhiyan): Only copy location entries, others can be reused.
        self.image.locations = copy.deepcopy(self.locations, memo)
        return type(self)(self.image, self.context, self.db_api)

    def append(self, object):
        self._check_user_storage_quota([object])
        return self.locations.append(object)

    def insert(self, index, object):
        self._check_user_storage_quota([object])
        return self.locations.insert(index, object)

    def extend(self, iter):
        self._check_user_storage_quota(iter)
        return self.locations.extend(iter)


class ImageProxy(glance.domain.proxy.Image):"
489,apps/glance/glance/quota/__init__.py,user,self._check_user_storage_quota,user_storage_quota,self._check_user_storage_quota,"def append(self, object):
        self._check_user_storage_quota([object])
        return self.locations.append(object)

    def insert(self, index, object):
        self._check_user_storage_quota([object])
        return self.locations.insert(index, object)

    def extend(self, iter):
        self._check_user_storage_quota(iter)
        return self.locations.extend(iter)


class ImageProxy(glance.domain.proxy.Image):

    def __init__(self, image, context, db_api, store_utils):
        self.image = image
        self.context = context
        self.db_api = db_api"
490,apps/glance/glance/quota/__init__.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"for location in locations:
            size_from_backend = None

            try:
                if CONF.enabled_backends:
                    size_from_backend = store.get_size_from_uri_and_backend(
                        location['url'], location['metadata'].get('store'),
                        context=context)
                else:
                    size_from_backend = store.get_size_from_backend(
                        location['url'], context=context)
            except (store.UnknownScheme, store.NotFound):
                pass
            except store.BadStoreUri:
                raise exception.BadStoreUri

            if size_from_backend:
                required_size = size_from_backend * len(locations)
                break"
491,apps/glance/glance/quota/__init__.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"if image.size:
        required_size = image.size * len(locations)
    else:
        for location in locations:
            size_from_backend = None

            try:
                if CONF.enabled_backends:
                    size_from_backend = store.get_size_from_uri_and_backend(
                        location['url'], location['metadata'].get('store'),
                        context=context)
                else:
                    size_from_backend = store.get_size_from_backend(
                        location['url'], context=context)
            except (store.UnknownScheme, store.NotFound):
                pass
            except store.BadStoreUri:
                raise exception.BadStoreUri

            if size_from_backend:
                required_size = size_from_backend * len(locations)
                break"
492,apps/glance/glance/quota/__init__.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"if CONF.enabled_backends:
                    size_from_backend = store.get_size_from_uri_and_backend(
                        location['url'], location['metadata'].get('store'),
                        context=context)
                else:
                    size_from_backend = store.get_size_from_backend(
                        location['url'], context=context)"
493,apps/glance/glance/quota/__init__.py,debug,LOG.debug,key,_enforce_image_property_quota.attempted,"if attempted > maximum:
            kwargs = {'attempted': attempted, 'maximum': maximum}
            exc = exception.ImagePropertyLimitExceeded(**kwargs)
            LOG.debug(encodeutils.exception_to_unicode(exc))
            raise exc"
494,apps/glance/glance/quota/__init__.py,debug,LOG.debug,key,_enforce_image_property_quota.kwargs,"if attempted > maximum:
            kwargs = {'attempted': attempted, 'maximum': maximum}
            exc = exception.ImagePropertyLimitExceeded(**kwargs)
            LOG.debug(encodeutils.exception_to_unicode(exc))
            raise exc"
495,apps/glance/glance/quota/__init__.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"try:
                if CONF.enabled_backends:
                    size_from_backend = store.get_size_from_uri_and_backend(
                        location['url'], location['metadata'].get('store'),
                        context=context)
                else:
                    size_from_backend = store.get_size_from_backend(
                        location['url'], context=context)
            except (store.UnknownScheme, store.NotFound):
                pass
            except store.BadStoreUri:
                raise exception.BadStoreUri"
496,apps/glance/glance/scrubber.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"if self.metadata_encryption_key:
                    uri = crypt.urlsafe_decrypt(self.metadata_encryption_key,
                                                loc['url'])
                else:
                    uri = loc['url']

                # if multi-store is enabled then we need to pass backend
                # to delete the image.
                backend = loc['metadata'].get('store')
                if CONF.enabled_backends:
                    ret.append((image['id'], loc['id'], uri, backend))
                else:
                    ret.append((image['id'], loc['id'], uri))
        return ret

    def has_image(self, image_id):
        """"""Returns whether the queue contains an image or not.

        :param image_id: The opaque image identifier"
497,apps/glance/glance/scrubber.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"records = self.db_queue.get_all_locations()
        except Exception as err:
            # Note(dharinic): spawn_n, in Daemon mode will log the
            # exception raised. Otherwise, exit 1 will occur.
            msg = (_LC(""Can not get scrub jobs from queue: %s"") %
                   encodeutils.exception_to_unicode(err))
            LOG.critical(msg)
            raise exception.FailedToGetScrubberJobs()

        delete_jobs = {}
        if CONF.enabled_backends:
            for image_id, loc_id, loc_uri, backend in records:
                if image_id not in delete_jobs:
                    delete_jobs[image_id] = []
                delete_jobs[image_id].append((image_id, loc_id,
                                              loc_uri, backend))
        else:
            for image_id, loc_id, loc_uri in records:
                if image_id not in delete_jobs:
                    delete_jobs[image_id] = []"
498,apps/glance/glance/scrubber.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"list(self.pool.starmap(self._scrub_image, delete_jobs.items()))

    def _scrub_image(self, image_id, delete_jobs):
        if len(delete_jobs) == 0:
            return

        LOG.info(_LI(""Scrubbing image %(id)s from %(count)d locations.""),
                 {'id': image_id, 'count': len(delete_jobs)})

        success = True
        if CONF.enabled_backends:
            for img_id, loc_id, uri, backend in delete_jobs:
                try:
                    self._delete_image_location_from_backend(img_id, loc_id,
                                                             uri,
                                                             backend=backend)
                except Exception:
                    success = False
        else:
            for img_id, loc_id, uri in delete_jobs:"
499,apps/glance/glance/scrubber.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"else:
            LOG.warning(_LW(""One or more image locations couldn't be scrubbed ""
                            ""from backend. Leaving image '%s' in ""
                            ""'pending_delete' status""), image_id)

    def _delete_image_location_from_backend(self, image_id, loc_id, uri,
                                            backend=None):
        try:
            LOG.debug(""Scrubbing image %s from a location."", image_id)
            try:
                if CONF.enabled_backends:
                    self.store_api.delete(uri, backend, self.admin_context)
                else:
                    self.store_api.delete_from_backend(uri, self.admin_context)
            except store_exceptions.NotFound:
                LOG.info(_LI(""Image location for image '%s' not found in ""
                             ""backend; Marking image location deleted in ""
                             ""db.""), image_id)

            if loc_id != '-':"
500,apps/glance/glance/scrubber.py,enabled,CONF.enabled_backends,key,self.metadata_encryption_key,"for image in self._get_all_images():
            deleted_at = image.get('deleted_at')
            if not deleted_at:
                continue
            # NOTE: Strip off microseconds which may occur after the last '.,'
            # Example: 2012-07-07T19:14:34.974216
            deleted_at = timeutils.isotime(deleted_at)
            date_str = deleted_at.rsplit('.', 1)[0].rsplit(',', 1)[0]
            delete_time = calendar.timegm(time.strptime(date_str,
                                                        ""%Y-%m-%dT%H:%M:%SZ""))

            if delete_time + self.scrub_time > time.time():
                continue

            for loc in image['locations']:
                if loc['status'] != 'pending_delete':
                    continue

                if self.metadata_encryption_key:
                    uri = crypt.urlsafe_decrypt(self.metadata_encryption_key,
                                                loc['url'])
                else:
                    uri = loc['url']

                # if multi-store is enabled then we need to pass backend
                # to delete the image.
                backend = loc['metadata'].get('store')
                if CONF.enabled_backends:
                    ret.append((image['id'], loc['id'], uri, backend))
                else:
                    ret.append((image['id'], loc['id'], uri))"
501,apps/glance/glance/scrubber.py,enabled,CONF.enabled_backends,key,get_all_locations.self.metadata_encryption_key,"for image in self._get_all_images():
            deleted_at = image.get('deleted_at')
            if not deleted_at:
                continue
            # NOTE: Strip off microseconds which may occur after the last '.,'
            # Example: 2012-07-07T19:14:34.974216
            deleted_at = timeutils.isotime(deleted_at)
            date_str = deleted_at.rsplit('.', 1)[0].rsplit(',', 1)[0]
            delete_time = calendar.timegm(time.strptime(date_str,
                                                        ""%Y-%m-%dT%H:%M:%SZ""))

            if delete_time + self.scrub_time > time.time():
                continue

            for loc in image['locations']:
                if loc['status'] != 'pending_delete':
                    continue

                if self.metadata_encryption_key:
                    uri = crypt.urlsafe_decrypt(self.metadata_encryption_key,
                                                loc['url'])
                else:
                    uri = loc['url']

                # if multi-store is enabled then we need to pass backend
                # to delete the image.
                backend = loc['metadata'].get('store')
                if CONF.enabled_backends:
                    ret.append((image['id'], loc['id'], uri, backend))
                else:
                    ret.append((image['id'], loc['id'], uri))"
502,apps/glance/glance/scrubber.py,enabled_backends,CONF.enabled_backends,key,self.metadata_encryption_key,"for image in self._get_all_images():
            deleted_at = image.get('deleted_at')
            if not deleted_at:
                continue
            # NOTE: Strip off microseconds which may occur after the last '.,'
            # Example: 2012-07-07T19:14:34.974216
            deleted_at = timeutils.isotime(deleted_at)
            date_str = deleted_at.rsplit('.', 1)[0].rsplit(',', 1)[0]
            delete_time = calendar.timegm(time.strptime(date_str,
                                                        ""%Y-%m-%dT%H:%M:%SZ""))

            if delete_time + self.scrub_time > time.time():
                continue

            for loc in image['locations']:
                if loc['status'] != 'pending_delete':
                    continue

                if self.metadata_encryption_key:
                    uri = crypt.urlsafe_decrypt(self.metadata_encryption_key,
                                                loc['url'])
                else:
                    uri = loc['url']

                # if multi-store is enabled then we need to pass backend
                # to delete the image.
                backend = loc['metadata'].get('store')
                if CONF.enabled_backends:
                    ret.append((image['id'], loc['id'], uri, backend))
                else:
                    ret.append((image['id'], loc['id'], uri))"
503,apps/glance/glance/scrubber.py,enabled_backends,CONF.enabled_backends,key,get_all_locations.self.metadata_encryption_key,"for image in self._get_all_images():
            deleted_at = image.get('deleted_at')
            if not deleted_at:
                continue
            # NOTE: Strip off microseconds which may occur after the last '.,'
            # Example: 2012-07-07T19:14:34.974216
            deleted_at = timeutils.isotime(deleted_at)
            date_str = deleted_at.rsplit('.', 1)[0].rsplit(',', 1)[0]
            delete_time = calendar.timegm(time.strptime(date_str,
                                                        ""%Y-%m-%dT%H:%M:%SZ""))

            if delete_time + self.scrub_time > time.time():
                continue

            for loc in image['locations']:
                if loc['status'] != 'pending_delete':
                    continue

                if self.metadata_encryption_key:
                    uri = crypt.urlsafe_decrypt(self.metadata_encryption_key,
                                                loc['url'])
                else:
                    uri = loc['url']

                # if multi-store is enabled then we need to pass backend
                # to delete the image.
                backend = loc['metadata'].get('store')
                if CONF.enabled_backends:
                    ret.append((image['id'], loc['id'], uri, backend))
                else:
                    ret.append((image['id'], loc['id'], uri))"
504,apps/glance/glance/scrubber.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"for image in self._get_all_images():
            deleted_at = image.get('deleted_at')
            if not deleted_at:
                continue
            # NOTE: Strip off microseconds which may occur after the last '.,'
            # Example: 2012-07-07T19:14:34.974216
            deleted_at = timeutils.isotime(deleted_at)
            date_str = deleted_at.rsplit('.', 1)[0].rsplit(',', 1)[0]
            delete_time = calendar.timegm(time.strptime(date_str,
                                                        ""%Y-%m-%dT%H:%M:%SZ""))

            if delete_time + self.scrub_time > time.time():
                continue

            for loc in image['locations']:
                if loc['status'] != 'pending_delete':
                    continue

                if self.metadata_encryption_key:
                    uri = crypt.urlsafe_decrypt(self.metadata_encryption_key,
                                                loc['url'])
                else:
                    uri = loc['url']

                # if multi-store is enabled then we need to pass backend
                # to delete the image.
                backend = loc['metadata'].get('store')
                if CONF.enabled_backends:
                    ret.append((image['id'], loc['id'], uri, backend))
                else:
                    ret.append((image['id'], loc['id'], uri))"
505,apps/glance/glance/scrubber.py,enabled,CONF.enabled_backends,key,self.metadata_encryption_key,"for loc in image['locations']:
                if loc['status'] != 'pending_delete':
                    continue

                if self.metadata_encryption_key:
                    uri = crypt.urlsafe_decrypt(self.metadata_encryption_key,
                                                loc['url'])
                else:
                    uri = loc['url']

                # if multi-store is enabled then we need to pass backend
                # to delete the image.
                backend = loc['metadata'].get('store')
                if CONF.enabled_backends:
                    ret.append((image['id'], loc['id'], uri, backend))
                else:
                    ret.append((image['id'], loc['id'], uri))"
506,apps/glance/glance/scrubber.py,enabled,CONF.enabled_backends,key,get_all_locations.self.metadata_encryption_key,"for loc in image['locations']:
                if loc['status'] != 'pending_delete':
                    continue

                if self.metadata_encryption_key:
                    uri = crypt.urlsafe_decrypt(self.metadata_encryption_key,
                                                loc['url'])
                else:
                    uri = loc['url']

                # if multi-store is enabled then we need to pass backend
                # to delete the image.
                backend = loc['metadata'].get('store')
                if CONF.enabled_backends:
                    ret.append((image['id'], loc['id'], uri, backend))
                else:
                    ret.append((image['id'], loc['id'], uri))"
507,apps/glance/glance/scrubber.py,enabled_backends,CONF.enabled_backends,key,self.metadata_encryption_key,"for loc in image['locations']:
                if loc['status'] != 'pending_delete':
                    continue

                if self.metadata_encryption_key:
                    uri = crypt.urlsafe_decrypt(self.metadata_encryption_key,
                                                loc['url'])
                else:
                    uri = loc['url']

                # if multi-store is enabled then we need to pass backend
                # to delete the image.
                backend = loc['metadata'].get('store')
                if CONF.enabled_backends:
                    ret.append((image['id'], loc['id'], uri, backend))
                else:
                    ret.append((image['id'], loc['id'], uri))"
508,apps/glance/glance/scrubber.py,enabled_backends,CONF.enabled_backends,key,get_all_locations.self.metadata_encryption_key,"for loc in image['locations']:
                if loc['status'] != 'pending_delete':
                    continue

                if self.metadata_encryption_key:
                    uri = crypt.urlsafe_decrypt(self.metadata_encryption_key,
                                                loc['url'])
                else:
                    uri = loc['url']

                # if multi-store is enabled then we need to pass backend
                # to delete the image.
                backend = loc['metadata'].get('store')
                if CONF.enabled_backends:
                    ret.append((image['id'], loc['id'], uri, backend))
                else:
                    ret.append((image['id'], loc['id'], uri))"
509,apps/glance/glance/scrubber.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"for loc in image['locations']:
                if loc['status'] != 'pending_delete':
                    continue

                if self.metadata_encryption_key:
                    uri = crypt.urlsafe_decrypt(self.metadata_encryption_key,
                                                loc['url'])
                else:
                    uri = loc['url']

                # if multi-store is enabled then we need to pass backend
                # to delete the image.
                backend = loc['metadata'].get('store')
                if CONF.enabled_backends:
                    ret.append((image['id'], loc['id'], uri, backend))
                else:
                    ret.append((image['id'], loc['id'], uri))"
510,apps/glance/glance/scrubber.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"if CONF.enabled_backends:
                    ret.append((image['id'], loc['id'], uri, backend))
                else:
                    ret.append((image['id'], loc['id'], uri))"
511,apps/glance/glance/scrubber.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"if CONF.enabled_backends:
            for image_id, loc_id, loc_uri, backend in records:
                if image_id not in delete_jobs:
                    delete_jobs[image_id] = []
                delete_jobs[image_id].append((image_id, loc_id,
                                              loc_uri, backend))
        else:
            for image_id, loc_id, loc_uri in records:
                if image_id not in delete_jobs:
                    delete_jobs[image_id] = []
                delete_jobs[image_id].append((image_id, loc_id, loc_uri))"
512,apps/glance/glance/scrubber.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"if CONF.enabled_backends:
            for img_id, loc_id, uri, backend in delete_jobs:
                try:
                    self._delete_image_location_from_backend(img_id, loc_id,
                                                             uri,
                                                             backend=backend)
                except Exception:
                    success = False
        else:
            for img_id, loc_id, uri in delete_jobs:
                try:
                    self._delete_image_location_from_backend(img_id, loc_id,
                                                             uri)
                except Exception:
                    success = False"
513,apps/glance/glance/scrubber.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"if CONF.enabled_backends:
                    self.store_api.delete(uri, backend, self.admin_context)
                else:
                    self.store_api.delete_from_backend(uri, self.admin_context)"
514,apps/glance/glance/scrubber.py,debug,LOG.debug,enabled,CONF.enabled_backends,"try:
            LOG.debug(""Scrubbing image %s from a location."", image_id)
            try:
                if CONF.enabled_backends:
                    self.store_api.delete(uri, backend, self.admin_context)
                else:
                    self.store_api.delete_from_backend(uri, self.admin_context)
            except store_exceptions.NotFound:
                LOG.info(_LI(""Image location for image '%s' not found in ""
                             ""backend; Marking image location deleted in ""
                             ""db.""), image_id)

            if loc_id != '-':
                db_api.get_api().image_location_delete(self.admin_context,
                                                       image_id,
                                                       int(loc_id),
                                                       'deleted')
            LOG.info(_LI(""Image %s is scrubbed from a location.""), image_id)
        except Exception as e:
            LOG.error(_LE(""Unable to scrub image %(id)s from a location. ""
                          ""Reason: %(exc)s ""),
                      {'id': image_id,
                       'exc': encodeutils.exception_to_unicode(e)})
            raise"
515,apps/glance/glance/scrubber.py,debug,LOG.debug,enabled_backends,CONF.enabled_backends,"try:
            LOG.debug(""Scrubbing image %s from a location."", image_id)
            try:
                if CONF.enabled_backends:
                    self.store_api.delete(uri, backend, self.admin_context)
                else:
                    self.store_api.delete_from_backend(uri, self.admin_context)
            except store_exceptions.NotFound:
                LOG.info(_LI(""Image location for image '%s' not found in ""
                             ""backend; Marking image location deleted in ""
                             ""db.""), image_id)

            if loc_id != '-':
                db_api.get_api().image_location_delete(self.admin_context,
                                                       image_id,
                                                       int(loc_id),
                                                       'deleted')
            LOG.info(_LI(""Image %s is scrubbed from a location.""), image_id)
        except Exception as e:
            LOG.error(_LE(""Unable to scrub image %(id)s from a location. ""
                          ""Reason: %(exc)s ""),
                      {'id': image_id,
                       'exc': encodeutils.exception_to_unicode(e)})
            raise"
516,apps/glance/glance/scrubber.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"try:
            LOG.debug(""Scrubbing image %s from a location."", image_id)
            try:
                if CONF.enabled_backends:
                    self.store_api.delete(uri, backend, self.admin_context)
                else:
                    self.store_api.delete_from_backend(uri, self.admin_context)
            except store_exceptions.NotFound:
                LOG.info(_LI(""Image location for image '%s' not found in ""
                             ""backend; Marking image location deleted in ""
                             ""db.""), image_id)

            if loc_id != '-':
                db_api.get_api().image_location_delete(self.admin_context,
                                                       image_id,
                                                       int(loc_id),
                                                       'deleted')
            LOG.info(_LI(""Image %s is scrubbed from a location.""), image_id)
        except Exception as e:
            LOG.error(_LE(""Unable to scrub image %(id)s from a location. ""
                          ""Reason: %(exc)s ""),
                      {'id': image_id,
                       'exc': encodeutils.exception_to_unicode(e)})
            raise"
517,apps/glance/glance/scrubber.py,enabled,CONF.enabled_backends,enabled_backends,CONF.enabled_backends,"try:
                if CONF.enabled_backends:
                    self.store_api.delete(uri, backend, self.admin_context)
                else:
                    self.store_api.delete_from_backend(uri, self.admin_context)
            except store_exceptions.NotFound:
                LOG.info(_LI(""Image location for image '%s' not found in ""
                             ""backend; Marking image location deleted in ""
                             ""db.""), image_id)"
518,apps/glance/glance/sqlite_migration.py,image_cache_dir,get_db_path.base_dir,image_cache_sqlite_db,get_db_path.db,"LOG.info(""Initiating migration process from SQLite to Centralized ""
                     ""database"")
            migrate = Migrate(sqlite_db_file, glance.db.get_api())
            migrate.migrate()


def get_db_path():
    """"""Return the local path to sqlite database.""""""
    db = CONF.image_cache_sqlite_db
    base_dir = CONF.image_cache_dir
    db_file = os.path.join(base_dir, db)
    if not os.path.exists(db_file):
        LOG.debug('SQLite caching database not located, skipping migration')
        return

    return db_file


class Migrate:
    def __init__(self, db, db_api):"
519,apps/glance/glance/sqlite_migration.py,image_cache_dir,get_db_path.base_dir,image_cache_sqlite_db,get_db_path.db,"LOG.info(""Initiating migration process from SQLite to Centralized ""
                     ""database"")
            migrate = Migrate(sqlite_db_file, glance.db.get_api())
            migrate.migrate()


def get_db_path():
    """"""Return the local path to sqlite database.""""""
    db = CONF.image_cache_sqlite_db
    base_dir = CONF.image_cache_dir
    db_file = os.path.join(base_dir, db)
    if not os.path.exists(db_file):
        LOG.debug('SQLite caching database not located, skipping migration')
        return

    return db_file


class Migrate:
    def __init__(self, db, db_api):"
520,apps/glance/glance/sqlite_migration.py,image_cache_dir,get_db_path.base_dir,image_cache_sqlite_db,get_db_path.db,"LOG.info(""Initiating migration process from SQLite to Centralized ""
                     ""database"")
            migrate = Migrate(sqlite_db_file, glance.db.get_api())
            migrate.migrate()


def get_db_path():
    """"""Return the local path to sqlite database.""""""
    db = CONF.image_cache_sqlite_db
    base_dir = CONF.image_cache_dir
    db_file = os.path.join(base_dir, db)
    if not os.path.exists(db_file):
        LOG.debug('SQLite caching database not located, skipping migration')
        return

    return db_file


class Migrate:
    def __init__(self, db, db_api):"
521,apps/glance/glance/sqlite_migration.py,image_cache_dir,get_db_path.base_dir,image_cache_sqlite_db,get_db_path.db,"LOG.info(""Initiating migration process from SQLite to Centralized ""
                     ""database"")
            migrate = Migrate(sqlite_db_file, glance.db.get_api())
            migrate.migrate()


def get_db_path():
    """"""Return the local path to sqlite database.""""""
    db = CONF.image_cache_sqlite_db
    base_dir = CONF.image_cache_dir
    db_file = os.path.join(base_dir, db)
    if not os.path.exists(db_file):
        LOG.debug('SQLite caching database not located, skipping migration')
        return

    return db_file


class Migrate:
    def __init__(self, db, db_api):"
522,apps/glance/glance/sqlite_migration.py,image_cache_dir,get_db_path.db_file,image_cache_sqlite_db,get_db_path.db_file,"def get_db_path():
    """"""Return the local path to sqlite database.""""""
    db = CONF.image_cache_sqlite_db
    base_dir = CONF.image_cache_dir
    db_file = os.path.join(base_dir, db)
    if not os.path.exists(db_file):
        LOG.debug('SQLite caching database not located, skipping migration')
        return

    return db_file


class Migrate:
    def __init__(self, db, db_api):
        self.db = db
        self.db_api = db_api
        self.context = context.get_admin_context()
        self.node_reference = CONF.worker_self_reference_url"
523,apps/glance/glance/sqlite_migration.py,image_cache_dir,get_db_path.db_file,image_cache_sqlite_db,get_db_path.db_file,"def get_db_path():
    """"""Return the local path to sqlite database.""""""
    db = CONF.image_cache_sqlite_db
    base_dir = CONF.image_cache_dir
    db_file = os.path.join(base_dir, db)
    if not os.path.exists(db_file):
        LOG.debug('SQLite caching database not located, skipping migration')
        return

    return db_file


class Migrate:
    def __init__(self, db, db_api):
        self.db = db
        self.db_api = db_api
        self.context = context.get_admin_context()
        self.node_reference = CONF.worker_self_reference_url"
524,apps/glance/glance/sqlite_migration.py,image_cache_dir,get_db_path.db_file,image_cache_sqlite_db,get_db_path.db_file,"def get_db_path():
    """"""Return the local path to sqlite database.""""""
    db = CONF.image_cache_sqlite_db
    base_dir = CONF.image_cache_dir
    db_file = os.path.join(base_dir, db)
    if not os.path.exists(db_file):
        LOG.debug('SQLite caching database not located, skipping migration')
        return

    return db_file


class Migrate:
    def __init__(self, db, db_api):
        self.db = db
        self.db_api = db_api
        self.context = context.get_admin_context()
        self.node_reference = CONF.worker_self_reference_url"
525,apps/glance/glance/sqlite_migration.py,image_cache_dir,get_db_path.db_file,image_cache_sqlite_db,get_db_path.db_file,"def get_db_path():
    """"""Return the local path to sqlite database.""""""
    db = CONF.image_cache_sqlite_db
    base_dir = CONF.image_cache_dir
    db_file = os.path.join(base_dir, db)
    if not os.path.exists(db_file):
        LOG.debug('SQLite caching database not located, skipping migration')
        return

    return db_file


class Migrate:
    def __init__(self, db, db_api):
        self.db = db
        self.db_api = db_api
        self.context = context.get_admin_context()
        self.node_reference = CONF.worker_self_reference_url"
